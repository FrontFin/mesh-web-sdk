/* tslint:disable */
/* eslint-disable */
/**
 * Front Financial Integration Catalog API
 * Front Integration Catalog allows users of client applications to connect accounts of financial institutions. Front Integration Catalog handles credential validation, multi-factor authentication, and error handling for each institution. After the account is connected, Front Integration Catalog allows client applications to get account information, such as holdings, transactions, balances.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface ApiResult
 */
export interface ApiResult {
    /**
     *
     * @type {ApiResultStatus}
     * @memberof ApiResult
     */
    'status'?: ApiResultStatusEnum;
    /**
     * A message generated by the API
     * @type {string}
     * @memberof ApiResult
     */
    'message'?: string | null;
    /**
     * User-friendly display message that can be presented to the end user
     * @type {string}
     * @memberof ApiResult
     */
    'displayMessage'?: string | null;
}

export const ApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type ApiResultStatusEnum = typeof ApiResultStatusEnum[keyof typeof ApiResultStatusEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const ApiResultStatus = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type ApiResultStatus = typeof ApiResultStatus[keyof typeof ApiResultStatus];


/**
 *
 * @export
 * @interface ApiV1AuthenticatePostRequest
 */
export interface ApiV1AuthenticatePostRequest {
    /**
     *
     * @type {BrokerType}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'type': ApiV1AuthenticatePostRequestTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'username'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'password'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'tradePin'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'challengeId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'challengeCode'?: string | null;
    /**
     * Used to provide answers to security questions
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'challengeAnswer'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'mfaCode'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'key'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'authToken'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'redirectLink'?: string | null;
    /**
     *
     * @type {B2BBrokerCryptocurrencyWalletAuthRequest}
     * @memberof ApiV1AuthenticatePostRequest
     */
    'cryptocurrencyWalletAuthData'?: B2BBrokerCryptocurrencyWalletAuthRequest | null;
}

export const ApiV1AuthenticatePostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1AuthenticatePostRequestTypeEnum = typeof ApiV1AuthenticatePostRequestTypeEnum[keyof typeof ApiV1AuthenticatePostRequestTypeEnum];

/**
 *
 * @export
 * @interface ApiV1BalanceGetPostRequest
 */
export interface ApiV1BalanceGetPostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1BalanceGetPostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1BalanceGetPostRequest
     */
    'type': ApiV1BalanceGetPostRequestTypeEnum;
}

export const ApiV1BalanceGetPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1BalanceGetPostRequestTypeEnum = typeof ApiV1BalanceGetPostRequestTypeEnum[keyof typeof ApiV1BalanceGetPostRequestTypeEnum];

/**
 *
 * @export
 * @interface ApiV1TokenRefreshPostRequest
 */
export interface ApiV1TokenRefreshPostRequest {
    /**
     *
     * @type {BrokerType}
     * @memberof ApiV1TokenRefreshPostRequest
     */
    'type': ApiV1TokenRefreshPostRequestTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ApiV1TokenRefreshPostRequest
     */
    'refreshToken': string;
    /**
     * Optional, used when we the refresh token should be refreshed.  Currently this flow is supported by TD Ameritrade
     * @type {boolean}
     * @memberof ApiV1TokenRefreshPostRequest
     */
    'createNewRefreshToken'?: boolean | null;
    /**
     * Some institutions may require accessToken to be provided as well.  It\'s currently required by WeBull only
     * @type {string}
     * @memberof ApiV1TokenRefreshPostRequest
     */
    'accessToken'?: string | null;
    /**
     * Currently used to update WeBull trade token.
     * @type {string}
     * @memberof ApiV1TokenRefreshPostRequest
     */
    'tradeToken'?: string | null;
    /**
     * Additional metadata
     * @type {{ [key: string]: string; }}
     * @memberof ApiV1TokenRefreshPostRequest
     */
    'metadata'?: { [key: string]: string; } | null;
}

export const ApiV1TokenRefreshPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TokenRefreshPostRequestTypeEnum = typeof ApiV1TokenRefreshPostRequestTypeEnum[keyof typeof ApiV1TokenRefreshPostRequestTypeEnum];

/**
 *
 * @export
 * @interface ApiV1TransactionsDetailsPostRequest
 */
export interface ApiV1TransactionsDetailsPostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1TransactionsDetailsPostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1TransactionsDetailsPostRequest
     */
    'type': ApiV1TransactionsDetailsPostRequestTypeEnum;
    /**
     *
     * @type {string}
     * @memberof ApiV1TransactionsDetailsPostRequest
     */
    'id': string;
    /**
     * Should be provided for Coinbase.
     * @type {BrokerOrderType}
     * @memberof ApiV1TransactionsDetailsPostRequest
     */
    'side'?: BrokerOrderType | null;
    /**
     * Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought.
     * @type {boolean}
     * @memberof ApiV1TransactionsDetailsPostRequest
     */
    'isCryptocurrency': boolean;
    /**
     * Symbol pair of the order (requested by some brokers).
     * @type {string}
     * @memberof ApiV1TransactionsDetailsPostRequest
     */
    'symbolPair'?: string | null;
}

export const ApiV1TransactionsDetailsPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TransactionsDetailsPostRequestTypeEnum = typeof ApiV1TransactionsDetailsPostRequestTypeEnum[keyof typeof ApiV1TransactionsDetailsPostRequestTypeEnum];

/**
 *
 * @export
 * @interface ApiV1TransactionsListPostRequest
 */
export interface ApiV1TransactionsListPostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1TransactionsListPostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1TransactionsListPostRequest
     */
    'type': ApiV1TransactionsListPostRequestTypeEnum;
    /**
     * The cursor to retrieve the next page of transactions.  Providing it will cause the response to only return changes after this update.  If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
     * @type {string}
     * @memberof ApiV1TransactionsListPostRequest
     */
    'cursor'?: string | null;
    /**
     * Number of records to include in the response. <br />  Default: `100` <br />  Maximum: `250`
     * @type {number}
     * @memberof ApiV1TransactionsListPostRequest
     */
    'count'?: number;
    /**
     * Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned.
     * @type {Array<BrokerOrderStatus>}
     * @memberof ApiV1TransactionsListPostRequest
     */
    'statuses'?: Array<BrokerOrderStatus> | null;
}

export const ApiV1TransactionsListPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TransactionsListPostRequestTypeEnum = typeof ApiV1TransactionsListPostRequestTypeEnum[keyof typeof ApiV1TransactionsListPostRequestTypeEnum];

/**
 *
 * @export
 * @interface ApiV1TransactionsPreviewSidePostRequest
 */
export interface ApiV1TransactionsPreviewSidePostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'type': ApiV1TransactionsPreviewSidePostRequestTypeEnum;
    /**
     * Symbol to trade. For example, `AAPL` or `ETH`
     * @type {string}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'symbol': string;
    /**
     * Symbol to use for payment, defaults to `USD`.
     * @type {string}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'paymentSymbol': string;
    /**
     * Amount of purchase.
     * @type {number}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'amount': number;
    /**
     * Price of the unit, used for `Limit` and `StopLoss` orders.
     * @type {number}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'price'?: number;
    /**
     * Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly.
     * @type {boolean}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'isCryptocurrency': boolean;
    /**
     * Indicates whether the `PaymentSymbol` is fiat or cryptocurrency
     * @type {boolean}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'paymentIsCryptocurrency': boolean;
    /**
     * This value indicates if the order should be executed in fiat amount (e.g. purchase ETH for $10). This can be  performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInFiatAmount` and  `SupportsPlacingBuyOrdersInFiatAmount` fields in `get supported order features for institution`) and `AmountInFiat`  value is passed.
     * @type {boolean}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'amountIsFiat': boolean;
    /**
     * Specifies the target amount in fiat currency. For example setting this to `10` when the `AmountIsFiat` = `true`  and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
     * @type {number}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'amountInFiat'?: number | null;
    /**
     * Specifies if the extended trading hours should be used.
     * @type {boolean}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'extendedHours'?: boolean;
    /**
     *
     * @type {BrokerOrderPlaceType}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'orderType': ApiV1TransactionsPreviewSidePostRequestOrderTypeEnum;
    /**
     *
     * @type {BrokerOrderTimeInForceType}
     * @memberof ApiV1TransactionsPreviewSidePostRequest
     */
    'timeInForce': ApiV1TransactionsPreviewSidePostRequestTimeInForceEnum;
}

export const ApiV1TransactionsPreviewSidePostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TransactionsPreviewSidePostRequestTypeEnum = typeof ApiV1TransactionsPreviewSidePostRequestTypeEnum[keyof typeof ApiV1TransactionsPreviewSidePostRequestTypeEnum];
export const ApiV1TransactionsPreviewSidePostRequestOrderTypeEnum = {
    Unknown: 'Unknown',
    Market: 'Market',
    Limit: 'Limit',
    StopLoss: 'StopLoss',
    StopLimit: 'StopLimit',
    NetDebit: 'NetDebit',
    NetCredit: 'NetCredit',
    Exercise: 'Exercise'
} as const;

export type ApiV1TransactionsPreviewSidePostRequestOrderTypeEnum = typeof ApiV1TransactionsPreviewSidePostRequestOrderTypeEnum[keyof typeof ApiV1TransactionsPreviewSidePostRequestOrderTypeEnum];
export const ApiV1TransactionsPreviewSidePostRequestTimeInForceEnum = {
    GoodTillCanceled: 'GoodTillCanceled',
    ImmediateOrCancel: 'ImmediateOrCancel',
    FillOrKill: 'FillOrKill',
    GoodForDay: 'GoodForDay',
    PostOnly: 'PostOnly'
} as const;

export type ApiV1TransactionsPreviewSidePostRequestTimeInForceEnum = typeof ApiV1TransactionsPreviewSidePostRequestTimeInForceEnum[keyof typeof ApiV1TransactionsPreviewSidePostRequestTimeInForceEnum];

/**
 *
 * @export
 * @interface ApiV1TransactionsSymbolinfoPostRequest
 */
export interface ApiV1TransactionsSymbolinfoPostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'type': ApiV1TransactionsSymbolinfoPostRequestTypeEnum;
    /**
     * Symbol to trade. For example, `AAPL` or `ETH`
     * @type {string}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'symbol': string;
    /**
     * Symbol to use for payment, defaults to `USD`.
     * @type {string}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'paymentSymbol': string;
    /**
     * Amount of purchase.
     * @type {number}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'amount': number;
    /**
     * Price of the unit, used for `Limit` and `StopLoss` orders.
     * @type {number}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'price'?: number;
    /**
     * Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly.
     * @type {boolean}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'isCryptocurrency': boolean;
    /**
     * Indicates whether the `PaymentSymbol` is fiat or cryptocurrency
     * @type {boolean}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'paymentIsCryptocurrency': boolean;
    /**
     * This value indicates if the order should be executed in fiat amount (e.g. purchase ETH for $10). This can be  performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInFiatAmount` and  `SupportsPlacingBuyOrdersInFiatAmount` fields in `get supported order features for institution`) and `AmountInFiat`  value is passed.
     * @type {boolean}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'amountIsFiat': boolean;
    /**
     * Specifies the target amount in fiat currency. For example setting this to `10` when the `AmountIsFiat` = `true`  and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
     * @type {number}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'amountInFiat'?: number | null;
    /**
     * Specifies if the extended trading hours should be used.
     * @type {boolean}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'extendedHours'?: boolean;
    /**
     *
     * @type {BrokerOrderPlaceType}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'orderType': ApiV1TransactionsSymbolinfoPostRequestOrderTypeEnum;
    /**
     *
     * @type {BrokerOrderTimeInForceType}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'timeInForce': ApiV1TransactionsSymbolinfoPostRequestTimeInForceEnum;
    /**
     *
     * @type {BrokerOrderType}
     * @memberof ApiV1TransactionsSymbolinfoPostRequest
     */
    'side'?: BrokerOrderType | null;
}

export const ApiV1TransactionsSymbolinfoPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TransactionsSymbolinfoPostRequestTypeEnum = typeof ApiV1TransactionsSymbolinfoPostRequestTypeEnum[keyof typeof ApiV1TransactionsSymbolinfoPostRequestTypeEnum];
export const ApiV1TransactionsSymbolinfoPostRequestOrderTypeEnum = {
    Unknown: 'Unknown',
    Market: 'Market',
    Limit: 'Limit',
    StopLoss: 'StopLoss',
    StopLimit: 'StopLimit',
    NetDebit: 'NetDebit',
    NetCredit: 'NetCredit',
    Exercise: 'Exercise'
} as const;

export type ApiV1TransactionsSymbolinfoPostRequestOrderTypeEnum = typeof ApiV1TransactionsSymbolinfoPostRequestOrderTypeEnum[keyof typeof ApiV1TransactionsSymbolinfoPostRequestOrderTypeEnum];
export const ApiV1TransactionsSymbolinfoPostRequestTimeInForceEnum = {
    GoodTillCanceled: 'GoodTillCanceled',
    ImmediateOrCancel: 'ImmediateOrCancel',
    FillOrKill: 'FillOrKill',
    GoodForDay: 'GoodForDay',
    PostOnly: 'PostOnly'
} as const;

export type ApiV1TransactionsSymbolinfoPostRequestTimeInForceEnum = typeof ApiV1TransactionsSymbolinfoPostRequestTimeInForceEnum[keyof typeof ApiV1TransactionsSymbolinfoPostRequestTimeInForceEnum];

/**
 *
 * @export
 * @interface ApiV1TransfersAddressGetPostRequest
 */
export interface ApiV1TransfersAddressGetPostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1TransfersAddressGetPostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1TransfersAddressGetPostRequest
     */
    'type': ApiV1TransfersAddressGetPostRequestTypeEnum;
    /**
     * Symbol of the required cryptocurrency, e.g. ETH or BTC.  Can be used instead of the `AddressType` field.
     * @type {string}
     * @memberof ApiV1TransfersAddressGetPostRequest
     */
    'symbol'?: string | null;
    /**
     * Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.  Can be used instead of `Symbol` field.
     * @type {CryptocurrencyAddressType}
     * @memberof ApiV1TransfersAddressGetPostRequest
     */
    'addressType'?: CryptocurrencyAddressType | null;
    /**
     * Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni
     * @type {string}
     * @memberof ApiV1TransfersAddressGetPostRequest
     */
    'chain'?: string | null;
}

export const ApiV1TransfersAddressGetPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TransfersAddressGetPostRequestTypeEnum = typeof ApiV1TransfersAddressGetPostRequestTypeEnum[keyof typeof ApiV1TransfersAddressGetPostRequestTypeEnum];

/**
 *
 * @export
 * @interface ApiV1TransfersDetailsPostRequest
 */
export interface ApiV1TransfersDetailsPostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1TransfersDetailsPostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1TransfersDetailsPostRequest
     */
    'type': ApiV1TransfersDetailsPostRequestTypeEnum;
    /**
     * Type of the address of the transferred asset. Can be used instead of the `Symbol` field.
     * @type {CryptocurrencyAddressType}
     * @memberof ApiV1TransfersDetailsPostRequest
     */
    'addressType'?: CryptocurrencyAddressType | null;
    /**
     * Transaction Id by the financial institution
     * @type {string}
     * @memberof ApiV1TransfersDetailsPostRequest
     */
    'transactionId'?: string | null;
    /**
     * Hash of the transaction on the blockchain
     * @type {string}
     * @memberof ApiV1TransfersDetailsPostRequest
     */
    'transactionHash'?: string | null;
    /**
     * Symbol of the transferred asset. Can be provided instead of the `AddressType` field.
     * @type {string}
     * @memberof ApiV1TransfersDetailsPostRequest
     */
    'symbol'?: string | null;
}

export const ApiV1TransfersDetailsPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TransfersDetailsPostRequestTypeEnum = typeof ApiV1TransfersDetailsPostRequestTypeEnum[keyof typeof ApiV1TransfersDetailsPostRequestTypeEnum];

/**
 *
 * @export
 * @interface ApiV1TransfersListPostRequest
 */
export interface ApiV1TransfersListPostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1TransfersListPostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1TransfersListPostRequest
     */
    'type': ApiV1TransfersListPostRequestTypeEnum;
    /**
     * Number of records to include in the response. <br />  Default: `100` <br />  Maximum: `250`
     * @type {number}
     * @memberof ApiV1TransfersListPostRequest
     */
    'count'?: number;
    /**
     * The cursor to retrieve the next page of transactions.  Providing it will cause the response to only return changes after this update.  If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
     * @type {string}
     * @memberof ApiV1TransfersListPostRequest
     */
    'cursor'?: string | null;
    /**
     * If this value is provided, result set is filtered to only include transaction with the provided statuses.
     * @type {Array<BrokerCryptocurrencyTransactionStatus>}
     * @memberof ApiV1TransfersListPostRequest
     */
    'statuses'?: Array<BrokerCryptocurrencyTransactionStatus> | null;
    /**
     * For cryptocurrency address the type of address is required.
     * @type {CryptocurrencyAddressType}
     * @memberof ApiV1TransfersListPostRequest
     */
    'cryptocurrencyAddressType'?: CryptocurrencyAddressType | null;
}

export const ApiV1TransfersListPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TransfersListPostRequestTypeEnum = typeof ApiV1TransfersListPostRequestTypeEnum[keyof typeof ApiV1TransfersListPostRequestTypeEnum];

/**
 *
 * @export
 * @interface ApiV1TransfersPostRequest
 */
export interface ApiV1TransfersPostRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof ApiV1TransfersPostRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof ApiV1TransfersPostRequest
     */
    'type': ApiV1TransfersPostRequestTypeEnum;
    /**
     * Additional data to send on-chain (optional, depends on an integration)
     * @type {string}
     * @memberof ApiV1TransfersPostRequest
     */
    'data'?: string | null;
    /**
     * Target address to transfer the asset to
     * @type {string}
     * @memberof ApiV1TransfersPostRequest
     */
    'targetAddress': string;
    /**
     * Amount to transfer
     * @type {number}
     * @memberof ApiV1TransfersPostRequest
     */
    'amount'?: number;
    /**
     * On-chain fee (optional, depends on an integration)
     * @type {number}
     * @memberof ApiV1TransfersPostRequest
     */
    'fee'?: number;
    /**
     * Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.  Can be used instead of `Symbol` and `Chain` fields.  To transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.
     * @type {CryptocurrencyAddressType}
     * @memberof ApiV1TransfersPostRequest
     */
    'addressType'?: CryptocurrencyAddressType | null;
    /**
     * 2 Factor auth code (optional, depends on an integration)
     * @type {string}
     * @memberof ApiV1TransfersPostRequest
     */
    'mfaCode'?: string | null;
    /**
     * Password or pass-phrase, required to send transfers (optional, depends on an integration)
     * @type {string}
     * @memberof ApiV1TransfersPostRequest
     */
    'password'?: string | null;
    /**
     * Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.  Can be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).  Please use `symbol/details` endpoint to get the list of all possible chains.
     * @type {string}
     * @memberof ApiV1TransfersPostRequest
     */
    'chain'?: string | null;
    /**
     * Memo (also called \"Tag\") - address remark.
     * @type {string}
     * @memberof ApiV1TransfersPostRequest
     */
    'memo'?: string | null;
    /**
     * Symbol to be transferred. Can be provided instead of the `AddressType` field.
     * @type {string}
     * @memberof ApiV1TransfersPostRequest
     */
    'symbol'?: string | null;
}

export const ApiV1TransfersPostRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type ApiV1TransfersPostRequestTypeEnum = typeof ApiV1TransfersPostRequestTypeEnum[keyof typeof ApiV1TransfersPostRequestTypeEnum];

/**
 *
 * @export
 * @interface AssetWeight
 */
export interface AssetWeight {
    /**
     *
     * @type {string}
     * @memberof AssetWeight
     */
    'symbol'?: string | null;
    /**
     *
     * @type {number}
     * @memberof AssetWeight
     */
    'weight'?: number;
    /**
     *
     * @type {boolean}
     * @memberof AssetWeight
     */
    'isCrypto'?: boolean | null;
}
/**
 *
 * @export
 * @interface AuthenticationFieldDescription
 */
export interface AuthenticationFieldDescription {
    /**
     * Name of the field, as expected from the API
     * @type {string}
     * @memberof AuthenticationFieldDescription
     */
    'name'?: string | null;
    /**
     *
     * @type {string}
     * @memberof AuthenticationFieldDescription
     */
    'description'?: string | null;
}
/**
 *
 * @export
 * @interface AuthenticationModel
 */
export interface AuthenticationModel {
    /**
     *
     * @type {B2BBrokerAuthResponse}
     * @memberof AuthenticationModel
     */
    'authResponse'?: B2BBrokerAuthResponse | null;
    /**
     * Set of fields that are expected to be provided based on the status of the AuthResponse
     * @type {Array<AuthenticationFieldDescription>}
     * @memberof AuthenticationModel
     */
    'fields'?: Array<AuthenticationFieldDescription> | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const AuthenticationSchemeType = {
    UsernamePassword: 'UsernamePassword',
    OAuth: 'OAuth',
    ApiKey: 'ApiKey',
    BlockchainAddress: 'BlockchainAddress'
} as const;

export type AuthenticationSchemeType = typeof AuthenticationSchemeType[keyof typeof AuthenticationSchemeType];


/**
 *
 * @export
 * @enum {string}
 */

export const B2BAssetType = {
    Equity: 'Equity',
    Cryptocurrency: 'Cryptocurrency',
    Option: 'Option',
    Nft: 'Nft'
} as const;

export type B2BAssetType = typeof B2BAssetType[keyof typeof B2BAssetType];


/**
 *
 * @export
 * @interface B2BBrokerAccountBalance
 */
export interface B2BBrokerAccountBalance {
    /**
     * Withdrawable cash amount on the account.
     * @type {number}
     * @memberof B2BBrokerAccountBalance
     */
    'cash'?: number | null;
    /**
     * Buying power indicating the maximum amount the user can spend to buy assets. E.g. available margin.
     * @type {number}
     * @memberof B2BBrokerAccountBalance
     */
    'buyingPower'?: number | null;
    /**
     * Buying power available for placing cryptocurrency orders.
     * @type {number}
     * @memberof B2BBrokerAccountBalance
     */
    'cryptocurrencyBuyingPower'?: number | null;
    /**
     * ISO 4217 currency code.
     * @type {string}
     * @memberof B2BBrokerAccountBalance
     */
    'currencyCode'?: string | null;
}
/**
 *
 * @export
 * @interface B2BBrokerAccountBalanceModel
 */
export interface B2BBrokerAccountBalanceModel {
    /**
     *
     * @type {Array<B2BBrokerAccountBalance>}
     * @memberof B2BBrokerAccountBalanceModel
     */
    'balances'?: Array<B2BBrokerAccountBalance> | null;
}
/**
 *
 * @export
 * @interface B2BBrokerAccountBalanceModelIApiResult
 */
export interface B2BBrokerAccountBalanceModelIApiResult {
    /**
     *
     * @type {B2BBrokerAccountBalanceModel}
     * @memberof B2BBrokerAccountBalanceModelIApiResult
     */
    'content'?: B2BBrokerAccountBalanceModel | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerAccountBalanceModelIApiResult
     */
    'status'?: B2BBrokerAccountBalanceModelIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAccountBalanceModelIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAccountBalanceModelIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerAccountBalanceModelIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerAccountBalanceModelIApiResultStatusEnum = typeof B2BBrokerAccountBalanceModelIApiResultStatusEnum[keyof typeof B2BBrokerAccountBalanceModelIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerAuthPromptResponse
 */
export interface B2BBrokerAuthPromptResponse {
    /**
     *
     * @type {BrokerAuthPromptStatus}
     * @memberof B2BBrokerAuthPromptResponse
     */
    'status'?: B2BBrokerAuthPromptResponseStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthPromptResponse
     */
    'redirectLink'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthPromptResponse
     */
    'linkToken'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthPromptResponse
     */
    'oAuthToken'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthPromptResponse
     */
    'errorMessage'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthPromptResponse
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerAuthPromptResponseStatusEnum = {
    Failed: 'Failed',
    Redirect: 'Redirect',
    OpenInBrokerModule: 'OpenInBrokerModule'
} as const;

export type B2BBrokerAuthPromptResponseStatusEnum = typeof B2BBrokerAuthPromptResponseStatusEnum[keyof typeof B2BBrokerAuthPromptResponseStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerAuthPromptResponseIApiResult
 */
export interface B2BBrokerAuthPromptResponseIApiResult {
    /**
     *
     * @type {B2BBrokerAuthPromptResponse}
     * @memberof B2BBrokerAuthPromptResponseIApiResult
     */
    'content'?: B2BBrokerAuthPromptResponse | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerAuthPromptResponseIApiResult
     */
    'status'?: B2BBrokerAuthPromptResponseIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthPromptResponseIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthPromptResponseIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerAuthPromptResponseIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerAuthPromptResponseIApiResultStatusEnum = typeof B2BBrokerAuthPromptResponseIApiResultStatusEnum[keyof typeof B2BBrokerAuthPromptResponseIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerAuthRequest
 */
export interface B2BBrokerAuthRequest {
    /**
     *
     * @type {BrokerType}
     * @memberof B2BBrokerAuthRequest
     */
    'type': B2BBrokerAuthRequestTypeEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'username'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'password'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'tradePin'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'challengeId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'challengeCode'?: string | null;
    /**
     * Used to provide answers to security questions
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'challengeAnswer'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'mfaCode'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'key'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'authToken'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthRequest
     */
    'redirectLink'?: string | null;
    /**
     *
     * @type {B2BBrokerCryptocurrencyWalletAuthRequest}
     * @memberof B2BBrokerAuthRequest
     */
    'cryptocurrencyWalletAuthData'?: B2BBrokerCryptocurrencyWalletAuthRequest | null;
}

export const B2BBrokerAuthRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerAuthRequestTypeEnum = typeof B2BBrokerAuthRequestTypeEnum[keyof typeof B2BBrokerAuthRequestTypeEnum];

/**
 *
 * @export
 * @interface B2BBrokerAuthResponse
 */
export interface B2BBrokerAuthResponse {
    /**
     * Status of the request
     * @type {BrokerAuthStatus}
     * @memberof B2BBrokerAuthResponse
     */
    'status'?: B2BBrokerAuthResponseStatusEnum;
    /**
     * Id of the challenge, relevant when the status is `ChallengeIssued`
     * @type {string}
     * @memberof B2BBrokerAuthResponse
     */
    'challengeId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthResponse
     */
    'challengeText'?: string | null;
    /**
     * Life span of the challenge
     * @type {number}
     * @memberof B2BBrokerAuthResponse
     */
    'challengeExpiresInSeconds'?: number | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthResponse
     */
    'errorMessage'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthResponse
     */
    'displayMessage'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthResponse
     */
    'accessToken'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthResponse
     */
    'refreshToken'?: string | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerAuthResponse
     */
    'expiresInSeconds'?: number | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerAuthResponse
     */
    'refreshTokenExpiresInSeconds'?: number | null;
    /**
     *
     * @type {BrokerAccount}
     * @memberof B2BBrokerAuthResponse
     */
    'account'?: BrokerAccount | null;
    /**
     *
     * @type {BrokerBrandInfo}
     * @memberof B2BBrokerAuthResponse
     */
    'brokerBrandInfo'?: BrokerBrandInfo | null;
    /**
     *
     * @type {Array<BrokerAccountTokens>}
     * @memberof B2BBrokerAuthResponse
     */
    'accountTokens'?: Array<BrokerAccountTokens> | null;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerAuthResponse
     */
    'requiresReauthentication'?: boolean | null;
}

export const B2BBrokerAuthResponseStatusEnum = {
    Failed: 'Failed',
    ChallengeFailed: 'ChallengeFailed',
    Succeeded: 'Succeeded',
    ChallengeIssued: 'ChallengeIssued',
    MfaRequired: 'MfaRequired',
    OpenInBrokerModule: 'OpenInBrokerModule',
    Delayed: 'Delayed'
} as const;

export type B2BBrokerAuthResponseStatusEnum = typeof B2BBrokerAuthResponseStatusEnum[keyof typeof B2BBrokerAuthResponseStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerAuthResponseIApiResult
 */
export interface B2BBrokerAuthResponseIApiResult {
    /**
     *
     * @type {B2BBrokerAuthResponse}
     * @memberof B2BBrokerAuthResponseIApiResult
     */
    'content'?: B2BBrokerAuthResponse | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerAuthResponseIApiResult
     */
    'status'?: B2BBrokerAuthResponseIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthResponseIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerAuthResponseIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerAuthResponseIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerAuthResponseIApiResultStatusEnum = typeof B2BBrokerAuthResponseIApiResultStatusEnum[keyof typeof B2BBrokerAuthResponseIApiResultStatusEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const B2BBrokerAuthStatus = {
    Failed: 'Failed',
    Succeeded: 'Succeeded'
} as const;

export type B2BBrokerAuthStatus = typeof B2BBrokerAuthStatus[keyof typeof B2BBrokerAuthStatus];


/**
 *
 * @export
 * @interface B2BBrokerCreateCryptocurrencyTransactionResponse
 */
export interface B2BBrokerCreateCryptocurrencyTransactionResponse {
    /**
     * Transaction Id by the financial institution
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponse
     */
    'transactionId'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponse
     */
    'failed'?: boolean;
    /**
     * Status of the operation
     * @type {BrokerCryptocurrencyTransactionStatus}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponse
     */
    'status'?: B2BBrokerCreateCryptocurrencyTransactionResponseStatusEnum;
    /**
     * Details of the current status of the transfer, as provided by the financial institution
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponse
     */
    'statusDetails'?: string | null;
    /**
     *
     * @type {B2BBrokerCreateCryptocurrencyTransactionResponseTransaction}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponse
     */
    'transaction'?: B2BBrokerCreateCryptocurrencyTransactionResponseTransaction | null;
}

export const B2BBrokerCreateCryptocurrencyTransactionResponseStatusEnum = {
    Unknown: 'Unknown',
    Failed: 'Failed',
    Frozen: 'Frozen',
    Succeeded: 'Succeeded',
    MfaRequired: 'MfaRequired',
    Pending: 'Pending',
    Expired: 'Expired',
    Canceled: 'Canceled',
    WaitingForSignature: 'WaitingForSignature',
    WaitingForClearing: 'WaitingForClearing',
    AwaitingApproval: 'AwaitingApproval',
    AwaitingConfirmation: 'AwaitingConfirmation',
    AwaitingVerification: 'AwaitingVerification',
    Rejected: 'Rejected',
    PendingCancel: 'PendingCancel'
} as const;

export type B2BBrokerCreateCryptocurrencyTransactionResponseStatusEnum = typeof B2BBrokerCreateCryptocurrencyTransactionResponseStatusEnum[keyof typeof B2BBrokerCreateCryptocurrencyTransactionResponseStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult
 */
export interface B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult {
    /**
     *
     * @type {B2BBrokerCreateCryptocurrencyTransactionResponse}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult
     */
    'content'?: B2BBrokerCreateCryptocurrencyTransactionResponse | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult
     */
    'status'?: B2BBrokerCreateCryptocurrencyTransactionResponseIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerCreateCryptocurrencyTransactionResponseIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerCreateCryptocurrencyTransactionResponseIApiResultStatusEnum = typeof B2BBrokerCreateCryptocurrencyTransactionResponseIApiResultStatusEnum[keyof typeof B2BBrokerCreateCryptocurrencyTransactionResponseIApiResultStatusEnum];

/**
 * Details of the created transaction
 * @export
 * @interface B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
 */
export interface B2BBrokerCreateCryptocurrencyTransactionResponseTransaction {
    /**
     * Identifier of the transfer, if provided by the financial institution
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'id'?: string | null;
    /**
     * Current status of the transaction
     * @type {BrokerCryptocurrencyTransactionStatus}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'status'?: B2BBrokerCreateCryptocurrencyTransactionResponseTransactionStatusEnum;
    /**
     * Details of the current status of the transfer, as provided by the financial institution
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'statusDetails'?: string | null;
    /**
     * The direction of the transaction
     * @type {BrokerCryptocurrencyTransactionType}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'type'?: B2BBrokerCreateCryptocurrencyTransactionResponseTransactionTypeEnum;
    /**
     * Address where the transaction was sent from
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'fromAddress'?: string | null;
    /**
     * Address where the transaction was sent to
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'targetAddress'?: string | null;
    /**
     * Ticker of the transaction
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'symbol'?: string | null;
    /**
     * Crypto Chain the transaction belongs to
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'chain'?: string | null;
    /**
     * Memo of the transaction (also called \"Tag\")
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'memo'?: string | null;
    /**
     * Hash of the transaction
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'hash'?: string | null;
    /**
     * Full amount affected the balance, typically transaction amount plus fee
     * @type {number}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'amount'?: number;
    /**
     * Transaction amount
     * @type {number}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'transactionAmount'?: number | null;
    /**
     * Unix timestamp in seconds indicating when the transaction was created
     * @type {number}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'createdTimestamp'?: number;
    /**
     * Unix timestamp in seconds indicating when the transaction was last updated
     * @type {number}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'updatedTimestamp'?: number;
    /**
     *
     * @type {B2BBrokerCryptocurrencyTransactionNetworkTransactionFee}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'networkTransactionFee'?: B2BBrokerCryptocurrencyTransactionNetworkTransactionFee | null;
    /**
     * Fee taken by the financial institution
     * @type {number}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'transferFee'?: number | null;
    /**
     * Number of confirmations on the blockchain
     * @type {number}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'confirmations'?: number | null;
    /**
     * Name of the executed blockchain function based on decoded input data
     * @type {string}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'blockchainMethodName'?: string | null;
    /**
     * Executed blockchain function based on decoded input data. Not guaranteed to be identified
     * @type {BrokerCryptocurrencyTransactionBlockchainMethod}
     * @memberof B2BBrokerCreateCryptocurrencyTransactionResponseTransaction
     */
    'blockchainMethod'?: B2BBrokerCreateCryptocurrencyTransactionResponseTransactionBlockchainMethodEnum;
}

export const B2BBrokerCreateCryptocurrencyTransactionResponseTransactionStatusEnum = {
    Unknown: 'Unknown',
    Failed: 'Failed',
    Frozen: 'Frozen',
    Succeeded: 'Succeeded',
    MfaRequired: 'MfaRequired',
    Pending: 'Pending',
    Expired: 'Expired',
    Canceled: 'Canceled',
    WaitingForSignature: 'WaitingForSignature',
    WaitingForClearing: 'WaitingForClearing',
    AwaitingApproval: 'AwaitingApproval',
    AwaitingConfirmation: 'AwaitingConfirmation',
    AwaitingVerification: 'AwaitingVerification',
    Rejected: 'Rejected',
    PendingCancel: 'PendingCancel'
} as const;

export type B2BBrokerCreateCryptocurrencyTransactionResponseTransactionStatusEnum = typeof B2BBrokerCreateCryptocurrencyTransactionResponseTransactionStatusEnum[keyof typeof B2BBrokerCreateCryptocurrencyTransactionResponseTransactionStatusEnum];
export const B2BBrokerCreateCryptocurrencyTransactionResponseTransactionTypeEnum = {
    Unknown: 'Unknown',
    Deposit: 'Deposit',
    Withdrawal: 'Withdrawal'
} as const;

export type B2BBrokerCreateCryptocurrencyTransactionResponseTransactionTypeEnum = typeof B2BBrokerCreateCryptocurrencyTransactionResponseTransactionTypeEnum[keyof typeof B2BBrokerCreateCryptocurrencyTransactionResponseTransactionTypeEnum];
export const B2BBrokerCreateCryptocurrencyTransactionResponseTransactionBlockchainMethodEnum = {
    Transfer: 'Transfer',
    Swap: 'Swap',
    Mint: 'Mint',
    Withdraw: 'Withdraw',
    ClaimRewards: 'ClaimRewards',
    Deposit: 'Deposit',
    Approve: 'Approve',
    ForgeToken: 'ForgeToken',
    Multicall: 'Multicall',
    MigrateToken: 'MigrateToken',
    Claim: 'Claim',
    OpenSeaTransfer: 'OpenSeaTransfer',
    Cancel: 'Cancel',
    Commit: 'Commit',
    Run: 'Run',
    Repay: 'Repay',
    Execute: 'Execute',
    Stake: 'Stake',
    Merge: 'Merge'
} as const;

export type B2BBrokerCreateCryptocurrencyTransactionResponseTransactionBlockchainMethodEnum = typeof B2BBrokerCreateCryptocurrencyTransactionResponseTransactionBlockchainMethodEnum[keyof typeof B2BBrokerCreateCryptocurrencyTransactionResponseTransactionBlockchainMethodEnum];

/**
 *
 * @export
 * @interface B2BBrokerCreateOrderRequest
 */
export interface B2BBrokerCreateOrderRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'type': B2BBrokerCreateOrderRequestTypeEnum;
    /**
     * Symbol to trade. For example, `AAPL` or `ETH`
     * @type {string}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'symbol': string;
    /**
     * Symbol to use for payment, defaults to `USD`.
     * @type {string}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'paymentSymbol': string;
    /**
     * Amount of purchase.
     * @type {number}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'amount': number;
    /**
     * Price of the unit, used for `Limit` and `StopLoss` orders.
     * @type {number}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'price'?: number;
    /**
     * Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly.
     * @type {boolean}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'isCryptocurrency': boolean;
    /**
     * Indicates whether the `PaymentSymbol` is fiat or cryptocurrency
     * @type {boolean}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'paymentIsCryptocurrency': boolean;
    /**
     * This value indicates if the order should be executed in fiat amount (e.g. purchase ETH for $10). This can be  performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInFiatAmount` and  `SupportsPlacingBuyOrdersInFiatAmount` fields in `get supported order features for institution`) and `AmountInFiat`  value is passed.
     * @type {boolean}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'amountIsFiat': boolean;
    /**
     * Specifies the target amount in fiat currency. For example setting this to `10` when the `AmountIsFiat` = `true`  and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
     * @type {number}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'amountInFiat'?: number | null;
    /**
     * Specifies if the extended trading hours should be used.
     * @type {boolean}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'extendedHours'?: boolean;
    /**
     *
     * @type {BrokerOrderPlaceType}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'orderType': B2BBrokerCreateOrderRequestOrderTypeEnum;
    /**
     *
     * @type {BrokerOrderTimeInForceType}
     * @memberof B2BBrokerCreateOrderRequest
     */
    'timeInForce': B2BBrokerCreateOrderRequestTimeInForceEnum;
}

export const B2BBrokerCreateOrderRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerCreateOrderRequestTypeEnum = typeof B2BBrokerCreateOrderRequestTypeEnum[keyof typeof B2BBrokerCreateOrderRequestTypeEnum];
export const B2BBrokerCreateOrderRequestOrderTypeEnum = {
    Unknown: 'Unknown',
    Market: 'Market',
    Limit: 'Limit',
    StopLoss: 'StopLoss',
    StopLimit: 'StopLimit',
    NetDebit: 'NetDebit',
    NetCredit: 'NetCredit',
    Exercise: 'Exercise'
} as const;

export type B2BBrokerCreateOrderRequestOrderTypeEnum = typeof B2BBrokerCreateOrderRequestOrderTypeEnum[keyof typeof B2BBrokerCreateOrderRequestOrderTypeEnum];
export const B2BBrokerCreateOrderRequestTimeInForceEnum = {
    GoodTillCanceled: 'GoodTillCanceled',
    ImmediateOrCancel: 'ImmediateOrCancel',
    FillOrKill: 'FillOrKill',
    GoodForDay: 'GoodForDay',
    PostOnly: 'PostOnly'
} as const;

export type B2BBrokerCreateOrderRequestTimeInForceEnum = typeof B2BBrokerCreateOrderRequestTimeInForceEnum[keyof typeof B2BBrokerCreateOrderRequestTimeInForceEnum];

/**
 *
 * @export
 * @interface B2BBrokerCreateOrderResult
 */
export interface B2BBrokerCreateOrderResult {
    /**
     * Id of the order, as returned from the financial institution. Can be used to get the status of the order.
     * @type {string}
     * @memberof B2BBrokerCreateOrderResult
     */
    'orderId'?: string | null;
    /**
     * Type of the institution.
     * @type {BrokerType}
     * @memberof B2BBrokerCreateOrderResult
     */
    'brokerType'?: B2BBrokerCreateOrderResultBrokerTypeEnum;
    /**
     * Side of the order.
     * @type {BrokerOrderType}
     * @memberof B2BBrokerCreateOrderResult
     */
    'side'?: B2BBrokerCreateOrderResultSideEnum;
    /**
     * Amount of the order.
     * @type {number}
     * @memberof B2BBrokerCreateOrderResult
     */
    'amount'?: number;
    /**
     * Unit price of the asset.
     * @type {number}
     * @memberof B2BBrokerCreateOrderResult
     */
    'price'?: number | null;
    /**
     * Total value of the order.
     * @type {number}
     * @memberof B2BBrokerCreateOrderResult
     */
    'value'?: number | null;
    /**
     * Optional Fee taken by the financial institution.
     * @type {number}
     * @memberof B2BBrokerCreateOrderResult
     */
    'fee'?: number | null;
    /**
     * Timestamp of the order.
     * @type {number}
     * @memberof B2BBrokerCreateOrderResult
     */
    'timestamp'?: number;
    /**
     * Status of the order.
     * @type {BrokerOrderStatus}
     * @memberof B2BBrokerCreateOrderResult
     */
    'status'?: B2BBrokerCreateOrderResultStatusEnum;
    /**
     * Text details of the order, if additionally returned from the financial institution.
     * @type {string}
     * @memberof B2BBrokerCreateOrderResult
     */
    'statusDetails'?: string | null;
    /**
     * Value that indicates how long the order will remain active before it is executed or expires.
     * @type {BrokerOrderTimeInForceType}
     * @memberof B2BBrokerCreateOrderResult
     */
    'timeInForce'?: BrokerOrderTimeInForceType | null;
    /**
     * Optional pair of symbols, as returned from the financial institution. Can be required to obtain the status of the order by some institutions.
     * @type {string}
     * @memberof B2BBrokerCreateOrderResult
     */
    'symbolPair'?: string | null;
    /**
     * Id of the parent order, applicable to some institutions if the order was executed in several trades.
     * @type {string}
     * @memberof B2BBrokerCreateOrderResult
     */
    'parentOrderId'?: string | null;
    /**
     * List of trades, provided only if the order was executed in several trades.
     * @type {Array<B2BBrokerOrderTrade>}
     * @memberof B2BBrokerCreateOrderResult
     */
    'trades'?: Array<B2BBrokerOrderTrade> | null;
    /**
     * A message describing the error if the order wasn\'t placed.
     * @type {string}
     * @memberof B2BBrokerCreateOrderResult
     */
    'errorMessage'?: string | null;
    /**
     * A user-friendly display message that can be presented to the end user.
     * @type {string}
     * @memberof B2BBrokerCreateOrderResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerCreateOrderResultBrokerTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerCreateOrderResultBrokerTypeEnum = typeof B2BBrokerCreateOrderResultBrokerTypeEnum[keyof typeof B2BBrokerCreateOrderResultBrokerTypeEnum];
export const B2BBrokerCreateOrderResultSideEnum = {
    Unknown: 'Unknown',
    Buy: 'Buy',
    Sell: 'Sell'
} as const;

export type B2BBrokerCreateOrderResultSideEnum = typeof B2BBrokerCreateOrderResultSideEnum[keyof typeof B2BBrokerCreateOrderResultSideEnum];
export const B2BBrokerCreateOrderResultStatusEnum = {
    Unknown: 'Unknown',
    InProgress: 'InProgress',
    Cancelled: 'Cancelled',
    Rejected: 'Rejected',
    Failed: 'Failed',
    Success: 'Success',
    PartiallyFilled: 'PartiallyFilled',
    Expired: 'Expired'
} as const;

export type B2BBrokerCreateOrderResultStatusEnum = typeof B2BBrokerCreateOrderResultStatusEnum[keyof typeof B2BBrokerCreateOrderResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerCreateOrderResultIApiResult
 */
export interface B2BBrokerCreateOrderResultIApiResult {
    /**
     *
     * @type {B2BBrokerCreateOrderResult}
     * @memberof B2BBrokerCreateOrderResultIApiResult
     */
    'content'?: B2BBrokerCreateOrderResult | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerCreateOrderResultIApiResult
     */
    'status'?: B2BBrokerCreateOrderResultIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCreateOrderResultIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCreateOrderResultIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerCreateOrderResultIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerCreateOrderResultIApiResultStatusEnum = typeof B2BBrokerCreateOrderResultIApiResultStatusEnum[keyof typeof B2BBrokerCreateOrderResultIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerCryptocurrencyDepositAddressResponse
 */
export interface B2BBrokerCryptocurrencyDepositAddressResponse {
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponse
     */
    'symbol'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponse
     */
    'address'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponse
     */
    'chain'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponse
     */
    'memo'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponse
     */
    'minimumDepositAmount'?: string | null;
}
/**
 *
 * @export
 * @interface B2BBrokerCryptocurrencyDepositAddressResponseIApiResult
 */
export interface B2BBrokerCryptocurrencyDepositAddressResponseIApiResult {
    /**
     *
     * @type {B2BBrokerCryptocurrencyDepositAddressResponse}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponseIApiResult
     */
    'content'?: B2BBrokerCryptocurrencyDepositAddressResponse | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponseIApiResult
     */
    'status'?: B2BBrokerCryptocurrencyDepositAddressResponseIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponseIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyDepositAddressResponseIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerCryptocurrencyDepositAddressResponseIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerCryptocurrencyDepositAddressResponseIApiResultStatusEnum = typeof B2BBrokerCryptocurrencyDepositAddressResponseIApiResultStatusEnum[keyof typeof B2BBrokerCryptocurrencyDepositAddressResponseIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerCryptocurrencyTransaction
 */
export interface B2BBrokerCryptocurrencyTransaction {
    /**
     * Identifier of the transfer, if provided by the financial institution
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'id'?: string | null;
    /**
     * Current status of the transaction
     * @type {BrokerCryptocurrencyTransactionStatus}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'status'?: B2BBrokerCryptocurrencyTransactionStatusEnum;
    /**
     * Details of the current status of the transfer, as provided by the financial institution
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'statusDetails'?: string | null;
    /**
     * The direction of the transaction
     * @type {BrokerCryptocurrencyTransactionType}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'type'?: B2BBrokerCryptocurrencyTransactionTypeEnum;
    /**
     * Address where the transaction was sent from
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'fromAddress'?: string | null;
    /**
     * Address where the transaction was sent to
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'targetAddress'?: string | null;
    /**
     * Ticker of the transaction
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'symbol'?: string | null;
    /**
     * Crypto Chain the transaction belongs to
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'chain'?: string | null;
    /**
     * Memo of the transaction (also called \"Tag\")
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'memo'?: string | null;
    /**
     * Hash of the transaction
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'hash'?: string | null;
    /**
     * Full amount affected the balance, typically transaction amount plus fee
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'amount'?: number;
    /**
     * Transaction amount
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'transactionAmount'?: number | null;
    /**
     * Unix timestamp in seconds indicating when the transaction was created
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'createdTimestamp'?: number;
    /**
     * Unix timestamp in seconds indicating when the transaction was last updated
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'updatedTimestamp'?: number;
    /**
     *
     * @type {B2BBrokerCryptocurrencyTransactionNetworkTransactionFee}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'networkTransactionFee'?: B2BBrokerCryptocurrencyTransactionNetworkTransactionFee | null;
    /**
     * Fee taken by the financial institution
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'transferFee'?: number | null;
    /**
     * Number of confirmations on the blockchain
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'confirmations'?: number | null;
    /**
     * Name of the executed blockchain function based on decoded input data
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'blockchainMethodName'?: string | null;
    /**
     * Executed blockchain function based on decoded input data. Not guaranteed to be identified
     * @type {BrokerCryptocurrencyTransactionBlockchainMethod}
     * @memberof B2BBrokerCryptocurrencyTransaction
     */
    'blockchainMethod'?: B2BBrokerCryptocurrencyTransactionBlockchainMethodEnum;
}

export const B2BBrokerCryptocurrencyTransactionStatusEnum = {
    Unknown: 'Unknown',
    Failed: 'Failed',
    Frozen: 'Frozen',
    Succeeded: 'Succeeded',
    MfaRequired: 'MfaRequired',
    Pending: 'Pending',
    Expired: 'Expired',
    Canceled: 'Canceled',
    WaitingForSignature: 'WaitingForSignature',
    WaitingForClearing: 'WaitingForClearing',
    AwaitingApproval: 'AwaitingApproval',
    AwaitingConfirmation: 'AwaitingConfirmation',
    AwaitingVerification: 'AwaitingVerification',
    Rejected: 'Rejected',
    PendingCancel: 'PendingCancel'
} as const;

export type B2BBrokerCryptocurrencyTransactionStatusEnum = typeof B2BBrokerCryptocurrencyTransactionStatusEnum[keyof typeof B2BBrokerCryptocurrencyTransactionStatusEnum];
export const B2BBrokerCryptocurrencyTransactionTypeEnum = {
    Unknown: 'Unknown',
    Deposit: 'Deposit',
    Withdrawal: 'Withdrawal'
} as const;

export type B2BBrokerCryptocurrencyTransactionTypeEnum = typeof B2BBrokerCryptocurrencyTransactionTypeEnum[keyof typeof B2BBrokerCryptocurrencyTransactionTypeEnum];
export const B2BBrokerCryptocurrencyTransactionBlockchainMethodEnum = {
    Transfer: 'Transfer',
    Swap: 'Swap',
    Mint: 'Mint',
    Withdraw: 'Withdraw',
    ClaimRewards: 'ClaimRewards',
    Deposit: 'Deposit',
    Approve: 'Approve',
    ForgeToken: 'ForgeToken',
    Multicall: 'Multicall',
    MigrateToken: 'MigrateToken',
    Claim: 'Claim',
    OpenSeaTransfer: 'OpenSeaTransfer',
    Cancel: 'Cancel',
    Commit: 'Commit',
    Run: 'Run',
    Repay: 'Repay',
    Execute: 'Execute',
    Stake: 'Stake',
    Merge: 'Merge'
} as const;

export type B2BBrokerCryptocurrencyTransactionBlockchainMethodEnum = typeof B2BBrokerCryptocurrencyTransactionBlockchainMethodEnum[keyof typeof B2BBrokerCryptocurrencyTransactionBlockchainMethodEnum];

/**
 *
 * @export
 * @interface B2BBrokerCryptocurrencyTransactionIApiResult
 */
export interface B2BBrokerCryptocurrencyTransactionIApiResult {
    /**
     *
     * @type {B2BBrokerCryptocurrencyTransaction}
     * @memberof B2BBrokerCryptocurrencyTransactionIApiResult
     */
    'content'?: B2BBrokerCryptocurrencyTransaction | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerCryptocurrencyTransactionIApiResult
     */
    'status'?: B2BBrokerCryptocurrencyTransactionIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransactionIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransactionIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerCryptocurrencyTransactionIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerCryptocurrencyTransactionIApiResultStatusEnum = typeof B2BBrokerCryptocurrencyTransactionIApiResultStatusEnum[keyof typeof B2BBrokerCryptocurrencyTransactionIApiResultStatusEnum];

/**
 * Fee taken by the network
 * @export
 * @interface B2BBrokerCryptocurrencyTransactionNetworkTransactionFee
 */
export interface B2BBrokerCryptocurrencyTransactionNetworkTransactionFee {
    /**
     *
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransactionNetworkTransactionFee
     */
    'gasPrice'?: number | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransactionNetworkTransactionFee
     */
    'gasUsed'?: number | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerCryptocurrencyTransactionNetworkTransactionFee
     */
    'amount'?: number | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyTransactionNetworkTransactionFee
     */
    'symbol'?: string | null;
}
/**
 *
 * @export
 * @interface B2BBrokerCryptocurrencyWalletAuthRequest
 */
export interface B2BBrokerCryptocurrencyWalletAuthRequest {
    /**
     * Symbol to connect
     * @type {string}
     * @memberof B2BBrokerCryptocurrencyWalletAuthRequest
     */
    'symbol'?: string | null;
    /**
     * Blockchain to connect to
     * @type {CryptocurrencyAddressType}
     * @memberof B2BBrokerCryptocurrencyWalletAuthRequest
     */
    'cryptocurrencyAddressType'?: CryptocurrencyAddressType | null;
    /**
     * Optional wallet type
     * @type {CryptocurrencyWalletType}
     * @memberof B2BBrokerCryptocurrencyWalletAuthRequest
     */
    'cryptocurrencyWalletType'?: CryptocurrencyWalletType | null;
}
/**
 *
 * @export
 * @interface B2BBrokerOptionData
 */
export interface B2BBrokerOptionData {
    /**
     * Type of option
     * @type {BrokerOptionType}
     * @memberof B2BBrokerOptionData
     */
    'optionType'?: B2BBrokerOptionDataOptionTypeEnum;
    /**
     * Direction of option
     * @type {BrokerOptionDirection}
     * @memberof B2BBrokerOptionData
     */
    'direction'?: B2BBrokerOptionDataDirectionEnum;
    /**
     * Option strike price
     * @type {number}
     * @memberof B2BBrokerOptionData
     */
    'strikePrice'?: number;
    /**
     * Option expiration timestamp
     * @type {number}
     * @memberof B2BBrokerOptionData
     */
    'expirationTimestamp'?: number;
    /**
     * Number of shares covered by option
     * @type {number}
     * @memberof B2BBrokerOptionData
     */
    'numberOfSharesInContract'?: number;
    /**
     * Option complex order strategy type
     * @type {string}
     * @memberof B2BBrokerOptionData
     */
    'complexOrderStrategyType'?: string | null;
}

export const B2BBrokerOptionDataOptionTypeEnum = {
    Unknown: 'Unknown',
    Call: 'Call',
    Put: 'Put'
} as const;

export type B2BBrokerOptionDataOptionTypeEnum = typeof B2BBrokerOptionDataOptionTypeEnum[keyof typeof B2BBrokerOptionDataOptionTypeEnum];
export const B2BBrokerOptionDataDirectionEnum = {
    Unknown: 'Unknown',
    BuyToOpen: 'BuyToOpen',
    BuyToClose: 'BuyToClose',
    SellToOpen: 'SellToOpen',
    SellToClose: 'SellToClose',
    BuyToCover: 'BuyToCover',
    SellShort: 'SellShort'
} as const;

export type B2BBrokerOptionDataDirectionEnum = typeof B2BBrokerOptionDataDirectionEnum[keyof typeof B2BBrokerOptionDataDirectionEnum];

/**
 *
 * @export
 * @interface B2BBrokerOrder
 */
export interface B2BBrokerOrder {
    /**
     * Transaction id, as provided by the institution
     * @type {string}
     * @memberof B2BBrokerOrder
     */
    'id'?: string | null;
    /**
     * Side of the transaction
     * @type {BrokerOrderType}
     * @memberof B2BBrokerOrder
     */
    'side'?: B2BBrokerOrderSideEnum;
    /**
     * Traded symbol
     * @type {string}
     * @memberof B2BBrokerOrder
     */
    'symbol'?: string | null;
    /**
     * Name of the traded asset
     * @type {string}
     * @memberof B2BBrokerOrder
     */
    'name'?: string | null;
    /**
     * Type of the traded asset
     * @type {B2BAssetType}
     * @memberof B2BBrokerOrder
     */
    'assetType'?: B2BBrokerOrderAssetTypeEnum;
    /**
     * Fiat or cryptocurrency symbol used for payment. For transactions with types `ConversionFrom` or `ConversionTo`  this field specifies the target symbol. For example, for `ETH` to `BTC` conversion, the transaction type is `ConversionTo`, the `Symbol` field is `ETH` and the `PaymentSymbol` is `BTC`
     * @type {string}
     * @memberof B2BBrokerOrder
     */
    'paymentSymbol'?: string | null;
    /**
     * Indicates if the payment was performed with fiat or crypto currency
     * @type {B2BBrokerOrderPaymentSymbolType}
     * @memberof B2BBrokerOrder
     */
    'paymentType'?: B2BBrokerOrderPaymentTypeEnum;
    /**
     * Executed amount
     * @type {number}
     * @memberof B2BBrokerOrder
     */
    'amount'?: number | null;
    /**
     * Price of the unit
     * @type {number}
     * @memberof B2BBrokerOrder
     */
    'price'?: number | null;
    /**
     * Order Fee, taken by the financial institution
     * @type {number}
     * @memberof B2BBrokerOrder
     */
    'fee'?: number | null;
    /**
     * Total value
     * @type {number}
     * @memberof B2BBrokerOrder
     */
    'value'?: number | null;
    /**
     * Unix timestamp in seconds indicating when the order was placed or the transaction was created
     * @type {number}
     * @memberof B2BBrokerOrder
     */
    'createdTimestamp'?: number;
    /**
     * Unix timestamp in seconds indicating when the transaction was last updated (e.g. executed)
     * @type {number}
     * @memberof B2BBrokerOrder
     */
    'updatedTimestamp'?: number;
    /**
     * Status of the transaction
     * @type {BrokerOrderStatus}
     * @memberof B2BBrokerOrder
     */
    'status'?: B2BBrokerOrderStatusEnum;
    /**
     * Status text, as provided by the institution
     * @type {string}
     * @memberof B2BBrokerOrder
     */
    'statusDetails'?: string | null;
    /**
     * Type of the placed order
     * @type {BrokerOrderPlaceType}
     * @memberof B2BBrokerOrder
     */
    'orderType'?: BrokerOrderPlaceType | null;
    /**
     * Time in force of the order: a value indicating how long the order remains active before it is executed or expires
     * @type {BrokerOrderTimeInForceType}
     * @memberof B2BBrokerOrder
     */
    'timeInForce'?: BrokerOrderTimeInForceType | null;
    /**
     * Type of the integration
     * @type {BrokerType}
     * @memberof B2BBrokerOrder
     */
    'brokerType'?: B2BBrokerOrderBrokerTypeEnum;
    /**
     * Type of the transaction
     * @type {B2BTransactionType}
     * @memberof B2BBrokerOrder
     */
    'transactionType'?: B2BBrokerOrderTransactionTypeEnum;
    /**
     * Id of the parent order, applicable to some institutions
     * @type {string}
     * @memberof B2BBrokerOrder
     */
    'parentOrderId'?: string | null;
    /**
     *
     * @type {B2BBrokerOrderOptionDetails}
     * @memberof B2BBrokerOrder
     */
    'optionDetails'?: B2BBrokerOrderOptionDetails | null;
}

export const B2BBrokerOrderSideEnum = {
    Unknown: 'Unknown',
    Buy: 'Buy',
    Sell: 'Sell'
} as const;

export type B2BBrokerOrderSideEnum = typeof B2BBrokerOrderSideEnum[keyof typeof B2BBrokerOrderSideEnum];
export const B2BBrokerOrderAssetTypeEnum = {
    Equity: 'Equity',
    Cryptocurrency: 'Cryptocurrency',
    Option: 'Option',
    Nft: 'Nft'
} as const;

export type B2BBrokerOrderAssetTypeEnum = typeof B2BBrokerOrderAssetTypeEnum[keyof typeof B2BBrokerOrderAssetTypeEnum];
export const B2BBrokerOrderPaymentTypeEnum = {
    Fiat: 'Fiat',
    Cryptocurrency: 'Cryptocurrency'
} as const;

export type B2BBrokerOrderPaymentTypeEnum = typeof B2BBrokerOrderPaymentTypeEnum[keyof typeof B2BBrokerOrderPaymentTypeEnum];
export const B2BBrokerOrderStatusEnum = {
    Unknown: 'Unknown',
    InProgress: 'InProgress',
    Cancelled: 'Cancelled',
    Rejected: 'Rejected',
    Failed: 'Failed',
    Success: 'Success',
    PartiallyFilled: 'PartiallyFilled',
    Expired: 'Expired'
} as const;

export type B2BBrokerOrderStatusEnum = typeof B2BBrokerOrderStatusEnum[keyof typeof B2BBrokerOrderStatusEnum];
export const B2BBrokerOrderBrokerTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerOrderBrokerTypeEnum = typeof B2BBrokerOrderBrokerTypeEnum[keyof typeof B2BBrokerOrderBrokerTypeEnum];
export const B2BBrokerOrderTransactionTypeEnum = {
    Order: 'Order',
    ConversionTo: 'ConversionTo',
    ConversionFrom: 'ConversionFrom',
    OwnAccountDeposit: 'OwnAccountDeposit',
    OwnAccountWithdraw: 'OwnAccountWithdraw',
    Stake: 'Stake',
    DividendReinvestment: 'DividendReinvestment',
    Interest: 'Interest',
    Reward: 'Reward',
    Unknown: 'Unknown',
    ConversionToFiat: 'ConversionToFiat',
    ConversionFromFiat: 'ConversionFromFiat'
} as const;

export type B2BBrokerOrderTransactionTypeEnum = typeof B2BBrokerOrderTransactionTypeEnum[keyof typeof B2BBrokerOrderTransactionTypeEnum];

/**
 *
 * @export
 * @interface B2BBrokerOrderIApiResult
 */
export interface B2BBrokerOrderIApiResult {
    /**
     *
     * @type {B2BBrokerOrder}
     * @memberof B2BBrokerOrderIApiResult
     */
    'content'?: B2BBrokerOrder | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerOrderIApiResult
     */
    'status'?: B2BBrokerOrderIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerOrderIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerOrderIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerOrderIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerOrderIApiResultStatusEnum = typeof B2BBrokerOrderIApiResultStatusEnum[keyof typeof B2BBrokerOrderIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerOrderListRequest
 */
export interface B2BBrokerOrderListRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof B2BBrokerOrderListRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof B2BBrokerOrderListRequest
     */
    'type': B2BBrokerOrderListRequestTypeEnum;
    /**
     * The cursor to retrieve the next page of transactions.  Providing it will cause the response to only return changes after this update.  If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
     * @type {string}
     * @memberof B2BBrokerOrderListRequest
     */
    'cursor'?: string | null;
    /**
     * Number of records to include in the response. <br />  Default: `100` <br />  Maximum: `250`
     * @type {number}
     * @memberof B2BBrokerOrderListRequest
     */
    'count'?: number;
    /**
     * Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned.
     * @type {Array<BrokerOrderStatus>}
     * @memberof B2BBrokerOrderListRequest
     */
    'statuses'?: Array<BrokerOrderStatus> | null;
}

export const B2BBrokerOrderListRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerOrderListRequestTypeEnum = typeof B2BBrokerOrderListRequestTypeEnum[keyof typeof B2BBrokerOrderListRequestTypeEnum];

/**
 *
 * @export
 * @interface B2BBrokerOrderListResponse
 */
export interface B2BBrokerOrderListResponse {
    /**
     * List of obtained transactions.
     * @type {Array<B2BBrokerOrder>}
     * @memberof B2BBrokerOrderListResponse
     */
    'transactions'?: Array<B2BBrokerOrder> | null;
    /**
     * The cursor to retrieve the next page of transactions.
     * @type {string}
     * @memberof B2BBrokerOrderListResponse
     */
    'cursor'?: string | null;
    /**
     * Total amount of records.
     * @type {number}
     * @memberof B2BBrokerOrderListResponse
     */
    'total'?: number;
}
/**
 *
 * @export
 * @interface B2BBrokerOrderListResponseIApiResult
 */
export interface B2BBrokerOrderListResponseIApiResult {
    /**
     *
     * @type {B2BBrokerOrderListResponse}
     * @memberof B2BBrokerOrderListResponseIApiResult
     */
    'content'?: B2BBrokerOrderListResponse | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerOrderListResponseIApiResult
     */
    'status'?: B2BBrokerOrderListResponseIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerOrderListResponseIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerOrderListResponseIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerOrderListResponseIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerOrderListResponseIApiResultStatusEnum = typeof B2BBrokerOrderListResponseIApiResultStatusEnum[keyof typeof B2BBrokerOrderListResponseIApiResultStatusEnum];

/**
 * Additional details for options
 * @export
 * @interface B2BBrokerOrderOptionDetails
 */
export interface B2BBrokerOrderOptionDetails {
    /**
     * Type of option
     * @type {BrokerOptionType}
     * @memberof B2BBrokerOrderOptionDetails
     */
    'optionType'?: B2BBrokerOrderOptionDetailsOptionTypeEnum;
    /**
     * Direction of option
     * @type {BrokerOptionDirection}
     * @memberof B2BBrokerOrderOptionDetails
     */
    'direction'?: B2BBrokerOrderOptionDetailsDirectionEnum;
    /**
     * Option strike price
     * @type {number}
     * @memberof B2BBrokerOrderOptionDetails
     */
    'strikePrice'?: number;
    /**
     * Option expiration timestamp
     * @type {number}
     * @memberof B2BBrokerOrderOptionDetails
     */
    'expirationTimestamp'?: number;
    /**
     * Number of shares covered by option
     * @type {number}
     * @memberof B2BBrokerOrderOptionDetails
     */
    'numberOfSharesInContract'?: number;
    /**
     * Option complex order strategy type
     * @type {string}
     * @memberof B2BBrokerOrderOptionDetails
     */
    'complexOrderStrategyType'?: string | null;
}

export const B2BBrokerOrderOptionDetailsOptionTypeEnum = {
    Unknown: 'Unknown',
    Call: 'Call',
    Put: 'Put'
} as const;

export type B2BBrokerOrderOptionDetailsOptionTypeEnum = typeof B2BBrokerOrderOptionDetailsOptionTypeEnum[keyof typeof B2BBrokerOrderOptionDetailsOptionTypeEnum];
export const B2BBrokerOrderOptionDetailsDirectionEnum = {
    Unknown: 'Unknown',
    BuyToOpen: 'BuyToOpen',
    BuyToClose: 'BuyToClose',
    SellToOpen: 'SellToOpen',
    SellToClose: 'SellToClose',
    BuyToCover: 'BuyToCover',
    SellShort: 'SellShort'
} as const;

export type B2BBrokerOrderOptionDetailsDirectionEnum = typeof B2BBrokerOrderOptionDetailsDirectionEnum[keyof typeof B2BBrokerOrderOptionDetailsDirectionEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const B2BBrokerOrderPaymentSymbolType = {
    Fiat: 'Fiat',
    Cryptocurrency: 'Cryptocurrency'
} as const;

export type B2BBrokerOrderPaymentSymbolType = typeof B2BBrokerOrderPaymentSymbolType[keyof typeof B2BBrokerOrderPaymentSymbolType];


/**
 *
 * @export
 * @interface B2BBrokerOrderRequest
 */
export interface B2BBrokerOrderRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof B2BBrokerOrderRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof B2BBrokerOrderRequest
     */
    'type': B2BBrokerOrderRequestTypeEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerOrderRequest
     */
    'id': string;
    /**
     * Should be provided for Coinbase.
     * @type {BrokerOrderType}
     * @memberof B2BBrokerOrderRequest
     */
    'side'?: BrokerOrderType | null;
    /**
     * Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought.
     * @type {boolean}
     * @memberof B2BBrokerOrderRequest
     */
    'isCryptocurrency': boolean;
    /**
     * Symbol pair of the order (requested by some brokers).
     * @type {string}
     * @memberof B2BBrokerOrderRequest
     */
    'symbolPair'?: string | null;
}

export const B2BBrokerOrderRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerOrderRequestTypeEnum = typeof B2BBrokerOrderRequestTypeEnum[keyof typeof B2BBrokerOrderRequestTypeEnum];

/**
 *
 * @export
 * @interface B2BBrokerOrderSymbolInfo
 */
export interface B2BBrokerOrderSymbolInfo {
    /**
     * Specifies if the fractional trading is allowed for the provided symbol
     * @type {SymbolTradingAllowance}
     * @memberof B2BBrokerOrderSymbolInfo
     */
    'fractionalTradingAllowance'?: B2BBrokerOrderSymbolInfoFractionalTradingAllowanceEnum;
    /**
     * Minimum allowed order value
     * @type {number}
     * @memberof B2BBrokerOrderSymbolInfo
     */
    'minimumOrderValue'?: number;
    /**
     * Maximum number of decimal digits accepted by the symbol
     * @type {number}
     * @memberof B2BBrokerOrderSymbolInfo
     */
    'precisionScale'?: number | null;
}

export const B2BBrokerOrderSymbolInfoFractionalTradingAllowanceEnum = {
    FractionalTradingAllowed: 'FractionalTradingAllowed',
    FractionalTradingNotAllowed: 'FractionalTradingNotAllowed',
    TradingNotAllowed: 'TradingNotAllowed',
    FractionalTradingPossiblyAllowed: 'FractionalTradingPossiblyAllowed'
} as const;

export type B2BBrokerOrderSymbolInfoFractionalTradingAllowanceEnum = typeof B2BBrokerOrderSymbolInfoFractionalTradingAllowanceEnum[keyof typeof B2BBrokerOrderSymbolInfoFractionalTradingAllowanceEnum];

/**
 *
 * @export
 * @interface B2BBrokerOrderSymbolInfoIApiResult
 */
export interface B2BBrokerOrderSymbolInfoIApiResult {
    /**
     *
     * @type {B2BBrokerOrderSymbolInfo}
     * @memberof B2BBrokerOrderSymbolInfoIApiResult
     */
    'content'?: B2BBrokerOrderSymbolInfo | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerOrderSymbolInfoIApiResult
     */
    'status'?: B2BBrokerOrderSymbolInfoIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerOrderSymbolInfoIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerOrderSymbolInfoIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerOrderSymbolInfoIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerOrderSymbolInfoIApiResultStatusEnum = typeof B2BBrokerOrderSymbolInfoIApiResultStatusEnum[keyof typeof B2BBrokerOrderSymbolInfoIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerOrderTrade
 */
export interface B2BBrokerOrderTrade {
    /**
     *
     * @type {string}
     * @memberof B2BBrokerOrderTrade
     */
    'tradeId'?: string | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerOrderTrade
     */
    'amount'?: number | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerOrderTrade
     */
    'value'?: number | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerOrderTrade
     */
    'price'?: number | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerOrderTrade
     */
    'fee'?: number | null;
    /**
     *
     * @type {BrokerOrderCategory}
     * @memberof B2BBrokerOrderTrade
     */
    'orderCategory'?: B2BBrokerOrderTradeOrderCategoryEnum;
}

export const B2BBrokerOrderTradeOrderCategoryEnum = {
    Order: 'Order',
    Trade: 'Trade',
    Ledger: 'Ledger',
    HistoryAction: 'HistoryAction'
} as const;

export type B2BBrokerOrderTradeOrderCategoryEnum = typeof B2BBrokerOrderTradeOrderCategoryEnum[keyof typeof B2BBrokerOrderTradeOrderCategoryEnum];

/**
 *
 * @export
 * @interface B2BBrokerPortfolioModel
 */
export interface B2BBrokerPortfolioModel {
    /**
     * Status of the request to the institution\'s API
     * @type {BrokerRequestStatus}
     * @memberof B2BBrokerPortfolioModel
     */
    'status'?: B2BBrokerPortfolioModelStatusEnum;
    /**
     * Error message specifying the problem
     * @type {string}
     * @memberof B2BBrokerPortfolioModel
     */
    'errorMessage'?: string | null;
    /**
     * User-friendly error message, optimized to be shown to the end user
     * @type {string}
     * @memberof B2BBrokerPortfolioModel
     */
    'displayMessage'?: string | null;
    /**
     * Equity holdings, such as stocks and ETFs
     * @type {Array<B2BPosition>}
     * @memberof B2BBrokerPortfolioModel
     */
    'equityPositions'?: Array<B2BPosition> | null;
    /**
     * The equity positions Front could not recognize
     * @type {Array<B2BPosition>}
     * @memberof B2BBrokerPortfolioModel
     */
    'notSupportedEquityPositions'?: Array<B2BPosition> | null;
    /**
     * The cryptocurrency positions Front could not recognize
     * @type {Array<B2BPosition>}
     * @memberof B2BBrokerPortfolioModel
     */
    'notSupportedCryptocurrencyPositions'?: Array<B2BPosition> | null;
    /**
     * Cryptocurrency holdings on the account
     * @type {Array<B2BPosition>}
     * @memberof B2BBrokerPortfolioModel
     */
    'cryptocurrencyPositions'?: Array<B2BPosition> | null;
    /**
     * NFT holdings on the account
     * @type {Array<B2BNftPosition>}
     * @memberof B2BBrokerPortfolioModel
     */
    'nftPositions'?: Array<B2BNftPosition> | null;
    /**
     * Option holdings on the account
     * @type {Array<B2BOptionPosition>}
     * @memberof B2BBrokerPortfolioModel
     */
    'optionPositions'?: Array<B2BOptionPosition> | null;
    /**
     * Type of the institution
     * @type {BrokerType}
     * @memberof B2BBrokerPortfolioModel
     */
    'type'?: B2BBrokerPortfolioModelTypeEnum;
    /**
     * External institution\'s account id (returned by the institution)
     * @type {string}
     * @memberof B2BBrokerPortfolioModel
     */
    'accountId'?: string | null;
    /**
     * Friendly name of the connected institution
     * @type {string}
     * @memberof B2BBrokerPortfolioModel
     */
    'institutionName'?: string | null;
    /**
     * Name of the account as returned from the institution
     * @type {string}
     * @memberof B2BBrokerPortfolioModel
     */
    'accountName'?: string | null;
}

export const B2BBrokerPortfolioModelStatusEnum = {
    Succeeded: 'Succeeded',
    Failed: 'Failed',
    NotAuthorized: 'NotAuthorized'
} as const;

export type B2BBrokerPortfolioModelStatusEnum = typeof B2BBrokerPortfolioModelStatusEnum[keyof typeof B2BBrokerPortfolioModelStatusEnum];
export const B2BBrokerPortfolioModelTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerPortfolioModelTypeEnum = typeof B2BBrokerPortfolioModelTypeEnum[keyof typeof B2BBrokerPortfolioModelTypeEnum];

/**
 *
 * @export
 * @interface B2BBrokerPortfolioModelIApiResult
 */
export interface B2BBrokerPortfolioModelIApiResult {
    /**
     *
     * @type {B2BBrokerPortfolioModel}
     * @memberof B2BBrokerPortfolioModelIApiResult
     */
    'content'?: B2BBrokerPortfolioModel | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerPortfolioModelIApiResult
     */
    'status'?: B2BBrokerPortfolioModelIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerPortfolioModelIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerPortfolioModelIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerPortfolioModelIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerPortfolioModelIApiResultStatusEnum = typeof B2BBrokerPortfolioModelIApiResultStatusEnum[keyof typeof B2BBrokerPortfolioModelIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerPreviewOrderResult
 */
export interface B2BBrokerPreviewOrderResult {
    /**
     *
     * @type {BrokerType}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'brokerType'?: B2BBrokerPreviewOrderResultBrokerTypeEnum;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'fee'?: number | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'feeText'?: string | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'amount'?: number;
    /**
     *
     * @type {BrokerOrderType}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'side'?: B2BBrokerPreviewOrderResultSideEnum;
    /**
     *
     * @type {BrokerOrderValidationStatus}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'status'?: B2BBrokerPreviewOrderResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'errorMessage'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'paymentSymbol'?: string | null;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'paymentIsCryptocurrency'?: boolean;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerPreviewOrderResult
     */
    'estimatedUnitPrice'?: number | null;
}

export const B2BBrokerPreviewOrderResultBrokerTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerPreviewOrderResultBrokerTypeEnum = typeof B2BBrokerPreviewOrderResultBrokerTypeEnum[keyof typeof B2BBrokerPreviewOrderResultBrokerTypeEnum];
export const B2BBrokerPreviewOrderResultSideEnum = {
    Unknown: 'Unknown',
    Buy: 'Buy',
    Sell: 'Sell'
} as const;

export type B2BBrokerPreviewOrderResultSideEnum = typeof B2BBrokerPreviewOrderResultSideEnum[keyof typeof B2BBrokerPreviewOrderResultSideEnum];
export const B2BBrokerPreviewOrderResultStatusEnum = {
    Success: 'Success',
    Failed: 'Failed'
} as const;

export type B2BBrokerPreviewOrderResultStatusEnum = typeof B2BBrokerPreviewOrderResultStatusEnum[keyof typeof B2BBrokerPreviewOrderResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerPreviewOrderResultIApiResult
 */
export interface B2BBrokerPreviewOrderResultIApiResult {
    /**
     *
     * @type {B2BBrokerPreviewOrderResult}
     * @memberof B2BBrokerPreviewOrderResultIApiResult
     */
    'content'?: B2BBrokerPreviewOrderResult | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerPreviewOrderResultIApiResult
     */
    'status'?: B2BBrokerPreviewOrderResultIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerPreviewOrderResultIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerPreviewOrderResultIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerPreviewOrderResultIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerPreviewOrderResultIApiResultStatusEnum = typeof B2BBrokerPreviewOrderResultIApiResultStatusEnum[keyof typeof B2BBrokerPreviewOrderResultIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerRefreshTokenResponse
 */
export interface B2BBrokerRefreshTokenResponse {
    /**
     *
     * @type {B2BBrokerAuthStatus}
     * @memberof B2BBrokerRefreshTokenResponse
     */
    'status'?: B2BBrokerRefreshTokenResponseStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerRefreshTokenResponse
     */
    'errorMessage'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerRefreshTokenResponse
     */
    'displayMessage'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerRefreshTokenResponse
     */
    'accessToken'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerRefreshTokenResponse
     */
    'refreshToken'?: string | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerRefreshTokenResponse
     */
    'expiresInSeconds'?: number | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerRefreshTokenResponse
     */
    'refreshTokenExpiresInSeconds'?: number | null;
    /**
     *
     * @type {Array<BrokerAccountTokens>}
     * @memberof B2BBrokerRefreshTokenResponse
     */
    'brokerAccountTokens'?: Array<BrokerAccountTokens> | null;
}

export const B2BBrokerRefreshTokenResponseStatusEnum = {
    Failed: 'Failed',
    Succeeded: 'Succeeded'
} as const;

export type B2BBrokerRefreshTokenResponseStatusEnum = typeof B2BBrokerRefreshTokenResponseStatusEnum[keyof typeof B2BBrokerRefreshTokenResponseStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerRefreshTokenResponseIApiResult
 */
export interface B2BBrokerRefreshTokenResponseIApiResult {
    /**
     *
     * @type {B2BBrokerRefreshTokenResponse}
     * @memberof B2BBrokerRefreshTokenResponseIApiResult
     */
    'content'?: B2BBrokerRefreshTokenResponse | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerRefreshTokenResponseIApiResult
     */
    'status'?: B2BBrokerRefreshTokenResponseIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerRefreshTokenResponseIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerRefreshTokenResponseIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerRefreshTokenResponseIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerRefreshTokenResponseIApiResultStatusEnum = typeof B2BBrokerRefreshTokenResponseIApiResultStatusEnum[keyof typeof B2BBrokerRefreshTokenResponseIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokerSymbolInfoForOrderRequest
 */
export interface B2BBrokerSymbolInfoForOrderRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'type': B2BBrokerSymbolInfoForOrderRequestTypeEnum;
    /**
     * Symbol to trade. For example, `AAPL` or `ETH`
     * @type {string}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'symbol': string;
    /**
     * Symbol to use for payment, defaults to `USD`.
     * @type {string}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'paymentSymbol': string;
    /**
     * Amount of purchase.
     * @type {number}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'amount': number;
    /**
     * Price of the unit, used for `Limit` and `StopLoss` orders.
     * @type {number}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'price'?: number;
    /**
     * Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly.
     * @type {boolean}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'isCryptocurrency': boolean;
    /**
     * Indicates whether the `PaymentSymbol` is fiat or cryptocurrency
     * @type {boolean}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'paymentIsCryptocurrency': boolean;
    /**
     * This value indicates if the order should be executed in fiat amount (e.g. purchase ETH for $10). This can be  performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInFiatAmount` and  `SupportsPlacingBuyOrdersInFiatAmount` fields in `get supported order features for institution`) and `AmountInFiat`  value is passed.
     * @type {boolean}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'amountIsFiat': boolean;
    /**
     * Specifies the target amount in fiat currency. For example setting this to `10` when the `AmountIsFiat` = `true`  and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
     * @type {number}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'amountInFiat'?: number | null;
    /**
     * Specifies if the extended trading hours should be used.
     * @type {boolean}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'extendedHours'?: boolean;
    /**
     *
     * @type {BrokerOrderPlaceType}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'orderType': B2BBrokerSymbolInfoForOrderRequestOrderTypeEnum;
    /**
     *
     * @type {BrokerOrderTimeInForceType}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'timeInForce': B2BBrokerSymbolInfoForOrderRequestTimeInForceEnum;
    /**
     *
     * @type {BrokerOrderType}
     * @memberof B2BBrokerSymbolInfoForOrderRequest
     */
    'side'?: BrokerOrderType | null;
}

export const B2BBrokerSymbolInfoForOrderRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerSymbolInfoForOrderRequestTypeEnum = typeof B2BBrokerSymbolInfoForOrderRequestTypeEnum[keyof typeof B2BBrokerSymbolInfoForOrderRequestTypeEnum];
export const B2BBrokerSymbolInfoForOrderRequestOrderTypeEnum = {
    Unknown: 'Unknown',
    Market: 'Market',
    Limit: 'Limit',
    StopLoss: 'StopLoss',
    StopLimit: 'StopLimit',
    NetDebit: 'NetDebit',
    NetCredit: 'NetCredit',
    Exercise: 'Exercise'
} as const;

export type B2BBrokerSymbolInfoForOrderRequestOrderTypeEnum = typeof B2BBrokerSymbolInfoForOrderRequestOrderTypeEnum[keyof typeof B2BBrokerSymbolInfoForOrderRequestOrderTypeEnum];
export const B2BBrokerSymbolInfoForOrderRequestTimeInForceEnum = {
    GoodTillCanceled: 'GoodTillCanceled',
    ImmediateOrCancel: 'ImmediateOrCancel',
    FillOrKill: 'FillOrKill',
    GoodForDay: 'GoodForDay',
    PostOnly: 'PostOnly'
} as const;

export type B2BBrokerSymbolInfoForOrderRequestTimeInForceEnum = typeof B2BBrokerSymbolInfoForOrderRequestTimeInForceEnum[keyof typeof B2BBrokerSymbolInfoForOrderRequestTimeInForceEnum];

/**
 *
 * @export
 * @interface B2BBrokerTradingFeature
 */
export interface B2BBrokerTradingFeature {
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeature
     */
    'supported'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeature
     */
    'supportsFiatCurrencyPayment'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeature
     */
    'supportsCryptocurrencyPayment'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeature
     */
    'supportsMarginOrders'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeature
     */
    'supportedCryptocurrencySymbols'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeature
     */
    'supportedCryptocurrencySymbolsForPayment'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeature
     */
    'supportedFiatCurrencies'?: Array<string> | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeature
     */
    'marketType'?: B2BBrokerTradingFeatureOrderType | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeature
     */
    'limitType'?: B2BBrokerTradingFeatureOrderType | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeature
     */
    'stopLossType'?: B2BBrokerTradingFeatureOrderType | null;
}
/**
 *
 * @export
 * @interface B2BBrokerTradingFeatureInfo
 */
export interface B2BBrokerTradingFeatureInfo {
    /**
     * Type of the integration.
     * @type {BrokerType}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'brokerType'?: B2BBrokerTradingFeatureInfoBrokerTypeEnum;
    /**
     * Account Id of the integration.
     * @type {string}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'accountId'?: string | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureInfoCryptocurrencyOrders}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'cryptocurrencyOrders'?: B2BBrokerTradingFeatureInfoCryptocurrencyOrders | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureInfoStockOrders}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'stockOrders'?: B2BBrokerTradingFeatureInfoStockOrders | null;
    /**
     * Status of the request.
     * @type {BrokerRequestStatus}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'status'?: B2BBrokerTradingFeatureInfoStatusEnum;
    /**
     * Indicates if the preview of orders (`preview order execution` endpoint) is provided by the institution.  This allows to validate the order using the API of the institution. If the order preview is not supported,  Front API validates the order without calling the institution\'s API.
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'supportsOrderPreview'?: boolean;
    /**
     * Indicates if it is possible to cancel the placed order, while it\'s in the `InProgress` status.
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'supportsOrderCancellation'?: boolean;
    /**
     * Indicates if the integration is available.
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'isIntegrationUp'?: boolean;
    /**
     * Indicates if trading is generally supported at this time.
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'isTradingSupported'?: boolean;
    /**
     * List of fiat balances of the account.
     * @type {Array<B2BBrokerAccountBalance>}
     * @memberof B2BBrokerTradingFeatureInfo
     */
    'fiatBalances'?: Array<B2BBrokerAccountBalance> | null;
}

export const B2BBrokerTradingFeatureInfoBrokerTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokerTradingFeatureInfoBrokerTypeEnum = typeof B2BBrokerTradingFeatureInfoBrokerTypeEnum[keyof typeof B2BBrokerTradingFeatureInfoBrokerTypeEnum];
export const B2BBrokerTradingFeatureInfoStatusEnum = {
    Succeeded: 'Succeeded',
    Failed: 'Failed',
    NotAuthorized: 'NotAuthorized'
} as const;

export type B2BBrokerTradingFeatureInfoStatusEnum = typeof B2BBrokerTradingFeatureInfoStatusEnum[keyof typeof B2BBrokerTradingFeatureInfoStatusEnum];

/**
 * Model, describing the ability to place cryptocurrency orders.
 * @export
 * @interface B2BBrokerTradingFeatureInfoCryptocurrencyOrders
 */
export interface B2BBrokerTradingFeatureInfoCryptocurrencyOrders {
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'supported'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'supportsFiatCurrencyPayment'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'supportsCryptocurrencyPayment'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'supportsMarginOrders'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'supportedCryptocurrencySymbols'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'supportedCryptocurrencySymbolsForPayment'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'supportedFiatCurrencies'?: Array<string> | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'marketType'?: B2BBrokerTradingFeatureOrderType | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'limitType'?: B2BBrokerTradingFeatureOrderType | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeatureInfoCryptocurrencyOrders
     */
    'stopLossType'?: B2BBrokerTradingFeatureOrderType | null;
}
/**
 *
 * @export
 * @interface B2BBrokerTradingFeatureInfoIApiResult
 */
export interface B2BBrokerTradingFeatureInfoIApiResult {
    /**
     *
     * @type {B2BBrokerTradingFeatureInfo}
     * @memberof B2BBrokerTradingFeatureInfoIApiResult
     */
    'content'?: B2BBrokerTradingFeatureInfo | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerTradingFeatureInfoIApiResult
     */
    'status'?: B2BBrokerTradingFeatureInfoIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerTradingFeatureInfoIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerTradingFeatureInfoIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerTradingFeatureInfoIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerTradingFeatureInfoIApiResultStatusEnum = typeof B2BBrokerTradingFeatureInfoIApiResultStatusEnum[keyof typeof B2BBrokerTradingFeatureInfoIApiResultStatusEnum];

/**
 * Model, describing the ability to place equity orders.
 * @export
 * @interface B2BBrokerTradingFeatureInfoStockOrders
 */
export interface B2BBrokerTradingFeatureInfoStockOrders {
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'supported'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'supportsFiatCurrencyPayment'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'supportsCryptocurrencyPayment'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'supportsMarginOrders'?: boolean;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'supportedCryptocurrencySymbols'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'supportedCryptocurrencySymbolsForPayment'?: Array<string> | null;
    /**
     *
     * @type {Array<string>}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'supportedFiatCurrencies'?: Array<string> | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'marketType'?: B2BBrokerTradingFeatureOrderType | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'limitType'?: B2BBrokerTradingFeatureOrderType | null;
    /**
     *
     * @type {B2BBrokerTradingFeatureOrderType}
     * @memberof B2BBrokerTradingFeatureInfoStockOrders
     */
    'stopLossType'?: B2BBrokerTradingFeatureOrderType | null;
}
/**
 *
 * @export
 * @interface B2BBrokerTradingFeatureOrderType
 */
export interface B2BBrokerTradingFeatureOrderType {
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureOrderType
     */
    'supported'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureOrderType
     */
    'supportsFractionalShares'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureOrderType
     */
    'supportsExtendedMarketHours'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureOrderType
     */
    'supportsPlacingBuyOrdersInFiatAmount'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BBrokerTradingFeatureOrderType
     */
    'supportsPlacingSellOrdersInFiatAmount'?: boolean;
    /**
     *
     * @type {Array<BrokerOrderTimeInForceType>}
     * @memberof B2BBrokerTradingFeatureOrderType
     */
    'supportedTimeInForceList'?: Array<BrokerOrderTimeInForceType> | null;
}
/**
 *
 * @export
 * @interface B2BBrokerTransactionsListModel
 */
export interface B2BBrokerTransactionsListModel {
    /**
     *
     * @type {Array<B2BBrokerCryptocurrencyTransaction>}
     * @memberof B2BBrokerTransactionsListModel
     */
    'transfers'?: Array<B2BBrokerCryptocurrencyTransaction> | null;
    /**
     *
     * @type {number}
     * @memberof B2BBrokerTransactionsListModel
     */
    'total'?: number;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerTransactionsListModel
     */
    'cursor'?: string | null;
}
/**
 *
 * @export
 * @interface B2BBrokerTransactionsListModelIApiResult
 */
export interface B2BBrokerTransactionsListModelIApiResult {
    /**
     *
     * @type {B2BBrokerTransactionsListModel}
     * @memberof B2BBrokerTransactionsListModelIApiResult
     */
    'content'?: B2BBrokerTransactionsListModel | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokerTransactionsListModelIApiResult
     */
    'status'?: B2BBrokerTransactionsListModelIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerTransactionsListModelIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokerTransactionsListModelIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokerTransactionsListModelIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokerTransactionsListModelIApiResultStatusEnum = typeof B2BBrokerTransactionsListModelIApiResultStatusEnum[keyof typeof B2BBrokerTransactionsListModelIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BBrokersHealthStatus
 */
export interface B2BBrokersHealthStatus {
    /**
     * Type of the integration
     * @type {BrokerType}
     * @memberof B2BBrokersHealthStatus
     */
    'type'?: B2BBrokersHealthStatusTypeEnum;
    /**
     * Is the communication with the integration up
     * @type {boolean}
     * @memberof B2BBrokersHealthStatus
     */
    'isUp'?: boolean;
    /**
     * Description of the outage
     * @type {string}
     * @memberof B2BBrokersHealthStatus
     */
    'description'?: string | null;
    /**
     * Unix timestamp in seconds indicating when the outage occurred
     * @type {number}
     * @memberof B2BBrokersHealthStatus
     */
    'downTimeStart'?: number | null;
    /**
     * Unix timestamp in seconds indicating expected end of the outage
     * @type {number}
     * @memberof B2BBrokersHealthStatus
     */
    'downTimeEnd'?: number | null;
    /**
     * Get products supported by the financial institution
     * @type {Array<BrokerFeature>}
     * @memberof B2BBrokersHealthStatus
     */
    'supportedProducts'?: Array<BrokerFeature> | null;
}

export const B2BBrokersHealthStatusTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type B2BBrokersHealthStatusTypeEnum = typeof B2BBrokersHealthStatusTypeEnum[keyof typeof B2BBrokersHealthStatusTypeEnum];

/**
 *
 * @export
 * @interface B2BBrokersHealthStatusListIApiResult
 */
export interface B2BBrokersHealthStatusListIApiResult {
    /**
     *
     * @type {Array<B2BBrokersHealthStatus>}
     * @memberof B2BBrokersHealthStatusListIApiResult
     */
    'content'?: Array<B2BBrokersHealthStatus> | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BBrokersHealthStatusListIApiResult
     */
    'status'?: B2BBrokersHealthStatusListIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BBrokersHealthStatusListIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BBrokersHealthStatusListIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BBrokersHealthStatusListIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BBrokersHealthStatusListIApiResultStatusEnum = typeof B2BBrokersHealthStatusListIApiResultStatusEnum[keyof typeof B2BBrokersHealthStatusListIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BCryptocurrencyFisco
 */
export interface B2BCryptocurrencyFisco {
    /**
     *
     * @type {string}
     * @memberof B2BCryptocurrencyFisco
     */
    'symbol'?: string | null;
    /**
     *
     * @type {B2BCryptocurrencyFiscoData}
     * @memberof B2BCryptocurrencyFisco
     */
    'frontScore'?: B2BCryptocurrencyFiscoData | null;
}
/**
 *
 * @export
 * @interface B2BCryptocurrencyFiscoData
 */
export interface B2BCryptocurrencyFiscoData {
    /**
     *
     * @type {number}
     * @memberof B2BCryptocurrencyFiscoData
     */
    'frontScore'?: number;
    /**
     *
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BCryptocurrencyFiscoData
     */
    'totalScore'?: B2BCryptocurrencyFiscoDataTotalScoreEnum;
    /**
     *
     * @type {boolean}
     * @memberof B2BCryptocurrencyFiscoData
     */
    'isCompatibilityScoreApplied'?: boolean;
}

export const B2BCryptocurrencyFiscoDataTotalScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BCryptocurrencyFiscoDataTotalScoreEnum = typeof B2BCryptocurrencyFiscoDataTotalScoreEnum[keyof typeof B2BCryptocurrencyFiscoDataTotalScoreEnum];

/**
 *
 * @export
 * @interface B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResult
 */
export interface B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResult {
    /**
     *
     * @type {Array<B2BCryptocurrencyFisco>}
     * @memberof B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResult
     */
    'content'?: Array<B2BCryptocurrencyFisco> | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResult
     */
    'status'?: B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResultStatusEnum = typeof B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResultStatusEnum[keyof typeof B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BNftPosition
 */
export interface B2BNftPosition {
    /**
     *
     * @type {number}
     * @memberof B2BNftPosition
     */
    'amount'?: number;
    /**
     *
     * @type {number}
     * @memberof B2BNftPosition
     */
    'costBasis'?: number | null;
    /**
     *
     * @type {string}
     * @memberof B2BNftPosition
     */
    'contractAddress'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BNftPosition
     */
    'name'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BNftPosition
     */
    'description'?: string | null;
    /**
     *
     * @type {number}
     * @memberof B2BNftPosition
     */
    'marketplaceId'?: number;
    /**
     *
     * @type {string}
     * @memberof B2BNftPosition
     */
    'tokenId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BNftPosition
     */
    'marketplacePermalink'?: string | null;
    /**
     *
     * @type {CryptocurrencyAddressType}
     * @memberof B2BNftPosition
     */
    'addressType'?: B2BNftPositionAddressTypeEnum;
}

export const B2BNftPositionAddressTypeEnum = {
    EthAddress: 'EthAddress',
    BtcAddress: 'BtcAddress',
    LtcAddress: 'LtcAddress',
    SolAddress: 'SolAddress',
    AlgoAddress: 'AlgoAddress',
    CeloAddress: 'CeloAddress',
    CardanoAddress: 'CardanoAddress',
    PolygonAddress: 'PolygonAddress',
    BnbAddress: 'BnbAddress',
    ElrondAddress: 'ElrondAddress',
    NeoAddress: 'NeoAddress',
    XrpAddress: 'XrpAddress',
    FlowAddress: 'FlowAddress',
    HarmonyOneAddress: 'HarmonyOneAddress',
    TronAddress: 'TronAddress',
    DogeAddress: 'DogeAddress'
} as const;

export type B2BNftPositionAddressTypeEnum = typeof B2BNftPositionAddressTypeEnum[keyof typeof B2BNftPositionAddressTypeEnum];

/**
 *
 * @export
 * @interface B2BOptimizedPortfolio
 */
export interface B2BOptimizedPortfolio {
    /**
     *
     * @type {number}
     * @memberof B2BOptimizedPortfolio
     */
    'annualizedStandardDeviation'?: number;
    /**
     *
     * @type {number}
     * @memberof B2BOptimizedPortfolio
     */
    'performance'?: number;
    /**
     *
     * @type {Array<AssetWeight>}
     * @memberof B2BOptimizedPortfolio
     */
    'assetWeights'?: Array<AssetWeight> | null;
    /**
     *
     * @type {number}
     * @memberof B2BOptimizedPortfolio
     */
    'value'?: number;
    /**
     *
     * @type {Array<ChartItem>}
     * @memberof B2BOptimizedPortfolio
     */
    'chartItems'?: Array<ChartItem> | null;
}
/**
 *
 * @export
 * @interface B2BOptionPosition
 */
export interface B2BOptionPosition {
    /**
     * Symbol of the underlying stock
     * @type {string}
     * @memberof B2BOptionPosition
     */
    'symbol'?: string | null;
    /**
     * Amount of options
     * @type {number}
     * @memberof B2BOptionPosition
     */
    'amount'?: number;
    /**
     * Total average paid price
     * @type {number}
     * @memberof B2BOptionPosition
     */
    'averageOpenPrice'?: number;
    /**
     * Side of the option, buy or sell
     * @type {BrokerOptionDirection}
     * @memberof B2BOptionPosition
     */
    'direction'?: B2BOptionPositionDirectionEnum;
    /**
     *
     * @type {number}
     * @memberof B2BOptionPosition
     */
    'createdTimestamp'?: number;
    /**
     *
     * @type {number}
     * @memberof B2BOptionPosition
     */
    'updatedTimestamp'?: number;
    /**
     * Number of shares of the underlying stock
     * @type {number}
     * @memberof B2BOptionPosition
     */
    'numberOfSharesInContract'?: number;
    /**
     * Type of the option, put or call
     * @type {BrokerOptionType}
     * @memberof B2BOptionPosition
     */
    'optionType'?: B2BOptionPositionOptionTypeEnum;
    /**
     * The last day that the option contract is valid
     * @type {string}
     * @memberof B2BOptionPosition
     */
    'expirationDate'?: string | null;
    /**
     * The price at which a put or call option can be exercised
     * @type {number}
     * @memberof B2BOptionPosition
     */
    'strikePrice'?: number;
}

export const B2BOptionPositionDirectionEnum = {
    Unknown: 'Unknown',
    BuyToOpen: 'BuyToOpen',
    BuyToClose: 'BuyToClose',
    SellToOpen: 'SellToOpen',
    SellToClose: 'SellToClose',
    BuyToCover: 'BuyToCover',
    SellShort: 'SellShort'
} as const;

export type B2BOptionPositionDirectionEnum = typeof B2BOptionPositionDirectionEnum[keyof typeof B2BOptionPositionDirectionEnum];
export const B2BOptionPositionOptionTypeEnum = {
    Unknown: 'Unknown',
    Call: 'Call',
    Put: 'Put'
} as const;

export type B2BOptionPositionOptionTypeEnum = typeof B2BOptionPositionOptionTypeEnum[keyof typeof B2BOptionPositionOptionTypeEnum];

/**
 *
 * @export
 * @interface B2BOriginalPortfolio
 */
export interface B2BOriginalPortfolio {
    /**
     *
     * @type {number}
     * @memberof B2BOriginalPortfolio
     */
    'annualizedStandardDeviation'?: number;
    /**
     *
     * @type {number}
     * @memberof B2BOriginalPortfolio
     */
    'performance'?: number;
    /**
     *
     * @type {Array<AssetWeight>}
     * @memberof B2BOriginalPortfolio
     */
    'assetWeights'?: Array<AssetWeight> | null;
    /**
     *
     * @type {number}
     * @memberof B2BOriginalPortfolio
     */
    'value'?: number;
    /**
     *
     * @type {Array<ChartItem>}
     * @memberof B2BOriginalPortfolio
     */
    'chartItems'?: Array<ChartItem> | null;
    /**
     *
     * @type {number}
     * @memberof B2BOriginalPortfolio
     */
    'startingValue'?: number;
}
/**
 *
 * @export
 * @interface B2BPortfolioFisco
 */
export interface B2BPortfolioFisco {
    /**
     *
     * @type {number}
     * @memberof B2BPortfolioFisco
     */
    'frontScore'?: number;
    /**
     *
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BPortfolioFisco
     */
    'totalScore'?: B2BPortfolioFiscoTotalScoreEnum;
    /**
     *
     * @type {number}
     * @memberof B2BPortfolioFisco
     */
    'maxFrontScore'?: number;
    /**
     *
     * @type {number}
     * @memberof B2BPortfolioFisco
     */
    'minFrontScore'?: number;
    /**
     * Front analyzes available financial data to reach a determination on risk associated with an asset based on its underlying financial conditions.  The Financials Score is a strong metric for investors who seek stocks that are underperforming and ripe for growth.
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BPortfolioFisco
     */
    'financialScore'?: B2BPortfolioFiscoFinancialScoreEnum;
    /**
     * Front\'s proprietary algorithm performs advanced statistical analysis.  We use tools popular among hedge funds to assess historical performance based on different categories and volatility of assets over a short period of time.
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BPortfolioFisco
     */
    'performanceScore'?: B2BPortfolioFiscoPerformanceScoreEnum;
    /**
     * Front Market Monitor autonomously crawls tens of thousands of websites  at a time and assigns each stock a score based on the news stories
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BPortfolioFisco
     */
    'newsScore'?: B2BPortfolioFiscoNewsScoreEnum;
    /**
     *
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BPortfolioFisco
     */
    'predictionScore'?: B2BPortfolioFiscoPredictionScoreEnum;
    /**
     *
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BPortfolioFisco
     */
    'residualReturnScore'?: B2BPortfolioFiscoResidualReturnScoreEnum;
    /**
     * Portfolio diversification score
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BPortfolioFisco
     */
    'diversificationScore'?: FiscoIngredientScoreEnum | null;
    /**
     * Environmental, Social, Governance  Parameters are a set of standards used to evaluate investments.  Environmental criteria consider how a company performs as a proponent of nature.  Social criteria examine how it manages relationships with employees, suppliers, customers,  and the communities where it operates. Governance deals with a companys leadership, audits, and shareholder rights.
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BPortfolioFisco
     */
    'esgScore'?: B2BPortfolioFiscoEsgScoreEnum;
    /**
     *
     * @type {boolean}
     * @memberof B2BPortfolioFisco
     */
    'isEsgScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BPortfolioFisco
     */
    'isFinancialScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BPortfolioFisco
     */
    'isPerformanceScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BPortfolioFisco
     */
    'isNewsScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BPortfolioFisco
     */
    'isPredictionScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BPortfolioFisco
     */
    'isResidualReturnScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BPortfolioFisco
     */
    'isDiversificationScoreApplied'?: boolean;
}

export const B2BPortfolioFiscoTotalScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BPortfolioFiscoTotalScoreEnum = typeof B2BPortfolioFiscoTotalScoreEnum[keyof typeof B2BPortfolioFiscoTotalScoreEnum];
export const B2BPortfolioFiscoFinancialScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BPortfolioFiscoFinancialScoreEnum = typeof B2BPortfolioFiscoFinancialScoreEnum[keyof typeof B2BPortfolioFiscoFinancialScoreEnum];
export const B2BPortfolioFiscoPerformanceScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BPortfolioFiscoPerformanceScoreEnum = typeof B2BPortfolioFiscoPerformanceScoreEnum[keyof typeof B2BPortfolioFiscoPerformanceScoreEnum];
export const B2BPortfolioFiscoNewsScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BPortfolioFiscoNewsScoreEnum = typeof B2BPortfolioFiscoNewsScoreEnum[keyof typeof B2BPortfolioFiscoNewsScoreEnum];
export const B2BPortfolioFiscoPredictionScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BPortfolioFiscoPredictionScoreEnum = typeof B2BPortfolioFiscoPredictionScoreEnum[keyof typeof B2BPortfolioFiscoPredictionScoreEnum];
export const B2BPortfolioFiscoResidualReturnScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BPortfolioFiscoResidualReturnScoreEnum = typeof B2BPortfolioFiscoResidualReturnScoreEnum[keyof typeof B2BPortfolioFiscoResidualReturnScoreEnum];
export const B2BPortfolioFiscoEsgScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BPortfolioFiscoEsgScoreEnum = typeof B2BPortfolioFiscoEsgScoreEnum[keyof typeof B2BPortfolioFiscoEsgScoreEnum];

/**
 *
 * @export
 * @interface B2BPortfolioFiscoIApiResult
 */
export interface B2BPortfolioFiscoIApiResult {
    /**
     *
     * @type {B2BPortfolioFisco}
     * @memberof B2BPortfolioFiscoIApiResult
     */
    'content'?: B2BPortfolioFisco | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BPortfolioFiscoIApiResult
     */
    'status'?: B2BPortfolioFiscoIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BPortfolioFiscoIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BPortfolioFiscoIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BPortfolioFiscoIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BPortfolioFiscoIApiResultStatusEnum = typeof B2BPortfolioFiscoIApiResultStatusEnum[keyof typeof B2BPortfolioFiscoIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BPortfolioModel
 */
export interface B2BPortfolioModel {
    /**
     * Amount of money spent to buy all positions of the portfolio.
     * @type {number}
     * @memberof B2BPortfolioModel
     */
    'portfolioCostBasis'?: number | null;
    /**
     * Actual performance based on the cost basis.
     * @type {number}
     * @memberof B2BPortfolioModel
     */
    'actualPortfolioPerformance'?: number | null;
    /**
     * Total USD portfolio value of all equities (sum(equity price * equity amount)). Does not include cash balance.
     * @type {number}
     * @memberof B2BPortfolioModel
     */
    'equitiesValue'?: number;
    /**
     * Total USD value of all cryptocurrencies in the portfolio.
     * @type {number}
     * @memberof B2BPortfolioModel
     */
    'cryptocurrenciesValue'?: number;
    /**
     * Total USD value of all NFTs in the portfolio.
     * @type {number}
     * @memberof B2BPortfolioModel
     */
    'nftsValue'?: number;
    /**
     * List of equity positions
     * @type {Array<B2BPositionWithMarketValues>}
     * @memberof B2BPortfolioModel
     */
    'equityPositions'?: Array<B2BPositionWithMarketValues> | null;
    /**
     * List of cryptocurrency positions
     * @type {Array<B2BPositionWithMarketValues>}
     * @memberof B2BPortfolioModel
     */
    'cryptocurrencyPositions'?: Array<B2BPositionWithMarketValues> | null;
    /**
     * List of NFT positions
     * @type {Array<NftPositionWithMarketValues>}
     * @memberof B2BPortfolioModel
     */
    'nftPositions'?: Array<NftPositionWithMarketValues> | null;
}
/**
 *
 * @export
 * @interface B2BPortfolioModelIApiResult
 */
export interface B2BPortfolioModelIApiResult {
    /**
     *
     * @type {B2BPortfolioModel}
     * @memberof B2BPortfolioModelIApiResult
     */
    'content'?: B2BPortfolioModel | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BPortfolioModelIApiResult
     */
    'status'?: B2BPortfolioModelIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BPortfolioModelIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BPortfolioModelIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BPortfolioModelIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BPortfolioModelIApiResultStatusEnum = typeof B2BPortfolioModelIApiResultStatusEnum[keyof typeof B2BPortfolioModelIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BPortfolioOptimizationModel
 */
export interface B2BPortfolioOptimizationModel {
    /**
     *
     * @type {B2BOriginalPortfolio}
     * @memberof B2BPortfolioOptimizationModel
     */
    'originalPortfolio'?: B2BOriginalPortfolio | null;
    /**
     *
     * @type {Array<B2BOptimizedPortfolio>}
     * @memberof B2BPortfolioOptimizationModel
     */
    'optimizedPortfolios'?: Array<B2BOptimizedPortfolio> | null;
}
/**
 *
 * @export
 * @interface B2BPortfolioOptimizationModelIApiResult
 */
export interface B2BPortfolioOptimizationModelIApiResult {
    /**
     *
     * @type {B2BPortfolioOptimizationModel}
     * @memberof B2BPortfolioOptimizationModelIApiResult
     */
    'content'?: B2BPortfolioOptimizationModel | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BPortfolioOptimizationModelIApiResult
     */
    'status'?: B2BPortfolioOptimizationModelIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BPortfolioOptimizationModelIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BPortfolioOptimizationModelIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BPortfolioOptimizationModelIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BPortfolioOptimizationModelIApiResultStatusEnum = typeof B2BPortfolioOptimizationModelIApiResultStatusEnum[keyof typeof B2BPortfolioOptimizationModelIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BPosition
 */
export interface B2BPosition {
    /**
     * Symbol of the asset
     * @type {string}
     * @memberof B2BPosition
     */
    'symbol'?: string | null;
    /**
     * Amount of the asset
     * @type {number}
     * @memberof B2BPosition
     */
    'amount'?: number;
    /**
     * The total original value (or purchase price) of the asset
     * @type {number}
     * @memberof B2BPosition
     */
    'costBasis'?: number | null;
}
/**
 *
 * @export
 * @interface B2BPositionWithMarketValues
 */
export interface B2BPositionWithMarketValues {
    /**
     * Symbol of the asset
     * @type {string}
     * @memberof B2BPositionWithMarketValues
     */
    'symbol'?: string | null;
    /**
     * Amount of the asset
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'amount'?: number;
    /**
     * The total original value (or purchase price) of the asset
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'costBasis'?: number | null;
    /**
     * Market value of the asset: amount of asset multiplied by last asset value.
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'marketValue'?: number | null;
    /**
     * What percentage of total portfolio value is taken by this asset.
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'portfolioPercentage'?: number | null;
    /**
     * Total return of investment of this asset. Can be negative or null. Based on the cost basis of the asset, cost basis  is not available by some of integrations.
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'totalReturn'?: number | null;
    /**
     * Percent of return of investment for this asset. Can be negative or null.
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'returnPercentage'?: number | null;
    /**
     * Current last price of the asset.
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'lastPrice'?: number | null;
    /**
     * Company name of the relative asset/
     * @type {string}
     * @memberof B2BPositionWithMarketValues
     */
    'companyName'?: string | null;
    /**
     * Total daily return of investment for this asset. Can be negative.
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'totalDailyReturn'?: number | null;
    /**
     * Daily percent of return of investment for this asset. Can be negative.
     * @type {number}
     * @memberof B2BPositionWithMarketValues
     */
    'dailyReturnPercentage'?: number | null;
}
/**
 *
 * @export
 * @interface B2BStockFisco
 */
export interface B2BStockFisco {
    /**
     *
     * @type {string}
     * @memberof B2BStockFisco
     */
    'symbol'?: string | null;
    /**
     *
     * @type {B2BStockFiscoData}
     * @memberof B2BStockFisco
     */
    'frontScore'?: B2BStockFiscoData | null;
}
/**
 *
 * @export
 * @interface B2BStockFiscoData
 */
export interface B2BStockFiscoData {
    /**
     *
     * @type {number}
     * @memberof B2BStockFiscoData
     */
    'frontScore'?: number;
    /**
     *
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BStockFiscoData
     */
    'totalScore'?: B2BStockFiscoDataTotalScoreEnum;
    /**
     *
     * @type {number}
     * @memberof B2BStockFiscoData
     */
    'maxFrontScore'?: number;
    /**
     *
     * @type {number}
     * @memberof B2BStockFiscoData
     */
    'minFrontScore'?: number;
    /**
     * Front analyzes available financial data to reach a determination on risk associated with an asset based on its underlying financial conditions.  The Financials Score is a strong metric for investors who seek stocks that are underperforming and ripe for growth.
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BStockFiscoData
     */
    'financialScore'?: B2BStockFiscoDataFinancialScoreEnum;
    /**
     * Front\'s proprietary algorithm performs advanced statistical analysis.  We use tools popular among hedge funds to assess historical performance based on different categories and volatility of assets over a short period of time.
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BStockFiscoData
     */
    'performanceScore'?: B2BStockFiscoDataPerformanceScoreEnum;
    /**
     * Front Market Monitor autonomously crawls tens of thousands of websites  at a time and assigns each stock a score based on the news stories
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BStockFiscoData
     */
    'newsScore'?: B2BStockFiscoDataNewsScoreEnum;
    /**
     *
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BStockFiscoData
     */
    'predictionScore'?: B2BStockFiscoDataPredictionScoreEnum;
    /**
     *
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BStockFiscoData
     */
    'residualReturnScore'?: B2BStockFiscoDataResidualReturnScoreEnum;
    /**
     * Portfolio diversification score
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BStockFiscoData
     */
    'diversificationScore'?: FiscoIngredientScoreEnum | null;
    /**
     * Environmental, Social, Governance  Parameters are a set of standards used to evaluate investments.  Environmental criteria consider how a company performs as a proponent of nature.  Social criteria examine how it manages relationships with employees, suppliers, customers,  and the communities where it operates. Governance deals with a companys leadership, audits, and shareholder rights.
     * @type {FiscoIngredientScoreEnum}
     * @memberof B2BStockFiscoData
     */
    'esgScore'?: B2BStockFiscoDataEsgScoreEnum;
    /**
     *
     * @type {boolean}
     * @memberof B2BStockFiscoData
     */
    'isCompatibilityScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BStockFiscoData
     */
    'isEsgScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BStockFiscoData
     */
    'isFinancialScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BStockFiscoData
     */
    'isPerformanceScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BStockFiscoData
     */
    'isNewsScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BStockFiscoData
     */
    'isPredictionScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BStockFiscoData
     */
    'isResidualReturnScoreApplied'?: boolean;
    /**
     *
     * @type {boolean}
     * @memberof B2BStockFiscoData
     */
    'isDiversificationScoreApplied'?: boolean;
}

export const B2BStockFiscoDataTotalScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BStockFiscoDataTotalScoreEnum = typeof B2BStockFiscoDataTotalScoreEnum[keyof typeof B2BStockFiscoDataTotalScoreEnum];
export const B2BStockFiscoDataFinancialScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BStockFiscoDataFinancialScoreEnum = typeof B2BStockFiscoDataFinancialScoreEnum[keyof typeof B2BStockFiscoDataFinancialScoreEnum];
export const B2BStockFiscoDataPerformanceScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BStockFiscoDataPerformanceScoreEnum = typeof B2BStockFiscoDataPerformanceScoreEnum[keyof typeof B2BStockFiscoDataPerformanceScoreEnum];
export const B2BStockFiscoDataNewsScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BStockFiscoDataNewsScoreEnum = typeof B2BStockFiscoDataNewsScoreEnum[keyof typeof B2BStockFiscoDataNewsScoreEnum];
export const B2BStockFiscoDataPredictionScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BStockFiscoDataPredictionScoreEnum = typeof B2BStockFiscoDataPredictionScoreEnum[keyof typeof B2BStockFiscoDataPredictionScoreEnum];
export const B2BStockFiscoDataResidualReturnScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BStockFiscoDataResidualReturnScoreEnum = typeof B2BStockFiscoDataResidualReturnScoreEnum[keyof typeof B2BStockFiscoDataResidualReturnScoreEnum];
export const B2BStockFiscoDataEsgScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type B2BStockFiscoDataEsgScoreEnum = typeof B2BStockFiscoDataEsgScoreEnum[keyof typeof B2BStockFiscoDataEsgScoreEnum];

/**
 *
 * @export
 * @interface B2BStockFiscoIReadOnlyCollectionIApiResult
 */
export interface B2BStockFiscoIReadOnlyCollectionIApiResult {
    /**
     *
     * @type {Array<B2BStockFisco>}
     * @memberof B2BStockFiscoIReadOnlyCollectionIApiResult
     */
    'content'?: Array<B2BStockFisco> | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BStockFiscoIReadOnlyCollectionIApiResult
     */
    'status'?: B2BStockFiscoIReadOnlyCollectionIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BStockFiscoIReadOnlyCollectionIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BStockFiscoIReadOnlyCollectionIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BStockFiscoIReadOnlyCollectionIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BStockFiscoIReadOnlyCollectionIApiResultStatusEnum = typeof B2BStockFiscoIReadOnlyCollectionIApiResultStatusEnum[keyof typeof B2BStockFiscoIReadOnlyCollectionIApiResultStatusEnum];

/**
 *
 * @export
 * @interface B2BSymbolNewsData
 */
export interface B2BSymbolNewsData {
    /**
     * The identifier of the news item.
     * @type {string}
     * @memberof B2BSymbolNewsData
     */
    'id'?: string;
    /**
     * The title of the news.
     * @type {string}
     * @memberof B2BSymbolNewsData
     */
    'title'?: string | null;
    /**
     * The news content.
     * @type {string}
     * @memberof B2BSymbolNewsData
     */
    'content'?: string | null;
    /**
     * The url of the image related to th news.
     * @type {string}
     * @memberof B2BSymbolNewsData
     */
    'imageUrl'?: string | null;
    /**
     * The name of the news source.
     * @type {string}
     * @memberof B2BSymbolNewsData
     */
    'source'?: string | null;
    /**
     * The url of the news source.
     * @type {string}
     * @memberof B2BSymbolNewsData
     */
    'sourceUrl'?: string | null;
    /**
     * The time of the creation of the news.
     * @type {number}
     * @memberof B2BSymbolNewsData
     */
    'createdTimestamp'?: number;
    /**
     * The url where the news is available.
     * @type {string}
     * @memberof B2BSymbolNewsData
     */
    'url'?: string | null;
    /**
     * Integer value which describes the relevance of the news in the Front system.
     * @type {number}
     * @memberof B2BSymbolNewsData
     */
    'rank'?: number;
    /**
     * List of stock symbols mentioned in the news.
     * @type {Array<string>}
     * @memberof B2BSymbolNewsData
     */
    'symbols'?: Array<string> | null;
    /**
     * List of cryptocurrencies mentioned in the news.
     * @type {Array<string>}
     * @memberof B2BSymbolNewsData
     */
    'cryptocurrencySymbols'?: Array<string> | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const B2BSymbolNewsOrder = {
    Rank: 'Rank',
    Timestamp: 'Timestamp'
} as const;

export type B2BSymbolNewsOrder = typeof B2BSymbolNewsOrder[keyof typeof B2BSymbolNewsOrder];


/**
 *
 * @export
 * @interface B2BSymbolNewsResponse
 */
export interface B2BSymbolNewsResponse {
    /**
     * The collection of news.
     * @type {Array<B2BSymbolNewsData>}
     * @memberof B2BSymbolNewsResponse
     */
    'news'?: Array<B2BSymbolNewsData> | null;
    /**
     * The total count of news related to the symbol
     * @type {number}
     * @memberof B2BSymbolNewsResponse
     */
    'count'?: number;
}
/**
 *
 * @export
 * @interface B2BSymbolNewsResponseIApiResult
 */
export interface B2BSymbolNewsResponseIApiResult {
    /**
     *
     * @type {B2BSymbolNewsResponse}
     * @memberof B2BSymbolNewsResponseIApiResult
     */
    'content'?: B2BSymbolNewsResponse | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof B2BSymbolNewsResponseIApiResult
     */
    'status'?: B2BSymbolNewsResponseIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof B2BSymbolNewsResponseIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof B2BSymbolNewsResponseIApiResult
     */
    'displayMessage'?: string | null;
}

export const B2BSymbolNewsResponseIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type B2BSymbolNewsResponseIApiResultStatusEnum = typeof B2BSymbolNewsResponseIApiResultStatusEnum[keyof typeof B2BSymbolNewsResponseIApiResultStatusEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const B2BSymbolNewsSortingDirection = {
    Ascending: 'Ascending',
    Descending: 'Descending'
} as const;

export type B2BSymbolNewsSortingDirection = typeof B2BSymbolNewsSortingDirection[keyof typeof B2BSymbolNewsSortingDirection];


/**
 *
 * @export
 * @enum {string}
 */

export const B2BTransactionType = {
    Order: 'Order',
    ConversionTo: 'ConversionTo',
    ConversionFrom: 'ConversionFrom',
    OwnAccountDeposit: 'OwnAccountDeposit',
    OwnAccountWithdraw: 'OwnAccountWithdraw',
    Stake: 'Stake',
    DividendReinvestment: 'DividendReinvestment',
    Interest: 'Interest',
    Reward: 'Reward',
    Unknown: 'Unknown',
    ConversionToFiat: 'ConversionToFiat',
    ConversionFromFiat: 'ConversionFromFiat'
} as const;

export type B2BTransactionType = typeof B2BTransactionType[keyof typeof B2BTransactionType];


/**
 *
 * @export
 * @interface BrokerAccount
 */
export interface BrokerAccount {
    /**
     *
     * @type {string}
     * @memberof BrokerAccount
     */
    'accountId'?: string | null;
    /**
     *
     * @type {string}
     * @memberof BrokerAccount
     */
    'accountName'?: string | null;
    /**
     * Buying power of the account. Typically consists of cash plus available margin.  For non-margin accounts fund contains cash only
     * @type {number}
     * @memberof BrokerAccount
     */
    'fund'?: number | null;
    /**
     * Cash balance in USD
     * @type {number}
     * @memberof BrokerAccount
     */
    'cash'?: number | null;
    /**
     * Indicates if this account was already connected by the current user and device.  Can be null.
     * @type {boolean}
     * @memberof BrokerAccount
     */
    'isReconnected'?: boolean | null;
    /**
     * The list of all asset balances of account
     * @type {Array<BrokerFiatBalance>}
     * @memberof BrokerAccount
     */
    'balances'?: Array<BrokerFiatBalance> | null;
}
/**
 *
 * @export
 * @interface BrokerAccountTokens
 */
export interface BrokerAccountTokens {
    /**
     *
     * @type {BrokerAccount}
     * @memberof BrokerAccountTokens
     */
    'account'?: BrokerAccount | null;
    /**
     *
     * @type {string}
     * @memberof BrokerAccountTokens
     */
    'accessToken'?: string | null;
    /**
     *
     * @type {string}
     * @memberof BrokerAccountTokens
     */
    'refreshToken'?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const BrokerAuthPromptStatus = {
    Failed: 'Failed',
    Redirect: 'Redirect',
    OpenInBrokerModule: 'OpenInBrokerModule'
} as const;

export type BrokerAuthPromptStatus = typeof BrokerAuthPromptStatus[keyof typeof BrokerAuthPromptStatus];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerAuthStatus = {
    Failed: 'Failed',
    ChallengeFailed: 'ChallengeFailed',
    Succeeded: 'Succeeded',
    ChallengeIssued: 'ChallengeIssued',
    MfaRequired: 'MfaRequired',
    OpenInBrokerModule: 'OpenInBrokerModule',
    Delayed: 'Delayed'
} as const;

export type BrokerAuthStatus = typeof BrokerAuthStatus[keyof typeof BrokerAuthStatus];


/**
 *
 * @export
 * @interface BrokerAuthenticationScheme
 */
export interface BrokerAuthenticationScheme {
    /**
     *
     * @type {BrokerType}
     * @memberof BrokerAuthenticationScheme
     */
    'brokerType'?: BrokerAuthenticationSchemeBrokerTypeEnum;
    /**
     * Type of authentication for the integration.
     * @type {AuthenticationSchemeType}
     * @memberof BrokerAuthenticationScheme
     */
    'authenticationSchemeType'?: BrokerAuthenticationSchemeAuthenticationSchemeTypeEnum;
    /**
     *
     * @type {BrokerAuthenticationSchemeInitialAuthenticationModel}
     * @memberof BrokerAuthenticationScheme
     */
    'initialAuthenticationModel'?: BrokerAuthenticationSchemeInitialAuthenticationModel | null;
    /**
     * Set of fields that should be provided depending on the status of the response of the first POST `authenticate` request.
     * @type {Array<AuthenticationModel>}
     * @memberof BrokerAuthenticationScheme
     */
    'authenticationSteps'?: Array<AuthenticationModel> | null;
    /**
     * Supported MFA schemes, can be none or multiple.
     * @type {Array<MfaScheme>}
     * @memberof BrokerAuthenticationScheme
     */
    'mfaSchemes'?: Array<MfaScheme> | null;
    /**
     * Optional URL with the instructions explaining how to create a set of API key/secret for the integration, can be shown to the end user.
     * @type {string}
     * @memberof BrokerAuthenticationScheme
     */
    'instructionsUrl'?: string | null;
}

export const BrokerAuthenticationSchemeBrokerTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type BrokerAuthenticationSchemeBrokerTypeEnum = typeof BrokerAuthenticationSchemeBrokerTypeEnum[keyof typeof BrokerAuthenticationSchemeBrokerTypeEnum];
export const BrokerAuthenticationSchemeAuthenticationSchemeTypeEnum = {
    UsernamePassword: 'UsernamePassword',
    OAuth: 'OAuth',
    ApiKey: 'ApiKey',
    BlockchainAddress: 'BlockchainAddress'
} as const;

export type BrokerAuthenticationSchemeAuthenticationSchemeTypeEnum = typeof BrokerAuthenticationSchemeAuthenticationSchemeTypeEnum[keyof typeof BrokerAuthenticationSchemeAuthenticationSchemeTypeEnum];

/**
 *
 * @export
 * @interface BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult
 */
export interface BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult {
    /**
     *
     * @type {Array<BrokerAuthenticationScheme>}
     * @memberof BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult
     */
    'content'?: Array<BrokerAuthenticationScheme> | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult
     */
    'status'?: BrokerAuthenticationSchemeIReadOnlyCollectionIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult
     */
    'displayMessage'?: string | null;
}

export const BrokerAuthenticationSchemeIReadOnlyCollectionIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type BrokerAuthenticationSchemeIReadOnlyCollectionIApiResultStatusEnum = typeof BrokerAuthenticationSchemeIReadOnlyCollectionIApiResultStatusEnum[keyof typeof BrokerAuthenticationSchemeIReadOnlyCollectionIApiResultStatusEnum];

/**
 * Set of fields that should be provided in the initial POST `authenticate` request.
 * @export
 * @interface BrokerAuthenticationSchemeInitialAuthenticationModel
 */
export interface BrokerAuthenticationSchemeInitialAuthenticationModel {
    /**
     *
     * @type {B2BBrokerAuthResponse}
     * @memberof BrokerAuthenticationSchemeInitialAuthenticationModel
     */
    'authResponse'?: B2BBrokerAuthResponse | null;
    /**
     * Set of fields that are expected to be provided based on the status of the AuthResponse
     * @type {Array<AuthenticationFieldDescription>}
     * @memberof BrokerAuthenticationSchemeInitialAuthenticationModel
     */
    'fields'?: Array<AuthenticationFieldDescription> | null;
}
/**
 *
 * @export
 * @interface BrokerBaseRequest
 */
export interface BrokerBaseRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof BrokerBaseRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof BrokerBaseRequest
     */
    'type': BrokerBaseRequestTypeEnum;
}

export const BrokerBaseRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type BrokerBaseRequestTypeEnum = typeof BrokerBaseRequestTypeEnum[keyof typeof BrokerBaseRequestTypeEnum];

/**
 *
 * @export
 * @interface BrokerBrandInfo
 */
export interface BrokerBrandInfo {
    /**
     *
     * @type {string}
     * @memberof BrokerBrandInfo
     */
    'brokerLogo'?: string | null;
    /**
     *
     * @type {string}
     * @memberof BrokerBrandInfo
     */
    'brokerPrimaryColor'?: string | null;
}
/**
 *
 * @export
 * @interface BrokerCreateCryptocurrencyTransactionRequest
 */
export interface BrokerCreateCryptocurrencyTransactionRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'type': BrokerCreateCryptocurrencyTransactionRequestTypeEnum;
    /**
     * Additional data to send on-chain (optional, depends on an integration)
     * @type {string}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'data'?: string | null;
    /**
     * Target address to transfer the asset to
     * @type {string}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'targetAddress': string;
    /**
     * Amount to transfer
     * @type {number}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'amount'?: number;
    /**
     * On-chain fee (optional, depends on an integration)
     * @type {number}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'fee'?: number;
    /**
     * Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.  Can be used instead of `Symbol` and `Chain` fields.  To transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.
     * @type {CryptocurrencyAddressType}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'addressType'?: CryptocurrencyAddressType | null;
    /**
     * 2 Factor auth code (optional, depends on an integration)
     * @type {string}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'mfaCode'?: string | null;
    /**
     * Password or pass-phrase, required to send transfers (optional, depends on an integration)
     * @type {string}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'password'?: string | null;
    /**
     * Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.  Can be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).  Please use `symbol/details` endpoint to get the list of all possible chains.
     * @type {string}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'chain'?: string | null;
    /**
     * Memo (also called \"Tag\") - address remark.
     * @type {string}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'memo'?: string | null;
    /**
     * Symbol to be transferred. Can be provided instead of the `AddressType` field.
     * @type {string}
     * @memberof BrokerCreateCryptocurrencyTransactionRequest
     */
    'symbol'?: string | null;
}

export const BrokerCreateCryptocurrencyTransactionRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type BrokerCreateCryptocurrencyTransactionRequestTypeEnum = typeof BrokerCreateCryptocurrencyTransactionRequestTypeEnum[keyof typeof BrokerCreateCryptocurrencyTransactionRequestTypeEnum];

/**
 *
 * @export
 * @interface BrokerCryptocurrencyDepositAddressRequest
 */
export interface BrokerCryptocurrencyDepositAddressRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof BrokerCryptocurrencyDepositAddressRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof BrokerCryptocurrencyDepositAddressRequest
     */
    'type': BrokerCryptocurrencyDepositAddressRequestTypeEnum;
    /**
     * Symbol of the required cryptocurrency, e.g. ETH or BTC.  Can be used instead of the `AddressType` field.
     * @type {string}
     * @memberof BrokerCryptocurrencyDepositAddressRequest
     */
    'symbol'?: string | null;
    /**
     * Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.  Can be used instead of `Symbol` field.
     * @type {CryptocurrencyAddressType}
     * @memberof BrokerCryptocurrencyDepositAddressRequest
     */
    'addressType'?: CryptocurrencyAddressType | null;
    /**
     * Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni
     * @type {string}
     * @memberof BrokerCryptocurrencyDepositAddressRequest
     */
    'chain'?: string | null;
}

export const BrokerCryptocurrencyDepositAddressRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type BrokerCryptocurrencyDepositAddressRequestTypeEnum = typeof BrokerCryptocurrencyDepositAddressRequestTypeEnum[keyof typeof BrokerCryptocurrencyDepositAddressRequestTypeEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const BrokerCryptocurrencyTransactionBlockchainMethod = {
    Transfer: 'Transfer',
    Swap: 'Swap',
    Mint: 'Mint',
    Withdraw: 'Withdraw',
    ClaimRewards: 'ClaimRewards',
    Deposit: 'Deposit',
    Approve: 'Approve',
    ForgeToken: 'ForgeToken',
    Multicall: 'Multicall',
    MigrateToken: 'MigrateToken',
    Claim: 'Claim',
    OpenSeaTransfer: 'OpenSeaTransfer',
    Cancel: 'Cancel',
    Commit: 'Commit',
    Run: 'Run',
    Repay: 'Repay',
    Execute: 'Execute',
    Stake: 'Stake',
    Merge: 'Merge'
} as const;

export type BrokerCryptocurrencyTransactionBlockchainMethod = typeof BrokerCryptocurrencyTransactionBlockchainMethod[keyof typeof BrokerCryptocurrencyTransactionBlockchainMethod];


/**
 *
 * @export
 * @interface BrokerCryptocurrencyTransactionDetailsRequest
 */
export interface BrokerCryptocurrencyTransactionDetailsRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof BrokerCryptocurrencyTransactionDetailsRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof BrokerCryptocurrencyTransactionDetailsRequest
     */
    'type': BrokerCryptocurrencyTransactionDetailsRequestTypeEnum;
    /**
     * Type of the address of the transferred asset. Can be used instead of the `Symbol` field.
     * @type {CryptocurrencyAddressType}
     * @memberof BrokerCryptocurrencyTransactionDetailsRequest
     */
    'addressType'?: CryptocurrencyAddressType | null;
    /**
     * Transaction Id by the financial institution
     * @type {string}
     * @memberof BrokerCryptocurrencyTransactionDetailsRequest
     */
    'transactionId'?: string | null;
    /**
     * Hash of the transaction on the blockchain
     * @type {string}
     * @memberof BrokerCryptocurrencyTransactionDetailsRequest
     */
    'transactionHash'?: string | null;
    /**
     * Symbol of the transferred asset. Can be provided instead of the `AddressType` field.
     * @type {string}
     * @memberof BrokerCryptocurrencyTransactionDetailsRequest
     */
    'symbol'?: string | null;
}

export const BrokerCryptocurrencyTransactionDetailsRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type BrokerCryptocurrencyTransactionDetailsRequestTypeEnum = typeof BrokerCryptocurrencyTransactionDetailsRequestTypeEnum[keyof typeof BrokerCryptocurrencyTransactionDetailsRequestTypeEnum];

/**
 *
 * @export
 * @interface BrokerCryptocurrencyTransactionFee
 */
export interface BrokerCryptocurrencyTransactionFee {
    /**
     *
     * @type {number}
     * @memberof BrokerCryptocurrencyTransactionFee
     */
    'gasPrice'?: number | null;
    /**
     *
     * @type {number}
     * @memberof BrokerCryptocurrencyTransactionFee
     */
    'gasUsed'?: number | null;
    /**
     *
     * @type {number}
     * @memberof BrokerCryptocurrencyTransactionFee
     */
    'amount'?: number | null;
    /**
     *
     * @type {string}
     * @memberof BrokerCryptocurrencyTransactionFee
     */
    'symbol'?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const BrokerCryptocurrencyTransactionStatus = {
    Unknown: 'Unknown',
    Failed: 'Failed',
    Frozen: 'Frozen',
    Succeeded: 'Succeeded',
    MfaRequired: 'MfaRequired',
    Pending: 'Pending',
    Expired: 'Expired',
    Canceled: 'Canceled',
    WaitingForSignature: 'WaitingForSignature',
    WaitingForClearing: 'WaitingForClearing',
    AwaitingApproval: 'AwaitingApproval',
    AwaitingConfirmation: 'AwaitingConfirmation',
    AwaitingVerification: 'AwaitingVerification',
    Rejected: 'Rejected',
    PendingCancel: 'PendingCancel'
} as const;

export type BrokerCryptocurrencyTransactionStatus = typeof BrokerCryptocurrencyTransactionStatus[keyof typeof BrokerCryptocurrencyTransactionStatus];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerCryptocurrencyTransactionType = {
    Unknown: 'Unknown',
    Deposit: 'Deposit',
    Withdrawal: 'Withdrawal'
} as const;

export type BrokerCryptocurrencyTransactionType = typeof BrokerCryptocurrencyTransactionType[keyof typeof BrokerCryptocurrencyTransactionType];


/**
 *
 * @export
 * @interface BrokerCryptocurrencyWalletListResponse
 */
export interface BrokerCryptocurrencyWalletListResponse {
    /**
     *
     * @type {Array<CryptocurrencyWalletDescription>}
     * @memberof BrokerCryptocurrencyWalletListResponse
     */
    'supportedCryptocurrencyWallets'?: Array<CryptocurrencyWalletDescription> | null;
    /**
     *
     * @type {Array<CryptocurrencyWalletDescription>}
     * @memberof BrokerCryptocurrencyWalletListResponse
     */
    'supportedCryptocurrencyAddresses'?: Array<CryptocurrencyWalletDescription> | null;
}
/**
 *
 * @export
 * @interface BrokerCryptocurrencyWalletListResponseIApiResult
 */
export interface BrokerCryptocurrencyWalletListResponseIApiResult {
    /**
     *
     * @type {BrokerCryptocurrencyWalletListResponse}
     * @memberof BrokerCryptocurrencyWalletListResponseIApiResult
     */
    'content'?: BrokerCryptocurrencyWalletListResponse | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof BrokerCryptocurrencyWalletListResponseIApiResult
     */
    'status'?: BrokerCryptocurrencyWalletListResponseIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof BrokerCryptocurrencyWalletListResponseIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof BrokerCryptocurrencyWalletListResponseIApiResult
     */
    'displayMessage'?: string | null;
}

export const BrokerCryptocurrencyWalletListResponseIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type BrokerCryptocurrencyWalletListResponseIApiResultStatusEnum = typeof BrokerCryptocurrencyWalletListResponseIApiResultStatusEnum[keyof typeof BrokerCryptocurrencyWalletListResponseIApiResultStatusEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const BrokerFeature = {
    Holdings: 'Holdings',
    Balance: 'Balance',
    Orders: 'Orders',
    Transfers: 'Transfers',
    Identity: 'Identity'
} as const;

export type BrokerFeature = typeof BrokerFeature[keyof typeof BrokerFeature];


/**
 *
 * @export
 * @interface BrokerFiatBalance
 */
export interface BrokerFiatBalance {
    /**
     * Account balance currency
     * @type {string}
     * @memberof BrokerFiatBalance
     */
    'symbol'?: string | null;
    /**
     * BuyingPower indicates total amount of money the user can spend for buying stock. Always includes cash and  can also include margin
     * @type {number}
     * @memberof BrokerFiatBalance
     */
    'buyingPower'?: number | null;
    /**
     * BuyingPower indicates total amount of money the user can spend for buying crypto.
     * @type {number}
     * @memberof BrokerFiatBalance
     */
    'cryptoBuyingPower'?: number | null;
    /**
     * Account cash indicates total amount of money
     * @type {number}
     * @memberof BrokerFiatBalance
     */
    'cash'?: number | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const BrokerOptionDirection = {
    Unknown: 'Unknown',
    BuyToOpen: 'BuyToOpen',
    BuyToClose: 'BuyToClose',
    SellToOpen: 'SellToOpen',
    SellToClose: 'SellToClose',
    BuyToCover: 'BuyToCover',
    SellShort: 'SellShort'
} as const;

export type BrokerOptionDirection = typeof BrokerOptionDirection[keyof typeof BrokerOptionDirection];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerOptionType = {
    Unknown: 'Unknown',
    Call: 'Call',
    Put: 'Put'
} as const;

export type BrokerOptionType = typeof BrokerOptionType[keyof typeof BrokerOptionType];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerOrderCategory = {
    Order: 'Order',
    Trade: 'Trade',
    Ledger: 'Ledger',
    HistoryAction: 'HistoryAction'
} as const;

export type BrokerOrderCategory = typeof BrokerOrderCategory[keyof typeof BrokerOrderCategory];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerOrderPlaceType = {
    Unknown: 'Unknown',
    Market: 'Market',
    Limit: 'Limit',
    StopLoss: 'StopLoss',
    StopLimit: 'StopLimit',
    NetDebit: 'NetDebit',
    NetCredit: 'NetCredit',
    Exercise: 'Exercise'
} as const;

export type BrokerOrderPlaceType = typeof BrokerOrderPlaceType[keyof typeof BrokerOrderPlaceType];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerOrderStatus = {
    Unknown: 'Unknown',
    InProgress: 'InProgress',
    Cancelled: 'Cancelled',
    Rejected: 'Rejected',
    Failed: 'Failed',
    Success: 'Success',
    PartiallyFilled: 'PartiallyFilled',
    Expired: 'Expired'
} as const;

export type BrokerOrderStatus = typeof BrokerOrderStatus[keyof typeof BrokerOrderStatus];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerOrderTimeInForceType = {
    GoodTillCanceled: 'GoodTillCanceled',
    ImmediateOrCancel: 'ImmediateOrCancel',
    FillOrKill: 'FillOrKill',
    GoodForDay: 'GoodForDay',
    PostOnly: 'PostOnly'
} as const;

export type BrokerOrderTimeInForceType = typeof BrokerOrderTimeInForceType[keyof typeof BrokerOrderTimeInForceType];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerOrderType = {
    Unknown: 'Unknown',
    Buy: 'Buy',
    Sell: 'Sell'
} as const;

export type BrokerOrderType = typeof BrokerOrderType[keyof typeof BrokerOrderType];


/**
 *
 * @export
 * @enum {string}
 */

export const BrokerOrderValidationStatus = {
    Success: 'Success',
    Failed: 'Failed'
} as const;

export type BrokerOrderValidationStatus = typeof BrokerOrderValidationStatus[keyof typeof BrokerOrderValidationStatus];


/**
 *
 * @export
 * @interface BrokerRefreshTokenRequest
 */
export interface BrokerRefreshTokenRequest {
    /**
     *
     * @type {BrokerType}
     * @memberof BrokerRefreshTokenRequest
     */
    'type': BrokerRefreshTokenRequestTypeEnum;
    /**
     *
     * @type {string}
     * @memberof BrokerRefreshTokenRequest
     */
    'refreshToken': string;
    /**
     * Optional, used when we the refresh token should be refreshed.  Currently this flow is supported by TD Ameritrade
     * @type {boolean}
     * @memberof BrokerRefreshTokenRequest
     */
    'createNewRefreshToken'?: boolean | null;
    /**
     * Some institutions may require accessToken to be provided as well.  It\'s currently required by WeBull only
     * @type {string}
     * @memberof BrokerRefreshTokenRequest
     */
    'accessToken'?: string | null;
    /**
     * Currently used to update WeBull trade token.
     * @type {string}
     * @memberof BrokerRefreshTokenRequest
     */
    'tradeToken'?: string | null;
    /**
     * Additional metadata
     * @type {{ [key: string]: string; }}
     * @memberof BrokerRefreshTokenRequest
     */
    'metadata'?: { [key: string]: string; } | null;
}

export const BrokerRefreshTokenRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type BrokerRefreshTokenRequestTypeEnum = typeof BrokerRefreshTokenRequestTypeEnum[keyof typeof BrokerRefreshTokenRequestTypeEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const BrokerRequestStatus = {
    Succeeded: 'Succeeded',
    Failed: 'Failed',
    NotAuthorized: 'NotAuthorized'
} as const;

export type BrokerRequestStatus = typeof BrokerRequestStatus[keyof typeof BrokerRequestStatus];


/**
 *
 * @export
 * @interface BrokerTransactionsListRequest
 */
export interface BrokerTransactionsListRequest {
    /**
     * Auth token that allows connecting to the target institution
     * @type {string}
     * @memberof BrokerTransactionsListRequest
     */
    'authToken': string;
    /**
     * Type of the institution to connect
     * @type {BrokerType}
     * @memberof BrokerTransactionsListRequest
     */
    'type': BrokerTransactionsListRequestTypeEnum;
    /**
     * Number of records to include in the response. <br />  Default: `100` <br />  Maximum: `250`
     * @type {number}
     * @memberof BrokerTransactionsListRequest
     */
    'count'?: number;
    /**
     * The cursor to retrieve the next page of transactions.  Providing it will cause the response to only return changes after this update.  If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
     * @type {string}
     * @memberof BrokerTransactionsListRequest
     */
    'cursor'?: string | null;
    /**
     * If this value is provided, result set is filtered to only include transaction with the provided statuses.
     * @type {Array<BrokerCryptocurrencyTransactionStatus>}
     * @memberof BrokerTransactionsListRequest
     */
    'statuses'?: Array<BrokerCryptocurrencyTransactionStatus> | null;
    /**
     * For cryptocurrency address the type of address is required.
     * @type {CryptocurrencyAddressType}
     * @memberof BrokerTransactionsListRequest
     */
    'cryptocurrencyAddressType'?: CryptocurrencyAddressType | null;
}

export const BrokerTransactionsListRequestTypeEnum = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type BrokerTransactionsListRequestTypeEnum = typeof BrokerTransactionsListRequestTypeEnum[keyof typeof BrokerTransactionsListRequestTypeEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const BrokerType = {
    Robinhood: 'Robinhood',
    ETrade: 'ETrade',
    Alpaca: 'Alpaca',
    TdAmeritrade: 'TdAmeritrade',
    WeBull: 'WeBull',
    Stash: 'Stash',
    InteractiveBrokers: 'InteractiveBrokers',
    Public: 'Public',
    Coinbase: 'Coinbase',
    Kraken: 'Kraken',
    CoinbasePro: 'CoinbasePro',
    CryptoCom: 'CryptoCom',
    OpenSea: 'OpenSea',
    BinanceUs: 'BinanceUs',
    Gemini: 'Gemini',
    CryptocurrencyAddress: 'CryptocurrencyAddress',
    CryptocurrencyWallet: 'CryptocurrencyWallet',
    OkCoin: 'OkCoin',
    Bittrex: 'Bittrex',
    KuCoin: 'KuCoin',
    Etoro: 'Etoro',
    CexIo: 'CexIo',
    BinanceInternational: 'BinanceInternational',
    Bitstamp: 'Bitstamp',
    GateIo: 'GateIo',
    Celsius: 'Celsius',
    Acorns: 'Acorns',
    Okx: 'Okx',
    BitFlyer: 'BitFlyer',
    Coinlist: 'Coinlist',
    Huobi: 'Huobi',
    Bitfinex: 'Bitfinex'
} as const;

export type BrokerType = typeof BrokerType[keyof typeof BrokerType];


/**
 *
 * @export
 * @interface CatalogLink
 */
export interface CatalogLink {
    /**
     * Url to open Front catalog that should be presented to the end user.
     * @type {string}
     * @memberof CatalogLink
     */
    'url'?: string | null;
}
/**
 *
 * @export
 * @interface CatalogLinkIApiResult
 */
export interface CatalogLinkIApiResult {
    /**
     *
     * @type {CatalogLink}
     * @memberof CatalogLinkIApiResult
     */
    'content'?: CatalogLink | null;
    /**
     *
     * @type {ApiResultStatus}
     * @memberof CatalogLinkIApiResult
     */
    'status'?: CatalogLinkIApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof CatalogLinkIApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CatalogLinkIApiResult
     */
    'displayMessage'?: string | null;
}

export const CatalogLinkIApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type CatalogLinkIApiResultStatusEnum = typeof CatalogLinkIApiResultStatusEnum[keyof typeof CatalogLinkIApiResultStatusEnum];

/**
 *
 * @export
 * @interface ChartItem
 */
export interface ChartItem {
    /**
     *
     * @type {number}
     * @memberof ChartItem
     */
    'value'?: number;
    /**
     *
     * @type {string}
     * @memberof ChartItem
     */
    'date'?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const CryptocurrencyAddressType = {
    EthAddress: 'EthAddress',
    BtcAddress: 'BtcAddress',
    LtcAddress: 'LtcAddress',
    SolAddress: 'SolAddress',
    AlgoAddress: 'AlgoAddress',
    CeloAddress: 'CeloAddress',
    CardanoAddress: 'CardanoAddress',
    PolygonAddress: 'PolygonAddress',
    BnbAddress: 'BnbAddress',
    ElrondAddress: 'ElrondAddress',
    NeoAddress: 'NeoAddress',
    XrpAddress: 'XrpAddress',
    FlowAddress: 'FlowAddress',
    HarmonyOneAddress: 'HarmonyOneAddress',
    TronAddress: 'TronAddress',
    DogeAddress: 'DogeAddress'
} as const;

export type CryptocurrencyAddressType = typeof CryptocurrencyAddressType[keyof typeof CryptocurrencyAddressType];


/**
 *
 * @export
 * @interface CryptocurrencyCoinDescription
 */
export interface CryptocurrencyCoinDescription {
    /**
     *
     * @type {string}
     * @memberof CryptocurrencyCoinDescription
     */
    'symbol'?: string | null;
    /**
     *
     * @type {string}
     * @memberof CryptocurrencyCoinDescription
     */
    'name'?: string | null;
}
/**
 *
 * @export
 * @interface CryptocurrencyWalletDescription
 */
export interface CryptocurrencyWalletDescription {
    /**
     *
     * @type {CryptocurrencyWalletType}
     * @memberof CryptocurrencyWalletDescription
     */
    'cryptocurrencyWalletType'?: CryptocurrencyWalletType | null;
    /**
     *
     * @type {CryptocurrencyAddressType}
     * @memberof CryptocurrencyWalletDescription
     */
    'cryptocurrencyAddressType'?: CryptocurrencyAddressType | null;
    /**
     *
     * @type {Array<CryptocurrencyCoinDescription>}
     * @memberof CryptocurrencyWalletDescription
     */
    'supportedCryptocurrencies'?: Array<CryptocurrencyCoinDescription> | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const CryptocurrencyWalletType = {
    CoinbaseWallet: 'CoinbaseWallet',
    Metamask: 'Metamask',
    TrustWallet: 'TrustWallet',
    MyEtherWallet: 'MyEtherWallet',
    AlphaWallet: 'AlphaWallet',
    AtomicWallet: 'AtomicWallet'
} as const;

export type CryptocurrencyWalletType = typeof CryptocurrencyWalletType[keyof typeof CryptocurrencyWalletType];


/**
 *
 * @export
 * @enum {string}
 */

export const FiscoIngredientScoreEnum = {
    VeryPoor: 'VeryPoor',
    Poor: 'Poor',
    Fair: 'Fair',
    Good: 'Good',
    Exceptional: 'Exceptional'
} as const;

export type FiscoIngredientScoreEnum = typeof FiscoIngredientScoreEnum[keyof typeof FiscoIngredientScoreEnum];


/**
 *
 * @export
 * @interface IApiResult
 */
export interface IApiResult {
    /**
     *
     * @type {ApiResultStatus}
     * @memberof IApiResult
     */
    'status'?: IApiResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof IApiResult
     */
    'message'?: string | null;
    /**
     *
     * @type {string}
     * @memberof IApiResult
     */
    'displayMessage'?: string | null;
}

export const IApiResultStatusEnum = {
    Ok: 'Ok',
    ServerFailure: 'ServerFailure',
    PermissionDenied: 'PermissionDenied',
    BadRequest: 'BadRequest',
    NotFound: 'NotFound',
    Conflict: 'Conflict',
    TooManyRequest: 'TooManyRequest'
} as const;

export type IApiResultStatusEnum = typeof IApiResultStatusEnum[keyof typeof IApiResultStatusEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const MfaScheme = {
    MfaCode: 'MfaCode',
    Challenge: 'Challenge',
    SecurityQuestion: 'SecurityQuestion'
} as const;

export type MfaScheme = typeof MfaScheme[keyof typeof MfaScheme];


/**
 *
 * @export
 * @enum {string}
 */

export const NftBlockchain = {
    Ethereum: 'Ethereum',
    Polygon: 'Polygon',
    Klaytn: 'Klaytn'
} as const;

export type NftBlockchain = typeof NftBlockchain[keyof typeof NftBlockchain];


/**
 *
 * @export
 * @interface NftOrder
 */
export interface NftOrder {
    /**
     *
     * @type {NftOrderSide}
     * @memberof NftOrder
     */
    'orderSide'?: NftOrderOrderSideEnum;
    /**
     *
     * @type {string}
     * @memberof NftOrder
     */
    'symbol'?: string | null;
    /**
     *
     * @type {number}
     * @memberof NftOrder
     */
    'price'?: number;
    /**
     *
     * @type {number}
     * @memberof NftOrder
     */
    'priceUsd'?: number | null;
    /**
     *
     * @type {number}
     * @memberof NftOrder
     */
    'amount'?: number;
    /**
     *
     * @type {number}
     * @memberof NftOrder
     */
    'createdTimestamp'?: number | null;
    /**
     *
     * @type {number}
     * @memberof NftOrder
     */
    'updatedTimestamp'?: number | null;
    /**
     *
     * @type {string}
     * @memberof NftOrder
     */
    'symbolLogo'?: string | null;
}

export const NftOrderOrderSideEnum = {
    Buy: 'Buy',
    Sell: 'Sell'
} as const;

export type NftOrderOrderSideEnum = typeof NftOrderOrderSideEnum[keyof typeof NftOrderOrderSideEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const NftOrderSide = {
    Buy: 'Buy',
    Sell: 'Sell'
} as const;

export type NftOrderSide = typeof NftOrderSide[keyof typeof NftOrderSide];


/**
 *
 * @export
 * @interface NftPositionWithMarketValues
 */
export interface NftPositionWithMarketValues {
    /**
     *
     * @type {number}
     * @memberof NftPositionWithMarketValues
     */
    'amount'?: number;
    /**
     *
     * @type {number}
     * @memberof NftPositionWithMarketValues
     */
    'costBasis'?: number | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'contractAddress'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'paymentTokenSymbol'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'name'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'description'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'imageUrl'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'imageOriginalUrl'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'animationUrl'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'backgroundColor'?: string | null;
    /**
     *
     * @type {number}
     * @memberof NftPositionWithMarketValues
     */
    'marketplaceId'?: number;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'tokenId'?: string | null;
    /**
     *
     * @type {number}
     * @memberof NftPositionWithMarketValues
     */
    'numberOfSales'?: number | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'contractType'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'contractName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'contractSchemaName'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'contractSymbol'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'contractDescription'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'marketplacePermalink'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'contractExternalLink'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'creatorAddress'?: string | null;
    /**
     *
     * @type {NftOrder}
     * @memberof NftPositionWithMarketValues
     */
    'currentOffer'?: NftOrder | null;
    /**
     *
     * @type {NftOrder}
     * @memberof NftPositionWithMarketValues
     */
    'lastSale'?: NftOrder | null;
    /**
     *
     * @type {NftBlockchain}
     * @memberof NftPositionWithMarketValues
     */
    'blockchain'?: NftPositionWithMarketValuesBlockchainEnum;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'addressExplorerLink'?: string | null;
    /**
     *
     * @type {string}
     * @memberof NftPositionWithMarketValues
     */
    'twitterUsername'?: string | null;
    /**
     * Amount of NFTs multiplied by NFT value
     * @type {number}
     * @memberof NftPositionWithMarketValues
     */
    'marketValue'?: number | null;
    /**
     * What percentage of total portfolio value is taken by this NFT
     * @type {number}
     * @memberof NftPositionWithMarketValues
     */
    'portfolioPercentage'?: number | null;
}

export const NftPositionWithMarketValuesBlockchainEnum = {
    Ethereum: 'Ethereum',
    Polygon: 'Polygon',
    Klaytn: 'Klaytn'
} as const;

export type NftPositionWithMarketValuesBlockchainEnum = typeof NftPositionWithMarketValuesBlockchainEnum[keyof typeof NftPositionWithMarketValuesBlockchainEnum];

/**
 *
 * @export
 * @interface ProblemDetails
 */
export interface ProblemDetails {
    [key: string]: any;

    /**
     *
     * @type {string}
     * @memberof ProblemDetails
     */
    'type'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ProblemDetails
     */
    'title'?: string | null;
    /**
     *
     * @type {number}
     * @memberof ProblemDetails
     */
    'status'?: number | null;
    /**
     *
     * @type {string}
     * @memberof ProblemDetails
     */
    'detail'?: string | null;
    /**
     *
     * @type {string}
     * @memberof ProblemDetails
     */
    'instance'?: string | null;
}
/**
 *
 * @export
 * @enum {string}
 */

export const SymbolTradingAllowance = {
    FractionalTradingAllowed: 'FractionalTradingAllowed',
    FractionalTradingNotAllowed: 'FractionalTradingNotAllowed',
    TradingNotAllowed: 'TradingNotAllowed',
    FractionalTradingPossiblyAllowed: 'FractionalTradingPossiblyAllowed'
} as const;

export type SymbolTradingAllowance = typeof SymbolTradingAllowance[keyof typeof SymbolTradingAllowance];



/**
 * BalanceApi - axios parameter creator
 * @export
 */
export const BalanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get real-time account fiat balances.
         * @summary Get account balance
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1BalanceGetPostRequest} [apiV1BalanceGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BalanceGetPost: async (xClientId: string, xClientSecret: string, apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1BalanceGetPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1BalanceGetPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/balance/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1BalanceGetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get cached aggregated fiat balances from all connected integrations.
         * @summary Get aggregated portfolio fiat balances
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {string} [userId] End user ID to get the aggregated portfolio for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BalancePortfolioGet: async (xClientId: string, xClientSecret: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1BalancePortfolioGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1BalancePortfolioGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/balance/portfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BalanceApi - functional programming interface
 * @export
 */
export const BalanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BalanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get real-time account fiat balances.
         * @summary Get account balance
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1BalanceGetPostRequest} [apiV1BalanceGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BalanceGetPost(xClientId: string, xClientSecret: string, apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerAccountBalanceModelIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BalanceGetPost(xClientId, xClientSecret, apiV1BalanceGetPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get cached aggregated fiat balances from all connected integrations.
         * @summary Get aggregated portfolio fiat balances
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {string} [userId] End user ID to get the aggregated portfolio for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1BalancePortfolioGet(xClientId: string, xClientSecret: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BPortfolioModelIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1BalancePortfolioGet(xClientId, xClientSecret, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BalanceApi - factory interface
 * @export
 */
export const BalanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BalanceApiFp(configuration)
    return {
        /**
         * Get real-time account fiat balances.
         * @summary Get account balance
         * @param {BalanceApiApiV1BalanceGetPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BalanceGetPost(requestParameters: BalanceApiApiV1BalanceGetPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerAccountBalanceModelIApiResult> {
            return localVarFp.apiV1BalanceGetPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1BalanceGetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get cached aggregated fiat balances from all connected integrations.
         * @summary Get aggregated portfolio fiat balances
         * @param {BalanceApiApiV1BalancePortfolioGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BalancePortfolioGet(requestParameters: BalanceApiApiV1BalancePortfolioGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BPortfolioModelIApiResult> {
            return localVarFp.apiV1BalancePortfolioGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1BalanceGetPost operation in BalanceApi.
 * @export
 * @interface BalanceApiApiV1BalanceGetPostRequest
 */
export interface BalanceApiApiV1BalanceGetPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof BalanceApiApiV1BalanceGetPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof BalanceApiApiV1BalanceGetPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1BalanceGetPostRequest}
     * @memberof BalanceApiApiV1BalanceGetPost
     */
    readonly apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest
}

/**
 * Request parameters for apiV1BalancePortfolioGet operation in BalanceApi.
 * @export
 * @interface BalanceApiApiV1BalancePortfolioGetRequest
 */
export interface BalanceApiApiV1BalancePortfolioGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof BalanceApiApiV1BalancePortfolioGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof BalanceApiApiV1BalancePortfolioGet
     */
    readonly xClientSecret: string

    /**
     * End user ID to get the aggregated portfolio for.
     * @type {string}
     * @memberof BalanceApiApiV1BalancePortfolioGet
     */
    readonly userId?: string
}

/**
 * BalanceApi - object-oriented interface
 * @export
 * @class BalanceApi
 * @extends {BaseAPI}
 */
export class BalanceApi extends BaseAPI {
    /**
     * Get real-time account fiat balances.
     * @summary Get account balance
     * @param {BalanceApiApiV1BalanceGetPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public apiV1BalanceGetPost(requestParameters: BalanceApiApiV1BalanceGetPostRequest, options?: AxiosRequestConfig) {
        return BalanceApiFp(this.configuration).apiV1BalanceGetPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1BalanceGetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get cached aggregated fiat balances from all connected integrations.
     * @summary Get aggregated portfolio fiat balances
     * @param {BalanceApiApiV1BalancePortfolioGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BalanceApi
     */
    public apiV1BalancePortfolioGet(requestParameters: BalanceApiApiV1BalancePortfolioGetRequest, options?: AxiosRequestConfig) {
        return BalanceApiFp(this.configuration).apiV1BalancePortfolioGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FrontScoreApi - axios parameter creator
 * @export
 */
export const FrontScoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get cryptocurrency health measurement.
         * @summary Get cryptocurrency Front Score
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {Array<string>} [symbols] List of cryptocurrency symbols to get Front Score for
         * @param {string} [userId] Optional end user id for compatibility score
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FrontscoreCryptocurrencyGet: async (xClientId: string, xClientSecret: string, symbols?: Array<string>, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1FrontscoreCryptocurrencyGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1FrontscoreCryptocurrencyGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/frontscore/cryptocurrency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (symbols) {
                localVarQueryParameter['Symbols'] = symbols;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get equity health measurement.
         * @summary Get stock Front Score
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {Array<string>} [symbols] List of equity symbols to get Front Score for
         * @param {string} [userId] Optional end user id for compatibility score
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FrontscoreEquityGet: async (xClientId: string, xClientSecret: string, symbols?: Array<string>, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1FrontscoreEquityGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1FrontscoreEquityGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/frontscore/equity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (symbols) {
                localVarQueryParameter['Symbols'] = symbols;
            }

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get portfolio health measurement.
         * @summary Get portfolio Front Score
         * @param {string} userId Id of the end user to get the Front Score of the aggregated portfolio for.
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FrontscoreGetGet: async (userId: string, xClientId: string, xClientSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiV1FrontscoreGetGet', 'userId', userId)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1FrontscoreGetGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1FrontscoreGetGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/frontscore/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FrontScoreApi - functional programming interface
 * @export
 */
export const FrontScoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FrontScoreApiAxiosParamCreator(configuration)
    return {
        /**
         * Get cryptocurrency health measurement.
         * @summary Get cryptocurrency Front Score
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {Array<string>} [symbols] List of cryptocurrency symbols to get Front Score for
         * @param {string} [userId] Optional end user id for compatibility score
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FrontscoreCryptocurrencyGet(xClientId: string, xClientSecret: string, symbols?: Array<string>, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1FrontscoreCryptocurrencyGet(xClientId, xClientSecret, symbols, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get equity health measurement.
         * @summary Get stock Front Score
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {Array<string>} [symbols] List of equity symbols to get Front Score for
         * @param {string} [userId] Optional end user id for compatibility score
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FrontscoreEquityGet(xClientId: string, xClientSecret: string, symbols?: Array<string>, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BStockFiscoIReadOnlyCollectionIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1FrontscoreEquityGet(xClientId, xClientSecret, symbols, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get portfolio health measurement.
         * @summary Get portfolio Front Score
         * @param {string} userId Id of the end user to get the Front Score of the aggregated portfolio for.
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1FrontscoreGetGet(userId: string, xClientId: string, xClientSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BPortfolioFiscoIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1FrontscoreGetGet(userId, xClientId, xClientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FrontScoreApi - factory interface
 * @export
 */
export const FrontScoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FrontScoreApiFp(configuration)
    return {
        /**
         * Get cryptocurrency health measurement.
         * @summary Get cryptocurrency Front Score
         * @param {FrontScoreApiApiV1FrontscoreCryptocurrencyGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FrontscoreCryptocurrencyGet(requestParameters: FrontScoreApiApiV1FrontscoreCryptocurrencyGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BCryptocurrencyFiscoIReadOnlyCollectionIApiResult> {
            return localVarFp.apiV1FrontscoreCryptocurrencyGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.symbols, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get equity health measurement.
         * @summary Get stock Front Score
         * @param {FrontScoreApiApiV1FrontscoreEquityGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FrontscoreEquityGet(requestParameters: FrontScoreApiApiV1FrontscoreEquityGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BStockFiscoIReadOnlyCollectionIApiResult> {
            return localVarFp.apiV1FrontscoreEquityGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.symbols, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get portfolio health measurement.
         * @summary Get portfolio Front Score
         * @param {FrontScoreApiApiV1FrontscoreGetGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1FrontscoreGetGet(requestParameters: FrontScoreApiApiV1FrontscoreGetGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BPortfolioFiscoIApiResult> {
            return localVarFp.apiV1FrontscoreGetGet(requestParameters.userId, requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1FrontscoreCryptocurrencyGet operation in FrontScoreApi.
 * @export
 * @interface FrontScoreApiApiV1FrontscoreCryptocurrencyGetRequest
 */
export interface FrontScoreApiApiV1FrontscoreCryptocurrencyGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreCryptocurrencyGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreCryptocurrencyGet
     */
    readonly xClientSecret: string

    /**
     * List of cryptocurrency symbols to get Front Score for
     * @type {Array<string>}
     * @memberof FrontScoreApiApiV1FrontscoreCryptocurrencyGet
     */
    readonly symbols?: Array<string>

    /**
     * Optional end user id for compatibility score
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreCryptocurrencyGet
     */
    readonly userId?: string
}

/**
 * Request parameters for apiV1FrontscoreEquityGet operation in FrontScoreApi.
 * @export
 * @interface FrontScoreApiApiV1FrontscoreEquityGetRequest
 */
export interface FrontScoreApiApiV1FrontscoreEquityGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreEquityGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreEquityGet
     */
    readonly xClientSecret: string

    /**
     * List of equity symbols to get Front Score for
     * @type {Array<string>}
     * @memberof FrontScoreApiApiV1FrontscoreEquityGet
     */
    readonly symbols?: Array<string>

    /**
     * Optional end user id for compatibility score
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreEquityGet
     */
    readonly userId?: string
}

/**
 * Request parameters for apiV1FrontscoreGetGet operation in FrontScoreApi.
 * @export
 * @interface FrontScoreApiApiV1FrontscoreGetGetRequest
 */
export interface FrontScoreApiApiV1FrontscoreGetGetRequest {
    /**
     * Id of the end user to get the Front Score of the aggregated portfolio for.
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreGetGet
     */
    readonly userId: string

    /**
     * Id of the client
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreGetGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof FrontScoreApiApiV1FrontscoreGetGet
     */
    readonly xClientSecret: string
}

/**
 * FrontScoreApi - object-oriented interface
 * @export
 * @class FrontScoreApi
 * @extends {BaseAPI}
 */
export class FrontScoreApi extends BaseAPI {
    /**
     * Get cryptocurrency health measurement.
     * @summary Get cryptocurrency Front Score
     * @param {FrontScoreApiApiV1FrontscoreCryptocurrencyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontScoreApi
     */
    public apiV1FrontscoreCryptocurrencyGet(requestParameters: FrontScoreApiApiV1FrontscoreCryptocurrencyGetRequest, options?: AxiosRequestConfig) {
        return FrontScoreApiFp(this.configuration).apiV1FrontscoreCryptocurrencyGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.symbols, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get equity health measurement.
     * @summary Get stock Front Score
     * @param {FrontScoreApiApiV1FrontscoreEquityGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontScoreApi
     */
    public apiV1FrontscoreEquityGet(requestParameters: FrontScoreApiApiV1FrontscoreEquityGetRequest, options?: AxiosRequestConfig) {
        return FrontScoreApiFp(this.configuration).apiV1FrontscoreEquityGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.symbols, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get portfolio health measurement.
     * @summary Get portfolio Front Score
     * @param {FrontScoreApiApiV1FrontscoreGetGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrontScoreApi
     */
    public apiV1FrontscoreGetGet(requestParameters: FrontScoreApiApiV1FrontscoreGetGetRequest, options?: AxiosRequestConfig) {
        return FrontScoreApiFp(this.configuration).apiV1FrontscoreGetGet(requestParameters.userId, requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Remove connection to the financial institution and erase all related data completely.
         * @summary Remove connection
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1BalanceGetPostRequest} [apiV1BalanceGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountDelete: async (xClientId: string, xClientSecret: string, apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1AccountDelete', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1AccountDelete', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1BalanceGetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType
         * @summary Get OAuth authentication link
         * @param {'Robinhood' | 'ETrade' | 'Alpaca' | 'TdAmeritrade' | 'WeBull' | 'Stash' | 'InteractiveBrokers' | 'Public' | 'Coinbase' | 'Kraken' | 'CoinbasePro' | 'CryptoCom' | 'OpenSea' | 'BinanceUs' | 'Gemini' | 'CryptocurrencyAddress' | 'CryptocurrencyWallet' | 'OkCoin' | 'Bittrex' | 'KuCoin' | 'Etoro' | 'CexIo' | 'BinanceInternational' | 'Bitstamp' | 'GateIo' | 'Celsius' | 'Acorns' | 'Okx' | 'BitFlyer' | 'Coinlist' | 'Huobi' | 'Bitfinex'} brokerType Type of the integration to connect
         * @param {string} userId Id of the end-user
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthenticateBrokerTypeGet: async (brokerType: 'Robinhood' | 'ETrade' | 'Alpaca' | 'TdAmeritrade' | 'WeBull' | 'Stash' | 'InteractiveBrokers' | 'Public' | 'Coinbase' | 'Kraken' | 'CoinbasePro' | 'CryptoCom' | 'OpenSea' | 'BinanceUs' | 'Gemini' | 'CryptocurrencyAddress' | 'CryptocurrencyWallet' | 'OkCoin' | 'Bittrex' | 'KuCoin' | 'Etoro' | 'CexIo' | 'BinanceInternational' | 'Bitstamp' | 'GateIo' | 'Celsius' | 'Acorns' | 'Okx' | 'BitFlyer' | 'Coinlist' | 'Huobi' | 'Bitfinex', userId: string, xClientId: string, xClientSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brokerType' is not null or undefined
            assertParamExists('apiV1AuthenticateBrokerTypeGet', 'brokerType', brokerType)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiV1AuthenticateBrokerTypeGet', 'userId', userId)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1AuthenticateBrokerTypeGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1AuthenticateBrokerTypeGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/authenticate/{brokerType}`
                .replace(`{${"brokerType"}}`, encodeURIComponent(String(brokerType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate user\'s brokerage/exchange account programmatically (not using the Web Catalog UI)
         * @summary Authenticate user\'s account
         * @param {string} userId Id of the end-user
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1AuthenticatePostRequest} [apiV1AuthenticatePostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthenticatePost: async (userId: string, xClientId: string, xClientSecret: string, apiV1AuthenticatePostRequest?: ApiV1AuthenticatePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('apiV1AuthenticatePost', 'userId', userId)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1AuthenticatePost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1AuthenticatePost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1AuthenticatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get authentication schemes of available integrations to perform authentication programmatically (not using  the Web Catalog UI).
         * @summary Get authentication schemes
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthenticationSchemesGet: async (xClientId: string, xClientSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1AuthenticationSchemesGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1AuthenticationSchemesGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/authenticationSchemes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get personalized catalog link for client
         * @summary Get catalog link
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {string} [userId] A unique Id representing the end user. Typically this will be a user Id from the              client application. Personally identifiable information, such as an email address or phone number,              should not be used.
         * @param {BrokerType} [brokerType] Type of broker to redirect to. Will redirect to catalog if not provided.
         * @param {string} [callbackUrl] Callback link - url to redirect user after authentication in brokerage account.  If not provided default client\&#39;s url will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CataloglinkGet: async (xClientId: string, xClientSecret: string, userId?: string, brokerType?: BrokerType, callbackUrl?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1CataloglinkGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1CataloglinkGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/cataloglink`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (brokerType !== undefined) {
                localVarQueryParameter['brokerType'] = brokerType;
            }

            if (callbackUrl !== undefined) {
                localVarQueryParameter['callbackUrl'] = callbackUrl;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supported cryptocurrency wallets and cryptocurrency addresses to perform authentication programmatically (not using  the Web Catalog UI).
         * @summary Get supported wallets
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CryptocurrencyWalletsGet: async (xClientId: string, xClientSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1CryptocurrencyWalletsGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1CryptocurrencyWalletsGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/cryptocurrencyWallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of supported institutions and their health statuses.
         * @summary Get health status
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StatusGet: async (xClientId: string, xClientSecret: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1StatusGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1StatusGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh auth token of the connected institution.  Some institutions do not require tokens to be refreshed.                The following institutions require custom flows:                WeBull: AuthToken should be provided along with the RefreshToken                TdAmeritrade: refresh token should also be refreshed.  CreateNewRefreshToken parameter should be set to true in order  to refresh the refresh token for TdAmeritrade.
         * @summary Refresh auth token
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TokenRefreshPostRequest} [apiV1TokenRefreshPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokenRefreshPost: async (xClientId: string, xClientSecret: string, apiV1TokenRefreshPostRequest?: ApiV1TokenRefreshPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TokenRefreshPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TokenRefreshPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TokenRefreshPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Remove connection to the financial institution and erase all related data completely.
         * @summary Remove connection
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1BalanceGetPostRequest} [apiV1BalanceGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AccountDelete(xClientId: string, xClientSecret: string, apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AccountDelete(xClientId, xClientSecret, apiV1BalanceGetPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType
         * @summary Get OAuth authentication link
         * @param {'Robinhood' | 'ETrade' | 'Alpaca' | 'TdAmeritrade' | 'WeBull' | 'Stash' | 'InteractiveBrokers' | 'Public' | 'Coinbase' | 'Kraken' | 'CoinbasePro' | 'CryptoCom' | 'OpenSea' | 'BinanceUs' | 'Gemini' | 'CryptocurrencyAddress' | 'CryptocurrencyWallet' | 'OkCoin' | 'Bittrex' | 'KuCoin' | 'Etoro' | 'CexIo' | 'BinanceInternational' | 'Bitstamp' | 'GateIo' | 'Celsius' | 'Acorns' | 'Okx' | 'BitFlyer' | 'Coinlist' | 'Huobi' | 'Bitfinex'} brokerType Type of the integration to connect
         * @param {string} userId Id of the end-user
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthenticateBrokerTypeGet(brokerType: 'Robinhood' | 'ETrade' | 'Alpaca' | 'TdAmeritrade' | 'WeBull' | 'Stash' | 'InteractiveBrokers' | 'Public' | 'Coinbase' | 'Kraken' | 'CoinbasePro' | 'CryptoCom' | 'OpenSea' | 'BinanceUs' | 'Gemini' | 'CryptocurrencyAddress' | 'CryptocurrencyWallet' | 'OkCoin' | 'Bittrex' | 'KuCoin' | 'Etoro' | 'CexIo' | 'BinanceInternational' | 'Bitstamp' | 'GateIo' | 'Celsius' | 'Acorns' | 'Okx' | 'BitFlyer' | 'Coinlist' | 'Huobi' | 'Bitfinex', userId: string, xClientId: string, xClientSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerAuthPromptResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthenticateBrokerTypeGet(brokerType, userId, xClientId, xClientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Authenticate user\'s brokerage/exchange account programmatically (not using the Web Catalog UI)
         * @summary Authenticate user\'s account
         * @param {string} userId Id of the end-user
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1AuthenticatePostRequest} [apiV1AuthenticatePostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthenticatePost(userId: string, xClientId: string, xClientSecret: string, apiV1AuthenticatePostRequest?: ApiV1AuthenticatePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerAuthResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthenticatePost(userId, xClientId, xClientSecret, apiV1AuthenticatePostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get authentication schemes of available integrations to perform authentication programmatically (not using  the Web Catalog UI).
         * @summary Get authentication schemes
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1AuthenticationSchemesGet(xClientId: string, xClientSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1AuthenticationSchemesGet(xClientId, xClientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get personalized catalog link for client
         * @summary Get catalog link
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {string} [userId] A unique Id representing the end user. Typically this will be a user Id from the              client application. Personally identifiable information, such as an email address or phone number,              should not be used.
         * @param {BrokerType} [brokerType] Type of broker to redirect to. Will redirect to catalog if not provided.
         * @param {string} [callbackUrl] Callback link - url to redirect user after authentication in brokerage account.  If not provided default client\&#39;s url will be used.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CataloglinkGet(xClientId: string, xClientSecret: string, userId?: string, brokerType?: BrokerType, callbackUrl?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogLinkIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CataloglinkGet(xClientId, xClientSecret, userId, brokerType, callbackUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supported cryptocurrency wallets and cryptocurrency addresses to perform authentication programmatically (not using  the Web Catalog UI).
         * @summary Get supported wallets
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1CryptocurrencyWalletsGet(xClientId: string, xClientSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BrokerCryptocurrencyWalletListResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1CryptocurrencyWalletsGet(xClientId, xClientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the list of supported institutions and their health statuses.
         * @summary Get health status
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StatusGet(xClientId: string, xClientSecret: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokersHealthStatusListIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StatusGet(xClientId, xClientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh auth token of the connected institution.  Some institutions do not require tokens to be refreshed.                The following institutions require custom flows:                WeBull: AuthToken should be provided along with the RefreshToken                TdAmeritrade: refresh token should also be refreshed.  CreateNewRefreshToken parameter should be set to true in order  to refresh the refresh token for TdAmeritrade.
         * @summary Refresh auth token
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TokenRefreshPostRequest} [apiV1TokenRefreshPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TokenRefreshPost(xClientId: string, xClientSecret: string, apiV1TokenRefreshPostRequest?: ApiV1TokenRefreshPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerRefreshTokenResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TokenRefreshPost(xClientId, xClientSecret, apiV1TokenRefreshPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * Remove connection to the financial institution and erase all related data completely.
         * @summary Remove connection
         * @param {IntegrationsApiApiV1AccountDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AccountDelete(requestParameters: IntegrationsApiApiV1AccountDeleteRequest, options?: AxiosRequestConfig): AxiosPromise<IApiResult> {
            return localVarFp.apiV1AccountDelete(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1BalanceGetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType
         * @summary Get OAuth authentication link
         * @param {IntegrationsApiApiV1AuthenticateBrokerTypeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthenticateBrokerTypeGet(requestParameters: IntegrationsApiApiV1AuthenticateBrokerTypeGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerAuthPromptResponseIApiResult> {
            return localVarFp.apiV1AuthenticateBrokerTypeGet(requestParameters.brokerType, requestParameters.userId, requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate user\'s brokerage/exchange account programmatically (not using the Web Catalog UI)
         * @summary Authenticate user\'s account
         * @param {IntegrationsApiApiV1AuthenticatePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthenticatePost(requestParameters: IntegrationsApiApiV1AuthenticatePostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerAuthResponseIApiResult> {
            return localVarFp.apiV1AuthenticatePost(requestParameters.userId, requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1AuthenticatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get authentication schemes of available integrations to perform authentication programmatically (not using  the Web Catalog UI).
         * @summary Get authentication schemes
         * @param {IntegrationsApiApiV1AuthenticationSchemesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1AuthenticationSchemesGet(requestParameters: IntegrationsApiApiV1AuthenticationSchemesGetRequest, options?: AxiosRequestConfig): AxiosPromise<BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult> {
            return localVarFp.apiV1AuthenticationSchemesGet(requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Get personalized catalog link for client
         * @summary Get catalog link
         * @param {IntegrationsApiApiV1CataloglinkGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CataloglinkGet(requestParameters: IntegrationsApiApiV1CataloglinkGetRequest, options?: AxiosRequestConfig): AxiosPromise<CatalogLinkIApiResult> {
            return localVarFp.apiV1CataloglinkGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.userId, requestParameters.brokerType, requestParameters.callbackUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supported cryptocurrency wallets and cryptocurrency addresses to perform authentication programmatically (not using  the Web Catalog UI).
         * @summary Get supported wallets
         * @param {IntegrationsApiApiV1CryptocurrencyWalletsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CryptocurrencyWalletsGet(requestParameters: IntegrationsApiApiV1CryptocurrencyWalletsGetRequest, options?: AxiosRequestConfig): AxiosPromise<BrokerCryptocurrencyWalletListResponseIApiResult> {
            return localVarFp.apiV1CryptocurrencyWalletsGet(requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of supported institutions and their health statuses.
         * @summary Get health status
         * @param {IntegrationsApiApiV1StatusGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StatusGet(requestParameters: IntegrationsApiApiV1StatusGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokersHealthStatusListIApiResult> {
            return localVarFp.apiV1StatusGet(requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh auth token of the connected institution.  Some institutions do not require tokens to be refreshed.                The following institutions require custom flows:                WeBull: AuthToken should be provided along with the RefreshToken                TdAmeritrade: refresh token should also be refreshed.  CreateNewRefreshToken parameter should be set to true in order  to refresh the refresh token for TdAmeritrade.
         * @summary Refresh auth token
         * @param {IntegrationsApiApiV1TokenRefreshPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokenRefreshPost(requestParameters: IntegrationsApiApiV1TokenRefreshPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerRefreshTokenResponseIApiResult> {
            return localVarFp.apiV1TokenRefreshPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TokenRefreshPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1AccountDelete operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiApiV1AccountDeleteRequest
 */
export interface IntegrationsApiApiV1AccountDeleteRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof IntegrationsApiApiV1AccountDelete
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof IntegrationsApiApiV1AccountDelete
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1BalanceGetPostRequest}
     * @memberof IntegrationsApiApiV1AccountDelete
     */
    readonly apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest
}

/**
 * Request parameters for apiV1AuthenticateBrokerTypeGet operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiApiV1AuthenticateBrokerTypeGetRequest
 */
export interface IntegrationsApiApiV1AuthenticateBrokerTypeGetRequest {
    /**
     * Type of the integration to connect
     * @type {'Robinhood' | 'ETrade' | 'Alpaca' | 'TdAmeritrade' | 'WeBull' | 'Stash' | 'InteractiveBrokers' | 'Public' | 'Coinbase' | 'Kraken' | 'CoinbasePro' | 'CryptoCom' | 'OpenSea' | 'BinanceUs' | 'Gemini' | 'CryptocurrencyAddress' | 'CryptocurrencyWallet' | 'OkCoin' | 'Bittrex' | 'KuCoin' | 'Etoro' | 'CexIo' | 'BinanceInternational' | 'Bitstamp' | 'GateIo' | 'Celsius' | 'Acorns' | 'Okx' | 'BitFlyer' | 'Coinlist' | 'Huobi' | 'Bitfinex'}
     * @memberof IntegrationsApiApiV1AuthenticateBrokerTypeGet
     */
    readonly brokerType: 'Robinhood' | 'ETrade' | 'Alpaca' | 'TdAmeritrade' | 'WeBull' | 'Stash' | 'InteractiveBrokers' | 'Public' | 'Coinbase' | 'Kraken' | 'CoinbasePro' | 'CryptoCom' | 'OpenSea' | 'BinanceUs' | 'Gemini' | 'CryptocurrencyAddress' | 'CryptocurrencyWallet' | 'OkCoin' | 'Bittrex' | 'KuCoin' | 'Etoro' | 'CexIo' | 'BinanceInternational' | 'Bitstamp' | 'GateIo' | 'Celsius' | 'Acorns' | 'Okx' | 'BitFlyer' | 'Coinlist' | 'Huobi' | 'Bitfinex'

    /**
     * Id of the end-user
     * @type {string}
     * @memberof IntegrationsApiApiV1AuthenticateBrokerTypeGet
     */
    readonly userId: string

    /**
     * Id of the client
     * @type {string}
     * @memberof IntegrationsApiApiV1AuthenticateBrokerTypeGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof IntegrationsApiApiV1AuthenticateBrokerTypeGet
     */
    readonly xClientSecret: string
}

/**
 * Request parameters for apiV1AuthenticatePost operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiApiV1AuthenticatePostRequest
 */
export interface IntegrationsApiApiV1AuthenticatePostRequest {
    /**
     * Id of the end-user
     * @type {string}
     * @memberof IntegrationsApiApiV1AuthenticatePost
     */
    readonly userId: string

    /**
     * Id of the client
     * @type {string}
     * @memberof IntegrationsApiApiV1AuthenticatePost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof IntegrationsApiApiV1AuthenticatePost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1AuthenticatePostRequest}
     * @memberof IntegrationsApiApiV1AuthenticatePost
     */
    readonly apiV1AuthenticatePostRequest?: ApiV1AuthenticatePostRequest
}

/**
 * Request parameters for apiV1AuthenticationSchemesGet operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiApiV1AuthenticationSchemesGetRequest
 */
export interface IntegrationsApiApiV1AuthenticationSchemesGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof IntegrationsApiApiV1AuthenticationSchemesGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof IntegrationsApiApiV1AuthenticationSchemesGet
     */
    readonly xClientSecret: string
}

/**
 * Request parameters for apiV1CataloglinkGet operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiApiV1CataloglinkGetRequest
 */
export interface IntegrationsApiApiV1CataloglinkGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof IntegrationsApiApiV1CataloglinkGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof IntegrationsApiApiV1CataloglinkGet
     */
    readonly xClientSecret: string

    /**
     * A unique Id representing the end user. Typically this will be a user Id from the              client application. Personally identifiable information, such as an email address or phone number,              should not be used.
     * @type {string}
     * @memberof IntegrationsApiApiV1CataloglinkGet
     */
    readonly userId?: string

    /**
     * Type of broker to redirect to. Will redirect to catalog if not provided.
     * @type {BrokerType}
     * @memberof IntegrationsApiApiV1CataloglinkGet
     */
    readonly brokerType?: BrokerType

    /**
     * Callback link - url to redirect user after authentication in brokerage account.  If not provided default client\&#39;s url will be used.
     * @type {string}
     * @memberof IntegrationsApiApiV1CataloglinkGet
     */
    readonly callbackUrl?: string
}

/**
 * Request parameters for apiV1CryptocurrencyWalletsGet operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiApiV1CryptocurrencyWalletsGetRequest
 */
export interface IntegrationsApiApiV1CryptocurrencyWalletsGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof IntegrationsApiApiV1CryptocurrencyWalletsGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof IntegrationsApiApiV1CryptocurrencyWalletsGet
     */
    readonly xClientSecret: string
}

/**
 * Request parameters for apiV1StatusGet operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiApiV1StatusGetRequest
 */
export interface IntegrationsApiApiV1StatusGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof IntegrationsApiApiV1StatusGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof IntegrationsApiApiV1StatusGet
     */
    readonly xClientSecret: string
}

/**
 * Request parameters for apiV1TokenRefreshPost operation in IntegrationsApi.
 * @export
 * @interface IntegrationsApiApiV1TokenRefreshPostRequest
 */
export interface IntegrationsApiApiV1TokenRefreshPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof IntegrationsApiApiV1TokenRefreshPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof IntegrationsApiApiV1TokenRefreshPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TokenRefreshPostRequest}
     * @memberof IntegrationsApiApiV1TokenRefreshPost
     */
    readonly apiV1TokenRefreshPostRequest?: ApiV1TokenRefreshPostRequest
}

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * Remove connection to the financial institution and erase all related data completely.
     * @summary Remove connection
     * @param {IntegrationsApiApiV1AccountDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public apiV1AccountDelete(requestParameters: IntegrationsApiApiV1AccountDeleteRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).apiV1AccountDelete(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1BalanceGetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType
     * @summary Get OAuth authentication link
     * @param {IntegrationsApiApiV1AuthenticateBrokerTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public apiV1AuthenticateBrokerTypeGet(requestParameters: IntegrationsApiApiV1AuthenticateBrokerTypeGetRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).apiV1AuthenticateBrokerTypeGet(requestParameters.brokerType, requestParameters.userId, requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate user\'s brokerage/exchange account programmatically (not using the Web Catalog UI)
     * @summary Authenticate user\'s account
     * @param {IntegrationsApiApiV1AuthenticatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public apiV1AuthenticatePost(requestParameters: IntegrationsApiApiV1AuthenticatePostRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).apiV1AuthenticatePost(requestParameters.userId, requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1AuthenticatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get authentication schemes of available integrations to perform authentication programmatically (not using  the Web Catalog UI).
     * @summary Get authentication schemes
     * @param {IntegrationsApiApiV1AuthenticationSchemesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public apiV1AuthenticationSchemesGet(requestParameters: IntegrationsApiApiV1AuthenticationSchemesGetRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).apiV1AuthenticationSchemesGet(requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get personalized catalog link for client
     * @summary Get catalog link
     * @param {IntegrationsApiApiV1CataloglinkGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public apiV1CataloglinkGet(requestParameters: IntegrationsApiApiV1CataloglinkGetRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).apiV1CataloglinkGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.userId, requestParameters.brokerType, requestParameters.callbackUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supported cryptocurrency wallets and cryptocurrency addresses to perform authentication programmatically (not using  the Web Catalog UI).
     * @summary Get supported wallets
     * @param {IntegrationsApiApiV1CryptocurrencyWalletsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public apiV1CryptocurrencyWalletsGet(requestParameters: IntegrationsApiApiV1CryptocurrencyWalletsGetRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).apiV1CryptocurrencyWalletsGet(requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the list of supported institutions and their health statuses.
     * @summary Get health status
     * @param {IntegrationsApiApiV1StatusGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public apiV1StatusGet(requestParameters: IntegrationsApiApiV1StatusGetRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).apiV1StatusGet(requestParameters.xClientId, requestParameters.xClientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh auth token of the connected institution.  Some institutions do not require tokens to be refreshed.                The following institutions require custom flows:                WeBull: AuthToken should be provided along with the RefreshToken                TdAmeritrade: refresh token should also be refreshed.  CreateNewRefreshToken parameter should be set to true in order  to refresh the refresh token for TdAmeritrade.
     * @summary Refresh auth token
     * @param {IntegrationsApiApiV1TokenRefreshPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public apiV1TokenRefreshPost(requestParameters: IntegrationsApiApiV1TokenRefreshPostRequest, options?: AxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).apiV1TokenRefreshPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TokenRefreshPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NewsApi - axios parameter creator
 * @export
 */
export const NewsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve news related to the symbol in the request.
         * @summary Retrieve news related to the cryptocurrency symbol in the request
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {number} [from] Lower timestamp limit of the news. If not speciefied news will be returned from the last 7 days.
         * @param {number} [to] Upper timestamp limit of the news. If not speciefied news will be returned up to the current time.
         * @param {string} [symbol] Specifies which symbol\&#39;s news should be returned.
         * @param {number} [count] The number of news to return. If not specified the maximum 25 value will be used.
         * @param {number} [offset] The offset which is used for paginatin the result set.
         * @param {'Rank' | 'Timestamp'} [order] Specifies the sorting criteria of the news. By default the most relevant news will be returned first.
         * @param {'Ascending' | 'Descending'} [sortDirection] Specifies the soring direction of the result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NewsCryptocurrencyGet: async (xClientId: string, xClientSecret: string, from?: number, to?: number, symbol?: string, count?: number, offset?: number, order?: 'Rank' | 'Timestamp', sortDirection?: 'Ascending' | 'Descending', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1NewsCryptocurrencyGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1NewsCryptocurrencyGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/news/cryptocurrency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (from !== undefined) {
                localVarQueryParameter['From'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['To'] = to;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['Symbol'] = symbol;
            }

            if (count !== undefined) {
                localVarQueryParameter['Count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['Offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['Order'] = order;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['SortDirection'] = sortDirection;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve news related to the symbol in the request.
         * @summary Retrieve news related to the symbol in the request
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {number} [from] Lower timestamp limit of the news. If not speciefied news will be returned from the last 7 days.
         * @param {number} [to] Upper timestamp limit of the news. If not speciefied news will be returned up to the current time.
         * @param {string} [symbol] Specifies which symbol\&#39;s news should be returned.
         * @param {number} [count] The number of news to return. If not specified the maximum 25 value will be used.
         * @param {number} [offset] The offset which is used for paginatin the result set.
         * @param {'Rank' | 'Timestamp'} [order] Specifies the sorting criteria of the news. By default the most relevant news will be returned first.
         * @param {'Ascending' | 'Descending'} [sortDirection] Specifies the soring direction of the result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NewsStockGet: async (xClientId: string, xClientSecret: string, from?: number, to?: number, symbol?: string, count?: number, offset?: number, order?: 'Rank' | 'Timestamp', sortDirection?: 'Ascending' | 'Descending', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1NewsStockGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1NewsStockGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/news/stock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (from !== undefined) {
                localVarQueryParameter['From'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['To'] = to;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['Symbol'] = symbol;
            }

            if (count !== undefined) {
                localVarQueryParameter['Count'] = count;
            }

            if (offset !== undefined) {
                localVarQueryParameter['Offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['Order'] = order;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['SortDirection'] = sortDirection;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NewsApi - functional programming interface
 * @export
 */
export const NewsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NewsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve news related to the symbol in the request.
         * @summary Retrieve news related to the cryptocurrency symbol in the request
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {number} [from] Lower timestamp limit of the news. If not speciefied news will be returned from the last 7 days.
         * @param {number} [to] Upper timestamp limit of the news. If not speciefied news will be returned up to the current time.
         * @param {string} [symbol] Specifies which symbol\&#39;s news should be returned.
         * @param {number} [count] The number of news to return. If not specified the maximum 25 value will be used.
         * @param {number} [offset] The offset which is used for paginatin the result set.
         * @param {'Rank' | 'Timestamp'} [order] Specifies the sorting criteria of the news. By default the most relevant news will be returned first.
         * @param {'Ascending' | 'Descending'} [sortDirection] Specifies the soring direction of the result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1NewsCryptocurrencyGet(xClientId: string, xClientSecret: string, from?: number, to?: number, symbol?: string, count?: number, offset?: number, order?: 'Rank' | 'Timestamp', sortDirection?: 'Ascending' | 'Descending', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BSymbolNewsResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1NewsCryptocurrencyGet(xClientId, xClientSecret, from, to, symbol, count, offset, order, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve news related to the symbol in the request.
         * @summary Retrieve news related to the symbol in the request
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {number} [from] Lower timestamp limit of the news. If not speciefied news will be returned from the last 7 days.
         * @param {number} [to] Upper timestamp limit of the news. If not speciefied news will be returned up to the current time.
         * @param {string} [symbol] Specifies which symbol\&#39;s news should be returned.
         * @param {number} [count] The number of news to return. If not specified the maximum 25 value will be used.
         * @param {number} [offset] The offset which is used for paginatin the result set.
         * @param {'Rank' | 'Timestamp'} [order] Specifies the sorting criteria of the news. By default the most relevant news will be returned first.
         * @param {'Ascending' | 'Descending'} [sortDirection] Specifies the soring direction of the result set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1NewsStockGet(xClientId: string, xClientSecret: string, from?: number, to?: number, symbol?: string, count?: number, offset?: number, order?: 'Rank' | 'Timestamp', sortDirection?: 'Ascending' | 'Descending', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BSymbolNewsResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1NewsStockGet(xClientId, xClientSecret, from, to, symbol, count, offset, order, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NewsApi - factory interface
 * @export
 */
export const NewsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NewsApiFp(configuration)
    return {
        /**
         * Retrieve news related to the symbol in the request.
         * @summary Retrieve news related to the cryptocurrency symbol in the request
         * @param {NewsApiApiV1NewsCryptocurrencyGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NewsCryptocurrencyGet(requestParameters: NewsApiApiV1NewsCryptocurrencyGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BSymbolNewsResponseIApiResult> {
            return localVarFp.apiV1NewsCryptocurrencyGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.from, requestParameters.to, requestParameters.symbol, requestParameters.count, requestParameters.offset, requestParameters.order, requestParameters.sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve news related to the symbol in the request.
         * @summary Retrieve news related to the symbol in the request
         * @param {NewsApiApiV1NewsStockGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1NewsStockGet(requestParameters: NewsApiApiV1NewsStockGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BSymbolNewsResponseIApiResult> {
            return localVarFp.apiV1NewsStockGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.from, requestParameters.to, requestParameters.symbol, requestParameters.count, requestParameters.offset, requestParameters.order, requestParameters.sortDirection, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1NewsCryptocurrencyGet operation in NewsApi.
 * @export
 * @interface NewsApiApiV1NewsCryptocurrencyGetRequest
 */
export interface NewsApiApiV1NewsCryptocurrencyGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly xClientSecret: string

    /**
     * Lower timestamp limit of the news. If not speciefied news will be returned from the last 7 days.
     * @type {number}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly from?: number

    /**
     * Upper timestamp limit of the news. If not speciefied news will be returned up to the current time.
     * @type {number}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly to?: number

    /**
     * Specifies which symbol\&#39;s news should be returned.
     * @type {string}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly symbol?: string

    /**
     * The number of news to return. If not specified the maximum 25 value will be used.
     * @type {number}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly count?: number

    /**
     * The offset which is used for paginatin the result set.
     * @type {number}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly offset?: number

    /**
     * Specifies the sorting criteria of the news. By default the most relevant news will be returned first.
     * @type {'Rank' | 'Timestamp'}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly order?: 'Rank' | 'Timestamp'

    /**
     * Specifies the soring direction of the result set.
     * @type {'Ascending' | 'Descending'}
     * @memberof NewsApiApiV1NewsCryptocurrencyGet
     */
    readonly sortDirection?: 'Ascending' | 'Descending'
}

/**
 * Request parameters for apiV1NewsStockGet operation in NewsApi.
 * @export
 * @interface NewsApiApiV1NewsStockGetRequest
 */
export interface NewsApiApiV1NewsStockGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly xClientSecret: string

    /**
     * Lower timestamp limit of the news. If not speciefied news will be returned from the last 7 days.
     * @type {number}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly from?: number

    /**
     * Upper timestamp limit of the news. If not speciefied news will be returned up to the current time.
     * @type {number}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly to?: number

    /**
     * Specifies which symbol\&#39;s news should be returned.
     * @type {string}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly symbol?: string

    /**
     * The number of news to return. If not specified the maximum 25 value will be used.
     * @type {number}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly count?: number

    /**
     * The offset which is used for paginatin the result set.
     * @type {number}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly offset?: number

    /**
     * Specifies the sorting criteria of the news. By default the most relevant news will be returned first.
     * @type {'Rank' | 'Timestamp'}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly order?: 'Rank' | 'Timestamp'

    /**
     * Specifies the soring direction of the result set.
     * @type {'Ascending' | 'Descending'}
     * @memberof NewsApiApiV1NewsStockGet
     */
    readonly sortDirection?: 'Ascending' | 'Descending'
}

/**
 * NewsApi - object-oriented interface
 * @export
 * @class NewsApi
 * @extends {BaseAPI}
 */
export class NewsApi extends BaseAPI {
    /**
     * Retrieve news related to the symbol in the request.
     * @summary Retrieve news related to the cryptocurrency symbol in the request
     * @param {NewsApiApiV1NewsCryptocurrencyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public apiV1NewsCryptocurrencyGet(requestParameters: NewsApiApiV1NewsCryptocurrencyGetRequest, options?: AxiosRequestConfig) {
        return NewsApiFp(this.configuration).apiV1NewsCryptocurrencyGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.from, requestParameters.to, requestParameters.symbol, requestParameters.count, requestParameters.offset, requestParameters.order, requestParameters.sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve news related to the symbol in the request.
     * @summary Retrieve news related to the symbol in the request
     * @param {NewsApiApiV1NewsStockGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NewsApi
     */
    public apiV1NewsStockGet(requestParameters: NewsApiApiV1NewsStockGetRequest, options?: AxiosRequestConfig) {
        return NewsApiFp(this.configuration).apiV1NewsStockGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.from, requestParameters.to, requestParameters.symbol, requestParameters.count, requestParameters.offset, requestParameters.order, requestParameters.sortDirection, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PortfolioApi - axios parameter creator
 * @export
 */
export const PortfolioApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.
         * @summary Get holdings
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1BalanceGetPostRequest} [apiV1BalanceGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1HoldingsGetPost: async (xClientId: string, xClientSecret: string, apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1HoldingsGetPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1HoldingsGetPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/holdings/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1BalanceGetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get suggested portfolio optimizations based on different annualized standard deviations and performance.
         * @summary Get optimized portfolio
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {string} [userId] Id of the end user to get the optimization of the aggregated portfolio for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1HoldingsOptimizeGet: async (xClientId: string, xClientSecret: string, userId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1HoldingsOptimizeGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1HoldingsOptimizeGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/holdings/optimize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the aggregated portfolio of the user containing market values.
         * @summary Get aggregated portfolio
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {string} [userId] End user ID to get the aggregated portfolio for.
         * @param {number} [timezoneOffset] Offset in second, used to calculate daily return for cryptocurrencies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1HoldingsPortfolioGet: async (xClientId: string, xClientSecret: string, userId?: string, timezoneOffset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1HoldingsPortfolioGet', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1HoldingsPortfolioGet', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/holdings/portfolio`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['UserId'] = userId;
            }

            if (timezoneOffset !== undefined) {
                localVarQueryParameter['TimezoneOffset'] = timezoneOffset;
            }

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortfolioApi - functional programming interface
 * @export
 */
export const PortfolioApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortfolioApiAxiosParamCreator(configuration)
    return {
        /**
         * Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.
         * @summary Get holdings
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1BalanceGetPostRequest} [apiV1BalanceGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1HoldingsGetPost(xClientId: string, xClientSecret: string, apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerPortfolioModelIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1HoldingsGetPost(xClientId, xClientSecret, apiV1BalanceGetPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get suggested portfolio optimizations based on different annualized standard deviations and performance.
         * @summary Get optimized portfolio
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {string} [userId] Id of the end user to get the optimization of the aggregated portfolio for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1HoldingsOptimizeGet(xClientId: string, xClientSecret: string, userId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BPortfolioOptimizationModelIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1HoldingsOptimizeGet(xClientId, xClientSecret, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the aggregated portfolio of the user containing market values.
         * @summary Get aggregated portfolio
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {string} [userId] End user ID to get the aggregated portfolio for.
         * @param {number} [timezoneOffset] Offset in second, used to calculate daily return for cryptocurrencies.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1HoldingsPortfolioGet(xClientId: string, xClientSecret: string, userId?: string, timezoneOffset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BPortfolioModelIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1HoldingsPortfolioGet(xClientId, xClientSecret, userId, timezoneOffset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PortfolioApi - factory interface
 * @export
 */
export const PortfolioApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortfolioApiFp(configuration)
    return {
        /**
         * Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.
         * @summary Get holdings
         * @param {PortfolioApiApiV1HoldingsGetPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1HoldingsGetPost(requestParameters: PortfolioApiApiV1HoldingsGetPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerPortfolioModelIApiResult> {
            return localVarFp.apiV1HoldingsGetPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1BalanceGetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get suggested portfolio optimizations based on different annualized standard deviations and performance.
         * @summary Get optimized portfolio
         * @param {PortfolioApiApiV1HoldingsOptimizeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1HoldingsOptimizeGet(requestParameters: PortfolioApiApiV1HoldingsOptimizeGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BPortfolioOptimizationModelIApiResult> {
            return localVarFp.apiV1HoldingsOptimizeGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the aggregated portfolio of the user containing market values.
         * @summary Get aggregated portfolio
         * @param {PortfolioApiApiV1HoldingsPortfolioGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1HoldingsPortfolioGet(requestParameters: PortfolioApiApiV1HoldingsPortfolioGetRequest, options?: AxiosRequestConfig): AxiosPromise<B2BPortfolioModelIApiResult> {
            return localVarFp.apiV1HoldingsPortfolioGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.userId, requestParameters.timezoneOffset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1HoldingsGetPost operation in PortfolioApi.
 * @export
 * @interface PortfolioApiApiV1HoldingsGetPostRequest
 */
export interface PortfolioApiApiV1HoldingsGetPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof PortfolioApiApiV1HoldingsGetPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof PortfolioApiApiV1HoldingsGetPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1BalanceGetPostRequest}
     * @memberof PortfolioApiApiV1HoldingsGetPost
     */
    readonly apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest
}

/**
 * Request parameters for apiV1HoldingsOptimizeGet operation in PortfolioApi.
 * @export
 * @interface PortfolioApiApiV1HoldingsOptimizeGetRequest
 */
export interface PortfolioApiApiV1HoldingsOptimizeGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof PortfolioApiApiV1HoldingsOptimizeGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof PortfolioApiApiV1HoldingsOptimizeGet
     */
    readonly xClientSecret: string

    /**
     * Id of the end user to get the optimization of the aggregated portfolio for.
     * @type {string}
     * @memberof PortfolioApiApiV1HoldingsOptimizeGet
     */
    readonly userId?: string
}

/**
 * Request parameters for apiV1HoldingsPortfolioGet operation in PortfolioApi.
 * @export
 * @interface PortfolioApiApiV1HoldingsPortfolioGetRequest
 */
export interface PortfolioApiApiV1HoldingsPortfolioGetRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof PortfolioApiApiV1HoldingsPortfolioGet
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof PortfolioApiApiV1HoldingsPortfolioGet
     */
    readonly xClientSecret: string

    /**
     * End user ID to get the aggregated portfolio for.
     * @type {string}
     * @memberof PortfolioApiApiV1HoldingsPortfolioGet
     */
    readonly userId?: string

    /**
     * Offset in second, used to calculate daily return for cryptocurrencies.
     * @type {number}
     * @memberof PortfolioApiApiV1HoldingsPortfolioGet
     */
    readonly timezoneOffset?: number
}

/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
    /**
     * Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.
     * @summary Get holdings
     * @param {PortfolioApiApiV1HoldingsGetPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public apiV1HoldingsGetPost(requestParameters: PortfolioApiApiV1HoldingsGetPostRequest, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).apiV1HoldingsGetPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1BalanceGetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get suggested portfolio optimizations based on different annualized standard deviations and performance.
     * @summary Get optimized portfolio
     * @param {PortfolioApiApiV1HoldingsOptimizeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public apiV1HoldingsOptimizeGet(requestParameters: PortfolioApiApiV1HoldingsOptimizeGetRequest, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).apiV1HoldingsOptimizeGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the aggregated portfolio of the user containing market values.
     * @summary Get aggregated portfolio
     * @param {PortfolioApiApiV1HoldingsPortfolioGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    public apiV1HoldingsPortfolioGet(requestParameters: PortfolioApiApiV1HoldingsPortfolioGetRequest, options?: AxiosRequestConfig) {
        return PortfolioApiFp(this.configuration).apiV1HoldingsPortfolioGet(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.userId, requestParameters.timezoneOffset, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancels a pending order (an order with `InProgress` status).  `SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions.  This value
         * @summary Cancel order execution
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsDetailsPostRequest} [apiV1TransactionsDetailsPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsCancelPost: async (xClientId: string, xClientSecret: string, apiV1TransactionsDetailsPostRequest?: ApiV1TransactionsDetailsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransactionsCancelPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransactionsCancelPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transactions/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransactionsDetailsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of an executed order. Typically used to poll the status of the previously executed order.
         * @summary Get transaction details
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsDetailsPostRequest} [apiV1TransactionsDetailsPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsDetailsPost: async (xClientId: string, xClientSecret: string, apiV1TransactionsDetailsPostRequest?: ApiV1TransactionsDetailsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransactionsDetailsPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransactionsDetailsPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transactions/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransactionsDetailsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get supported features for trading for a particular financial institution. Different institutions support different  features (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to  describe such features for provided financial institution.
         * @summary Get supported order features for institution
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1BalanceGetPostRequest} [apiV1BalanceGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsFeatureListPost: async (xClientId: string, xClientSecret: string, apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransactionsFeatureListPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransactionsFeatureListPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transactions/featureList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1BalanceGetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transactions on the account - the paginated history of the executed orders along with the pending orders.
         * @summary Get transactions
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsListPostRequest} [apiV1TransactionsListPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsListPost: async (xClientId: string, xClientSecret: string, apiV1TransactionsListPostRequest?: ApiV1TransactionsListPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransactionsListPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransactionsListPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transactions/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransactionsListPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates the order information (such as necessary balance availability), and returns additional information,  such as expected order fee.  Does not execute the order.
         * @summary Preview order execution
         * @param {'Unknown' | 'Buy' | 'Sell'} side
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsPreviewSidePostRequest} [apiV1TransactionsPreviewSidePostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsPreviewSidePost: async (side: 'Unknown' | 'Buy' | 'Sell', xClientId: string, xClientSecret: string, apiV1TransactionsPreviewSidePostRequest?: ApiV1TransactionsPreviewSidePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('apiV1TransactionsPreviewSidePost', 'side', side)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransactionsPreviewSidePost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransactionsPreviewSidePost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transactions/preview/{side}`
                .replace(`{${"side"}}`, encodeURIComponent(String(side)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransactionsPreviewSidePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validates the order information and then calls institution\'s API to execute an order.  It\'s recommended to call this endpoint after calling the `preview` endpoint to make sure that the  order execution request is correct.
         * @summary Execute order
         * @param {'Unknown' | 'Buy' | 'Sell'} side
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsPreviewSidePostRequest} [apiV1TransactionsPreviewSidePostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsSidePost: async (side: 'Unknown' | 'Buy' | 'Sell', xClientId: string, xClientSecret: string, apiV1TransactionsPreviewSidePostRequest?: ApiV1TransactionsPreviewSidePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'side' is not null or undefined
            assertParamExists('apiV1TransactionsSidePost', 'side', side)
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransactionsSidePost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransactionsSidePost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transactions/{side}`
                .replace(`{${"side"}}`, encodeURIComponent(String(side)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransactionsPreviewSidePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information on trading allowance for a provided symbol.  For example - some institutions allow fractional trading for some symbols, but do not allow it  for others. So before placing an order the API client can check if the required symbol can be traded fractionally  with the provided institution.
         * @summary Get symbol information
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsSymbolinfoPostRequest} [apiV1TransactionsSymbolinfoPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsSymbolinfoPost: async (xClientId: string, xClientSecret: string, apiV1TransactionsSymbolinfoPostRequest?: ApiV1TransactionsSymbolinfoPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransactionsSymbolinfoPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransactionsSymbolinfoPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transactions/symbolinfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransactionsSymbolinfoPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancels a pending order (an order with `InProgress` status).  `SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions.  This value
         * @summary Cancel order execution
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsDetailsPostRequest} [apiV1TransactionsDetailsPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransactionsCancelPost(xClientId: string, xClientSecret: string, apiV1TransactionsDetailsPostRequest?: ApiV1TransactionsDetailsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransactionsCancelPost(xClientId, xClientSecret, apiV1TransactionsDetailsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of an executed order. Typically used to poll the status of the previously executed order.
         * @summary Get transaction details
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsDetailsPostRequest} [apiV1TransactionsDetailsPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransactionsDetailsPost(xClientId: string, xClientSecret: string, apiV1TransactionsDetailsPostRequest?: ApiV1TransactionsDetailsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerOrderIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransactionsDetailsPost(xClientId, xClientSecret, apiV1TransactionsDetailsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get supported features for trading for a particular financial institution. Different institutions support different  features (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to  describe such features for provided financial institution.
         * @summary Get supported order features for institution
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1BalanceGetPostRequest} [apiV1BalanceGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransactionsFeatureListPost(xClientId: string, xClientSecret: string, apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerTradingFeatureInfoIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransactionsFeatureListPost(xClientId, xClientSecret, apiV1BalanceGetPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get transactions on the account - the paginated history of the executed orders along with the pending orders.
         * @summary Get transactions
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsListPostRequest} [apiV1TransactionsListPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransactionsListPost(xClientId: string, xClientSecret: string, apiV1TransactionsListPostRequest?: ApiV1TransactionsListPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerOrderListResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransactionsListPost(xClientId, xClientSecret, apiV1TransactionsListPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates the order information (such as necessary balance availability), and returns additional information,  such as expected order fee.  Does not execute the order.
         * @summary Preview order execution
         * @param {'Unknown' | 'Buy' | 'Sell'} side
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsPreviewSidePostRequest} [apiV1TransactionsPreviewSidePostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransactionsPreviewSidePost(side: 'Unknown' | 'Buy' | 'Sell', xClientId: string, xClientSecret: string, apiV1TransactionsPreviewSidePostRequest?: ApiV1TransactionsPreviewSidePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerPreviewOrderResultIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransactionsPreviewSidePost(side, xClientId, xClientSecret, apiV1TransactionsPreviewSidePostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Validates the order information and then calls institution\'s API to execute an order.  It\'s recommended to call this endpoint after calling the `preview` endpoint to make sure that the  order execution request is correct.
         * @summary Execute order
         * @param {'Unknown' | 'Buy' | 'Sell'} side
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsPreviewSidePostRequest} [apiV1TransactionsPreviewSidePostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransactionsSidePost(side: 'Unknown' | 'Buy' | 'Sell', xClientId: string, xClientSecret: string, apiV1TransactionsPreviewSidePostRequest?: ApiV1TransactionsPreviewSidePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerCreateOrderResultIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransactionsSidePost(side, xClientId, xClientSecret, apiV1TransactionsPreviewSidePostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns information on trading allowance for a provided symbol.  For example - some institutions allow fractional trading for some symbols, but do not allow it  for others. So before placing an order the API client can check if the required symbol can be traded fractionally  with the provided institution.
         * @summary Get symbol information
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransactionsSymbolinfoPostRequest} [apiV1TransactionsSymbolinfoPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransactionsSymbolinfoPost(xClientId: string, xClientSecret: string, apiV1TransactionsSymbolinfoPostRequest?: ApiV1TransactionsSymbolinfoPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerOrderSymbolInfoIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransactionsSymbolinfoPost(xClientId, xClientSecret, apiV1TransactionsSymbolinfoPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Cancels a pending order (an order with `InProgress` status).  `SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions.  This value
         * @summary Cancel order execution
         * @param {TransactionsApiApiV1TransactionsCancelPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsCancelPost(requestParameters: TransactionsApiApiV1TransactionsCancelPostRequest, options?: AxiosRequestConfig): AxiosPromise<IApiResult> {
            return localVarFp.apiV1TransactionsCancelPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsDetailsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of an executed order. Typically used to poll the status of the previously executed order.
         * @summary Get transaction details
         * @param {TransactionsApiApiV1TransactionsDetailsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsDetailsPost(requestParameters: TransactionsApiApiV1TransactionsDetailsPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerOrderIApiResult> {
            return localVarFp.apiV1TransactionsDetailsPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsDetailsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get supported features for trading for a particular financial institution. Different institutions support different  features (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to  describe such features for provided financial institution.
         * @summary Get supported order features for institution
         * @param {TransactionsApiApiV1TransactionsFeatureListPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsFeatureListPost(requestParameters: TransactionsApiApiV1TransactionsFeatureListPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerTradingFeatureInfoIApiResult> {
            return localVarFp.apiV1TransactionsFeatureListPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1BalanceGetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transactions on the account - the paginated history of the executed orders along with the pending orders.
         * @summary Get transactions
         * @param {TransactionsApiApiV1TransactionsListPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsListPost(requestParameters: TransactionsApiApiV1TransactionsListPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerOrderListResponseIApiResult> {
            return localVarFp.apiV1TransactionsListPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsListPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates the order information (such as necessary balance availability), and returns additional information,  such as expected order fee.  Does not execute the order.
         * @summary Preview order execution
         * @param {TransactionsApiApiV1TransactionsPreviewSidePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsPreviewSidePost(requestParameters: TransactionsApiApiV1TransactionsPreviewSidePostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerPreviewOrderResultIApiResult> {
            return localVarFp.apiV1TransactionsPreviewSidePost(requestParameters.side, requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsPreviewSidePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Validates the order information and then calls institution\'s API to execute an order.  It\'s recommended to call this endpoint after calling the `preview` endpoint to make sure that the  order execution request is correct.
         * @summary Execute order
         * @param {TransactionsApiApiV1TransactionsSidePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsSidePost(requestParameters: TransactionsApiApiV1TransactionsSidePostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerCreateOrderResultIApiResult> {
            return localVarFp.apiV1TransactionsSidePost(requestParameters.side, requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsPreviewSidePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information on trading allowance for a provided symbol.  For example - some institutions allow fractional trading for some symbols, but do not allow it  for others. So before placing an order the API client can check if the required symbol can be traded fractionally  with the provided institution.
         * @summary Get symbol information
         * @param {TransactionsApiApiV1TransactionsSymbolinfoPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransactionsSymbolinfoPost(requestParameters: TransactionsApiApiV1TransactionsSymbolinfoPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerOrderSymbolInfoIApiResult> {
            return localVarFp.apiV1TransactionsSymbolinfoPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsSymbolinfoPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1TransactionsCancelPost operation in TransactionsApi.
 * @export
 * @interface TransactionsApiApiV1TransactionsCancelPostRequest
 */
export interface TransactionsApiApiV1TransactionsCancelPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsCancelPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsCancelPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransactionsDetailsPostRequest}
     * @memberof TransactionsApiApiV1TransactionsCancelPost
     */
    readonly apiV1TransactionsDetailsPostRequest?: ApiV1TransactionsDetailsPostRequest
}

/**
 * Request parameters for apiV1TransactionsDetailsPost operation in TransactionsApi.
 * @export
 * @interface TransactionsApiApiV1TransactionsDetailsPostRequest
 */
export interface TransactionsApiApiV1TransactionsDetailsPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsDetailsPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsDetailsPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransactionsDetailsPostRequest}
     * @memberof TransactionsApiApiV1TransactionsDetailsPost
     */
    readonly apiV1TransactionsDetailsPostRequest?: ApiV1TransactionsDetailsPostRequest
}

/**
 * Request parameters for apiV1TransactionsFeatureListPost operation in TransactionsApi.
 * @export
 * @interface TransactionsApiApiV1TransactionsFeatureListPostRequest
 */
export interface TransactionsApiApiV1TransactionsFeatureListPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsFeatureListPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsFeatureListPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1BalanceGetPostRequest}
     * @memberof TransactionsApiApiV1TransactionsFeatureListPost
     */
    readonly apiV1BalanceGetPostRequest?: ApiV1BalanceGetPostRequest
}

/**
 * Request parameters for apiV1TransactionsListPost operation in TransactionsApi.
 * @export
 * @interface TransactionsApiApiV1TransactionsListPostRequest
 */
export interface TransactionsApiApiV1TransactionsListPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsListPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsListPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransactionsListPostRequest}
     * @memberof TransactionsApiApiV1TransactionsListPost
     */
    readonly apiV1TransactionsListPostRequest?: ApiV1TransactionsListPostRequest
}

/**
 * Request parameters for apiV1TransactionsPreviewSidePost operation in TransactionsApi.
 * @export
 * @interface TransactionsApiApiV1TransactionsPreviewSidePostRequest
 */
export interface TransactionsApiApiV1TransactionsPreviewSidePostRequest {
    /**
     *
     * @type {'Unknown' | 'Buy' | 'Sell'}
     * @memberof TransactionsApiApiV1TransactionsPreviewSidePost
     */
    readonly side: 'Unknown' | 'Buy' | 'Sell'

    /**
     * Id of the client
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsPreviewSidePost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsPreviewSidePost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransactionsPreviewSidePostRequest}
     * @memberof TransactionsApiApiV1TransactionsPreviewSidePost
     */
    readonly apiV1TransactionsPreviewSidePostRequest?: ApiV1TransactionsPreviewSidePostRequest
}

/**
 * Request parameters for apiV1TransactionsSidePost operation in TransactionsApi.
 * @export
 * @interface TransactionsApiApiV1TransactionsSidePostRequest
 */
export interface TransactionsApiApiV1TransactionsSidePostRequest {
    /**
     *
     * @type {'Unknown' | 'Buy' | 'Sell'}
     * @memberof TransactionsApiApiV1TransactionsSidePost
     */
    readonly side: 'Unknown' | 'Buy' | 'Sell'

    /**
     * Id of the client
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsSidePost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsSidePost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransactionsPreviewSidePostRequest}
     * @memberof TransactionsApiApiV1TransactionsSidePost
     */
    readonly apiV1TransactionsPreviewSidePostRequest?: ApiV1TransactionsPreviewSidePostRequest
}

/**
 * Request parameters for apiV1TransactionsSymbolinfoPost operation in TransactionsApi.
 * @export
 * @interface TransactionsApiApiV1TransactionsSymbolinfoPostRequest
 */
export interface TransactionsApiApiV1TransactionsSymbolinfoPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsSymbolinfoPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransactionsApiApiV1TransactionsSymbolinfoPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransactionsSymbolinfoPostRequest}
     * @memberof TransactionsApiApiV1TransactionsSymbolinfoPost
     */
    readonly apiV1TransactionsSymbolinfoPostRequest?: ApiV1TransactionsSymbolinfoPostRequest
}

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Cancels a pending order (an order with `InProgress` status).  `SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions.  This value
     * @summary Cancel order execution
     * @param {TransactionsApiApiV1TransactionsCancelPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public apiV1TransactionsCancelPost(requestParameters: TransactionsApiApiV1TransactionsCancelPostRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).apiV1TransactionsCancelPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsDetailsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of an executed order. Typically used to poll the status of the previously executed order.
     * @summary Get transaction details
     * @param {TransactionsApiApiV1TransactionsDetailsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public apiV1TransactionsDetailsPost(requestParameters: TransactionsApiApiV1TransactionsDetailsPostRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).apiV1TransactionsDetailsPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsDetailsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get supported features for trading for a particular financial institution. Different institutions support different  features (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to  describe such features for provided financial institution.
     * @summary Get supported order features for institution
     * @param {TransactionsApiApiV1TransactionsFeatureListPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public apiV1TransactionsFeatureListPost(requestParameters: TransactionsApiApiV1TransactionsFeatureListPostRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).apiV1TransactionsFeatureListPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1BalanceGetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transactions on the account - the paginated history of the executed orders along with the pending orders.
     * @summary Get transactions
     * @param {TransactionsApiApiV1TransactionsListPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public apiV1TransactionsListPost(requestParameters: TransactionsApiApiV1TransactionsListPostRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).apiV1TransactionsListPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsListPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates the order information (such as necessary balance availability), and returns additional information,  such as expected order fee.  Does not execute the order.
     * @summary Preview order execution
     * @param {TransactionsApiApiV1TransactionsPreviewSidePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public apiV1TransactionsPreviewSidePost(requestParameters: TransactionsApiApiV1TransactionsPreviewSidePostRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).apiV1TransactionsPreviewSidePost(requestParameters.side, requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsPreviewSidePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validates the order information and then calls institution\'s API to execute an order.  It\'s recommended to call this endpoint after calling the `preview` endpoint to make sure that the  order execution request is correct.
     * @summary Execute order
     * @param {TransactionsApiApiV1TransactionsSidePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public apiV1TransactionsSidePost(requestParameters: TransactionsApiApiV1TransactionsSidePostRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).apiV1TransactionsSidePost(requestParameters.side, requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsPreviewSidePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information on trading allowance for a provided symbol.  For example - some institutions allow fractional trading for some symbols, but do not allow it  for others. So before placing an order the API client can check if the required symbol can be traded fractionally  with the provided institution.
     * @summary Get symbol information
     * @param {TransactionsApiApiV1TransactionsSymbolinfoPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public apiV1TransactionsSymbolinfoPost(requestParameters: TransactionsApiApiV1TransactionsSymbolinfoPostRequest, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).apiV1TransactionsSymbolinfoPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransactionsSymbolinfoPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransfersApi - axios parameter creator
 * @export
 */
export const TransfersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
         * @summary Get deposit address
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersAddressGetPostRequest} [apiV1TransfersAddressGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersAddressGetPost: async (xClientId: string, xClientSecret: string, apiV1TransfersAddressGetPostRequest?: ApiV1TransfersAddressGetPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransfersAddressGetPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransfersAddressGetPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transfers/address/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransfersAddressGetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a cryptocurrency transfer.
         * @summary Get transfer
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersDetailsPostRequest} [apiV1TransfersDetailsPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersDetailsPost: async (xClientId: string, xClientSecret: string, apiV1TransfersDetailsPostRequest?: ApiV1TransfersDetailsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransfersDetailsPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransfersDetailsPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transfers/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransfersDetailsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get cryptocurrency transfers, such as transfers on a cryptocurrency wallet, or  deposit/withdrawal transfers on an cryptocurrency exchange account.
         * @summary List transfers
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersListPostRequest} [apiV1TransfersListPostRequest] Authentication token and integration type to obtain the list of transfers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersListPost: async (xClientId: string, xClientSecret: string, apiV1TransfersListPostRequest?: ApiV1TransfersListPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransfersListPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransfersListPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transfers/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransfersListPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange.
         * @summary Initiate a transfer
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersPostRequest} [apiV1TransfersPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersPost: async (xClientId: string, xClientSecret: string, apiV1TransfersPostRequest?: ApiV1TransfersPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransfersPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransfersPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transfers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransfersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple  blockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.
         * @summary Get details of asset
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersAddressGetPostRequest} [apiV1TransfersAddressGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersSymbolDetailsPost: async (xClientId: string, xClientSecret: string, apiV1TransfersAddressGetPostRequest?: ApiV1TransfersAddressGetPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xClientId' is not null or undefined
            assertParamExists('apiV1TransfersSymbolDetailsPost', 'xClientId', xClientId)
            // verify required parameter 'xClientSecret' is not null or undefined
            assertParamExists('apiV1TransfersSymbolDetailsPost', 'xClientSecret', xClientSecret)
            const localVarPath = `/api/v1/transfers/symbol/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication API-keys required
            await setApiKeyToObject(localVarHeaderParameter, "X-Client-Id and X-Client-Secret headers", configuration)

            if (xClientId != null) {
                localVarHeaderParameter['X-Client-Id'] = String(xClientId);
            }

            if (xClientSecret != null) {
                localVarHeaderParameter['X-Client-Secret'] = String(xClientSecret);
            }



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(apiV1TransfersAddressGetPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransfersApi - functional programming interface
 * @export
 */
export const TransfersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransfersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
         * @summary Get deposit address
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersAddressGetPostRequest} [apiV1TransfersAddressGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransfersAddressGetPost(xClientId: string, xClientSecret: string, apiV1TransfersAddressGetPostRequest?: ApiV1TransfersAddressGetPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerCryptocurrencyDepositAddressResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransfersAddressGetPost(xClientId, xClientSecret, apiV1TransfersAddressGetPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a cryptocurrency transfer.
         * @summary Get transfer
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersDetailsPostRequest} [apiV1TransfersDetailsPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransfersDetailsPost(xClientId: string, xClientSecret: string, apiV1TransfersDetailsPostRequest?: ApiV1TransfersDetailsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerCryptocurrencyTransactionIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransfersDetailsPost(xClientId, xClientSecret, apiV1TransfersDetailsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get cryptocurrency transfers, such as transfers on a cryptocurrency wallet, or  deposit/withdrawal transfers on an cryptocurrency exchange account.
         * @summary List transfers
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersListPostRequest} [apiV1TransfersListPostRequest] Authentication token and integration type to obtain the list of transfers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransfersListPost(xClientId: string, xClientSecret: string, apiV1TransfersListPostRequest?: ApiV1TransfersListPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerTransactionsListModelIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransfersListPost(xClientId, xClientSecret, apiV1TransfersListPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange.
         * @summary Initiate a transfer
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersPostRequest} [apiV1TransfersPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransfersPost(xClientId: string, xClientSecret: string, apiV1TransfersPostRequest?: ApiV1TransfersPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransfersPost(xClientId, xClientSecret, apiV1TransfersPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple  blockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.
         * @summary Get details of asset
         * @param {string} xClientId Id of the client
         * @param {string} xClientSecret Client secret, should be stored safely and never shared
         * @param {ApiV1TransfersAddressGetPostRequest} [apiV1TransfersAddressGetPostRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1TransfersSymbolDetailsPost(xClientId: string, xClientSecret: string, apiV1TransfersAddressGetPostRequest?: ApiV1TransfersAddressGetPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<B2BBrokerCryptocurrencyDepositAddressResponseIApiResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1TransfersSymbolDetailsPost(xClientId, xClientSecret, apiV1TransfersAddressGetPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransfersApi - factory interface
 * @export
 */
export const TransfersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransfersApiFp(configuration)
    return {
        /**
         * Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
         * @summary Get deposit address
         * @param {TransfersApiApiV1TransfersAddressGetPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersAddressGetPost(requestParameters: TransfersApiApiV1TransfersAddressGetPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerCryptocurrencyDepositAddressResponseIApiResult> {
            return localVarFp.apiV1TransfersAddressGetPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersAddressGetPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a cryptocurrency transfer.
         * @summary Get transfer
         * @param {TransfersApiApiV1TransfersDetailsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersDetailsPost(requestParameters: TransfersApiApiV1TransfersDetailsPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerCryptocurrencyTransactionIApiResult> {
            return localVarFp.apiV1TransfersDetailsPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersDetailsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get cryptocurrency transfers, such as transfers on a cryptocurrency wallet, or  deposit/withdrawal transfers on an cryptocurrency exchange account.
         * @summary List transfers
         * @param {TransfersApiApiV1TransfersListPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersListPost(requestParameters: TransfersApiApiV1TransfersListPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerTransactionsListModelIApiResult> {
            return localVarFp.apiV1TransfersListPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersListPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange.
         * @summary Initiate a transfer
         * @param {TransfersApiApiV1TransfersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersPost(requestParameters: TransfersApiApiV1TransfersPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult> {
            return localVarFp.apiV1TransfersPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple  blockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.
         * @summary Get details of asset
         * @param {TransfersApiApiV1TransfersSymbolDetailsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TransfersSymbolDetailsPost(requestParameters: TransfersApiApiV1TransfersSymbolDetailsPostRequest, options?: AxiosRequestConfig): AxiosPromise<B2BBrokerCryptocurrencyDepositAddressResponseIApiResult> {
            return localVarFp.apiV1TransfersSymbolDetailsPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersAddressGetPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiV1TransfersAddressGetPost operation in TransfersApi.
 * @export
 * @interface TransfersApiApiV1TransfersAddressGetPostRequest
 */
export interface TransfersApiApiV1TransfersAddressGetPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransfersApiApiV1TransfersAddressGetPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransfersApiApiV1TransfersAddressGetPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransfersAddressGetPostRequest}
     * @memberof TransfersApiApiV1TransfersAddressGetPost
     */
    readonly apiV1TransfersAddressGetPostRequest?: ApiV1TransfersAddressGetPostRequest
}

/**
 * Request parameters for apiV1TransfersDetailsPost operation in TransfersApi.
 * @export
 * @interface TransfersApiApiV1TransfersDetailsPostRequest
 */
export interface TransfersApiApiV1TransfersDetailsPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransfersApiApiV1TransfersDetailsPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransfersApiApiV1TransfersDetailsPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransfersDetailsPostRequest}
     * @memberof TransfersApiApiV1TransfersDetailsPost
     */
    readonly apiV1TransfersDetailsPostRequest?: ApiV1TransfersDetailsPostRequest
}

/**
 * Request parameters for apiV1TransfersListPost operation in TransfersApi.
 * @export
 * @interface TransfersApiApiV1TransfersListPostRequest
 */
export interface TransfersApiApiV1TransfersListPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransfersApiApiV1TransfersListPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransfersApiApiV1TransfersListPost
     */
    readonly xClientSecret: string

    /**
     * Authentication token and integration type to obtain the list of transfers.
     * @type {ApiV1TransfersListPostRequest}
     * @memberof TransfersApiApiV1TransfersListPost
     */
    readonly apiV1TransfersListPostRequest?: ApiV1TransfersListPostRequest
}

/**
 * Request parameters for apiV1TransfersPost operation in TransfersApi.
 * @export
 * @interface TransfersApiApiV1TransfersPostRequest
 */
export interface TransfersApiApiV1TransfersPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransfersApiApiV1TransfersPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransfersApiApiV1TransfersPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransfersPostRequest}
     * @memberof TransfersApiApiV1TransfersPost
     */
    readonly apiV1TransfersPostRequest?: ApiV1TransfersPostRequest
}

/**
 * Request parameters for apiV1TransfersSymbolDetailsPost operation in TransfersApi.
 * @export
 * @interface TransfersApiApiV1TransfersSymbolDetailsPostRequest
 */
export interface TransfersApiApiV1TransfersSymbolDetailsPostRequest {
    /**
     * Id of the client
     * @type {string}
     * @memberof TransfersApiApiV1TransfersSymbolDetailsPost
     */
    readonly xClientId: string

    /**
     * Client secret, should be stored safely and never shared
     * @type {string}
     * @memberof TransfersApiApiV1TransfersSymbolDetailsPost
     */
    readonly xClientSecret: string

    /**
     *
     * @type {ApiV1TransfersAddressGetPostRequest}
     * @memberof TransfersApiApiV1TransfersSymbolDetailsPost
     */
    readonly apiV1TransfersAddressGetPostRequest?: ApiV1TransfersAddressGetPostRequest
}

/**
 * TransfersApi - object-oriented interface
 * @export
 * @class TransfersApi
 * @extends {BaseAPI}
 */
export class TransfersApi extends BaseAPI {
    /**
     * Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
     * @summary Get deposit address
     * @param {TransfersApiApiV1TransfersAddressGetPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiV1TransfersAddressGetPost(requestParameters: TransfersApiApiV1TransfersAddressGetPostRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiV1TransfersAddressGetPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersAddressGetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a cryptocurrency transfer.
     * @summary Get transfer
     * @param {TransfersApiApiV1TransfersDetailsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiV1TransfersDetailsPost(requestParameters: TransfersApiApiV1TransfersDetailsPostRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiV1TransfersDetailsPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersDetailsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get cryptocurrency transfers, such as transfers on a cryptocurrency wallet, or  deposit/withdrawal transfers on an cryptocurrency exchange account.
     * @summary List transfers
     * @param {TransfersApiApiV1TransfersListPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiV1TransfersListPost(requestParameters: TransfersApiApiV1TransfersListPostRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiV1TransfersListPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersListPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange.
     * @summary Initiate a transfer
     * @param {TransfersApiApiV1TransfersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiV1TransfersPost(requestParameters: TransfersApiApiV1TransfersPostRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiV1TransfersPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple  blockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.
     * @summary Get details of asset
     * @param {TransfersApiApiV1TransfersSymbolDetailsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransfersApi
     */
    public apiV1TransfersSymbolDetailsPost(requestParameters: TransfersApiApiV1TransfersSymbolDetailsPostRequest, options?: AxiosRequestConfig) {
        return TransfersApiFp(this.configuration).apiV1TransfersSymbolDetailsPost(requestParameters.xClientId, requestParameters.xClientSecret, requestParameters.apiV1TransfersAddressGetPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


