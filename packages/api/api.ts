/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export interface ApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
}

export type ApiResultStatus =
  | 'ok'
  | 'serverFailure'
  | 'permissionDenied'
  | 'badRequest'
  | 'notFound'
  | 'conflict'
  | 'tooManyRequest'
  | 'locked'

export interface Asset {
  symbol?: string | null
  name?: string | null
  type?: 'equity' | 'cryptocurrency'
}

export interface AssetPaginationResponse {
  /** list of items */
  items?: Asset[] | null
  /**
   * Total number of items
   * @format int32
   */
  total?: number
}

export interface AssetPaginationResponseIApiResult {
  readonly content?: AssetPaginationResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export type AssetType = 'equity' | 'cryptocurrency'

export interface AssetWeight {
  symbol?: string | null
  /** @format double */
  weight?: number
  isCrypto?: boolean | null
}

export interface AuthenticationFieldDescription {
  /** Name of the field, as expected from the API */
  name?: string | null
  description?: string | null
}

export interface AuthenticationModel {
  authResponse?: B2BBrokerAuthResponse | null
  /** Set of fields that are expected to be provided based on the status of the AuthResponse */
  fields?: AuthenticationFieldDescription[] | null
}

export type AuthenticationSchemeType = 'usernamePassword' | 'oAuth' | 'apiKey' | 'blockchainAddress'

export type B2BAssetType = 'equity' | 'cryptocurrency' | 'option' | 'nft'

export interface B2BBrokerAccountBalance {
  /**
   * Withdrawable cash amount on the account.
   * @format double
   */
  cash?: number | null
  /**
   * Buying power indicating the maximum amount the user can spend to buy assets. E.g. available margin.
   * @format double
   */
  buyingPower?: number | null
  /**
   * Buying power available for placing cryptocurrency orders.
   * @format double
   */
  cryptocurrencyBuyingPower?: number | null
  /** ISO 4217 currency code. */
  currencyCode?: string | null
}

export interface B2BBrokerAccountBalanceModel {
  balances?: B2BBrokerAccountBalance[] | null
}

export interface B2BBrokerAccountBalanceModelIApiResult {
  readonly content?: B2BBrokerAccountBalanceModel | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerAuthPromptResponse {
  status?: 'failed' | 'redirect' | 'openInBrokerModule'
  redirectLink?: string | null
  linkToken?: string | null
  oAuthToken?: string | null
  errorMessage?: string | null
  displayMessage?: string | null
}

export interface B2BBrokerAuthPromptResponseIApiResult {
  readonly content?: B2BBrokerAuthPromptResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerAuthRequest {
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  username?: string | null
  password?: string | null
  tradePin?: string | null
  challengeId?: string | null
  challengeCode?: string | null
  /** Used to provide answers to security questions */
  challengeAnswer?: string | null
  mfaCode?: string | null
  mfaType?: 'phone' | 'email' | 'totp' | 'phoneAndEmail' | 'requireNextSecurityQuestion' | 'readEmail'
  key?: string | null
  authToken?: string | null
  redirectLink?: string | null
  confirmationEmail?: string | null
  cryptocurrencyWalletAuthData?: B2BBrokerCryptocurrencyWalletAuthRequest | null
}

export interface B2BBrokerAuthResponse {
  /** Status of the request */
  status?:
    | 'failed'
    | 'challengeFailed'
    | 'succeeded'
    | 'challengeIssued'
    | 'mfaRequired'
    | 'openInBrokerModule'
    | 'delayed'
    | 'deviceConfirmationRequired'
    | 'emailVerification'
    | 'emailReceived'
    | 'captchaChallenge'
  mfaType?: MfaType | null
  /** Id of the challenge, relevant when the status is `ChallengeIssued` */
  challengeId?: string | null
  challengeText?: string | null
  /**
   * Life span of the challenge
   * @format int32
   */
  challengeExpiresInSeconds?: number | null
  errorMessage?: string | null
  displayMessage?: string | null
  accessToken?: string | null
  refreshToken?: string | null
  /** @format int32 */
  expiresInSeconds?: number | null
  /** @format int32 */
  refreshTokenExpiresInSeconds?: number | null
  account?: BrokerAccount | null
  brokerBrandInfo?: BrokerBrandInfo | null
  accountTokens?: BrokerAccountTokens[] | null
  requiresReauthentication?: boolean | null
  email?: string | null
}

export interface B2BBrokerAuthResponseIApiResult {
  readonly content?: B2BBrokerAuthResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export type B2BBrokerAuthStatus = 'failed' | 'succeeded' | 'mfaRequired'

export interface B2BBrokerCreateCryptocurrencyTransactionResponse {
  /** Transaction Id by the financial institution */
  transactionId?: string | null
  failed?: boolean
  /** Status of the operation */
  status?:
    | 'unknown'
    | 'failed'
    | 'frozen'
    | 'succeeded'
    | 'mfaRequired'
    | 'pending'
    | 'expired'
    | 'canceled'
    | 'waitingForSignature'
    | 'waitingForClearing'
    | 'awaitingApproval'
    | 'awaitingConfirmation'
    | 'awaitingVerification'
    | 'rejected'
    | 'pendingCancel'
    | 'emailVerification'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
  /** Details of the current status of the transfer, as provided by the financial institution */
  statusDetails?: string | null
  /** Details of the created transaction */
  transaction?: B2BBrokerCryptocurrencyTransaction | null
}

export interface B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult {
  readonly content?: B2BBrokerCreateCryptocurrencyTransactionResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerCreateOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /**
   * Symbol to trade. For example, `AAPL` or `ETH`
   * @minLength 1
   */
  symbol: string
  /**
   * Symbol to use for payment, defaults to `USD`.
   * @minLength 1
   */
  paymentSymbol: string
  /**
   * Amount of purchase.
   * @format double
   */
  amount: number
  /**
   * Price of the unit, used for `Limit` and `StopLoss` orders.
   * @format double
   */
  price?: number
  /** Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly. */
  isCryptocurrency: boolean
  /** Indicates whether the `PaymentSymbol` is fiat or cryptocurrency */
  paymentIsCryptocurrency: boolean
  /** @deprecated */
  amountIsFiat?: boolean | null
  /**
   * @deprecated
   * @format double
   */
  amountInFiat?: number | null
  /**
   * This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
   * performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
   * `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
   * value is passed.
   */
  amountIsInPaymentSymbol: boolean
  /**
   * Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
   * and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
   * @format double
   */
  amountInPaymentSymbol?: number | null
  /** Specifies if the extended trading hours should be used. */
  extendedHours?: boolean
  orderType:
    | 'unknown'
    | 'market'
    | 'limit'
    | 'stopLoss'
    | 'stopLimit'
    | 'takeProfit'
    | 'netDebit'
    | 'netCredit'
    | 'exercise'
  timeInForce: 'goodTillCanceled' | 'immediateOrCancel' | 'fillOrKill' | 'goodForDay' | 'postOnly' | 'unknown'
  /** MFA Code to create an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
}

export interface B2BBrokerCreateOrderResult {
  /** Id of the order, as returned from the financial institution. Can be used to get the status of the order. */
  orderId?: string | null
  /** Type of the institution. */
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** Side of the order. */
  side?: 'unknown' | 'buy' | 'sell'
  /**
   * Amount of the order.
   * @format double
   */
  amount?: number
  /**
   * Unit price of the asset.
   * @format double
   */
  price?: number | null
  /**
   * Total value of the order.
   * @format double
   */
  value?: number | null
  /**
   * Optional Fee taken by the financial institution.
   * @format double
   */
  fee?: number | null
  /**
   * Timestamp of the order.
   * @format int64
   */
  timestamp?: number
  /** Status of the order. */
  status?: 'unknown' | 'inProgress' | 'cancelled' | 'rejected' | 'failed' | 'success' | 'partiallyFilled' | 'expired'
  /** Text details of the order, if additionally returned from the financial institution. */
  statusDetails?: string | null
  /** Value that indicates how long the order will remain active before it is executed or expires. */
  timeInForce?: BrokerOrderTimeInForceType | null
  /** Optional pair of symbols, as returned from the financial institution. Can be required to obtain the status of the order by some institutions. */
  symbolPair?: string | null
  /** Id of the parent order, applicable to some institutions if the order was executed in several trades. */
  parentOrderId?: string | null
  /** List of trades, provided only if the order was executed in several trades. */
  trades?: B2BBrokerOrderTrade[] | null
  /** A message describing the error if the order wasn't placed. */
  errorMessage?: string | null
  /** A user-friendly display message that can be presented to the end user. */
  displayMessage?: string | null
}

export interface B2BBrokerCreateOrderResultIApiResult {
  readonly content?: B2BBrokerCreateOrderResult | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerCryptocurrencyDepositAddressResponse {
  symbol?: string | null
  address?: string | null
  chain?: string | null
  memo?: string | null
  minimumDepositAmount?: string | null
  /** @format uuid */
  networkId?: string | null
  brokerResponseStatus?: BrokerResponseStatus | null
  errorMessage?: string | null
}

export interface B2BBrokerCryptocurrencyDepositAddressResponseIApiResult {
  readonly content?: B2BBrokerCryptocurrencyDepositAddressResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerCryptocurrencySymbolDetailsResponse {
  /** Requested symbol */
  symbol?: string | null
  /** Supported address types */
  addressTypes?: CryptocurrencyAddressType[] | null
  /** Supported chains. One of the values should be provided to execute transfers */
  chains?: BrokerCryptocurrencyChain[] | null
}

export interface B2BBrokerCryptocurrencySymbolDetailsResponseIApiResult {
  readonly content?: B2BBrokerCryptocurrencySymbolDetailsResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerCryptocurrencyTransaction {
  /** Identifier of the transfer, if provided by the financial institution */
  id?: string | null
  /** Current status of the transaction */
  status?:
    | 'unknown'
    | 'failed'
    | 'frozen'
    | 'succeeded'
    | 'mfaRequired'
    | 'pending'
    | 'expired'
    | 'canceled'
    | 'waitingForSignature'
    | 'waitingForClearing'
    | 'awaitingApproval'
    | 'awaitingConfirmation'
    | 'awaitingVerification'
    | 'rejected'
    | 'pendingCancel'
    | 'emailVerification'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
  /** Details of the current status of the transfer, as provided by the financial institution */
  statusDetails?: string | null
  /** The direction of the transaction */
  type?: 'unknown' | 'deposit' | 'withdrawal'
  /** Address where the transaction was sent from */
  fromAddress?: string | null
  /** Address where the transaction was sent to */
  targetAddress?: string | null
  /** Ticker of the transaction */
  symbol?: string | null
  /** Crypto Chain the transaction belongs to */
  chain?: string | null
  /** Memo of the transaction (also called "Tag") */
  memo?: string | null
  /** Hash of the transaction */
  hash?: string | null
  /**
   * Full amount affected the balance, typically transaction amount plus fee
   * @format double
   */
  amount?: number
  /**
   * Transaction amount
   * @format double
   */
  transactionAmount?: number | null
  /**
   * Unix timestamp in seconds indicating when the transaction was created
   * @format int64
   */
  createdTimestamp?: number
  /**
   * Unix timestamp in seconds indicating when the transaction was last updated
   * @format int64
   */
  updatedTimestamp?: number
  /** Fee taken by the network */
  networkTransactionFee?: BrokerCryptocurrencyTransactionNetworkFee | null
  /**
   * Fee taken by the financial institution
   * @format double
   */
  transferFee?: number | null
  /**
   * Number of confirmations on the blockchain
   * @format int64
   */
  confirmations?: number | null
  /** Name of the executed blockchain function based on decoded input data */
  blockchainMethodName?: string | null
  /** Executed blockchain function based on decoded input data. Not guaranteed to be identified */
  blockchainMethod?:
    | 'transfer'
    | 'swap'
    | 'mint'
    | 'withdraw'
    | 'claimRewards'
    | 'deposit'
    | 'approve'
    | 'forgeToken'
    | 'multicall'
    | 'migrateToken'
    | 'claim'
    | 'openSeaTransfer'
    | 'cancel'
    | 'commit'
    | 'run'
    | 'repay'
    | 'execute'
    | 'stake'
    | 'merge'
}

export interface B2BBrokerCryptocurrencyTransactionIApiResult {
  readonly content?: B2BBrokerCryptocurrencyTransaction | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerCryptocurrencyWalletAuthRequest {
  /** Symbol to connect */
  symbol?: string | null
  /** Blockchain to connect to */
  cryptocurrencyAddressType?: CryptocurrencyAddressType | null
  /** Optional wallet type */
  cryptocurrencyWalletType?: CryptocurrencyWalletType | null
}

export interface B2BBrokerOptionData {
  /** Type of option */
  optionType?: 'unknown' | 'call' | 'put'
  /** Direction of option */
  direction?: 'unknown' | 'buyToOpen' | 'buyToClose' | 'sellToOpen' | 'sellToClose' | 'buyToCover' | 'sellShort'
  /**
   * Option strike price
   * @format double
   */
  strikePrice?: number
  /**
   * Option expiration timestamp
   * @format int64
   */
  expirationTimestamp?: number
  /**
   * Number of shares covered by option
   * @format double
   */
  numberOfSharesInContract?: number
  /** Option complex order strategy type */
  complexOrderStrategyType?: string | null
}

export interface B2BBrokerOrder {
  /** Transaction id, as provided by the institution */
  id?: string | null
  /** Side of the transaction */
  side?: 'unknown' | 'buy' | 'sell'
  /** Traded symbol */
  symbol?: string | null
  /** Name of the traded asset */
  name?: string | null
  /** Type of the traded asset */
  assetType?: 'equity' | 'cryptocurrency' | 'option' | 'nft'
  /**
   * Fiat or cryptocurrency symbol used for payment. For transactions with types `ConversionFrom` or `ConversionTo`
   * this field specifies the target symbol. For example, for `ETH` to `BTC` conversion, the transaction type is `ConversionTo`, the `Symbol` field is `ETH` and the `PaymentSymbol` is `BTC`
   */
  paymentSymbol?: string | null
  /** Indicates if the payment was performed with fiat or crypto currency */
  paymentType?: 'fiat' | 'cryptocurrency'
  /**
   * Executed amount
   * @format double
   */
  amount?: number | null
  /**
   * Price of the unit
   * @format double
   */
  price?: number | null
  /**
   * Order Fee, taken by the financial institution
   * @format double
   */
  fee?: number | null
  /**
   * Total value
   * @format double
   */
  value?: number | null
  /**
   * Unix timestamp in seconds indicating when the order was placed or the transaction was created
   * @format int64
   */
  createdTimestamp?: number
  /**
   * Unix timestamp in seconds indicating when the transaction was last updated (e.g. executed)
   * @format int64
   */
  updatedTimestamp?: number
  /** Status of the transaction */
  status?: 'unknown' | 'inProgress' | 'cancelled' | 'rejected' | 'failed' | 'success' | 'partiallyFilled' | 'expired'
  /** Status text, as provided by the institution */
  statusDetails?: string | null
  /** Type of the placed order */
  orderType?: BrokerOrderPlaceType | null
  /** Time in force of the order: a value indicating how long the order remains active before it is executed or expires */
  timeInForce?: BrokerOrderTimeInForceType | null
  /** Type of the integration */
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** Type of the transaction */
  transactionType?:
    | 'order'
    | 'conversionTo'
    | 'conversionFrom'
    | 'ownAccountDeposit'
    | 'ownAccountWithdraw'
    | 'stake'
    | 'dividendReinvestment'
    | 'interest'
    | 'reward'
    | 'unknown'
    | 'conversionToFiat'
    | 'conversionFromFiat'
  /** Id of the parent order, applicable to some institutions */
  parentOrderId?: string | null
  /** Additional details for options */
  optionDetails?: B2BBrokerOptionData | null
}

export interface B2BBrokerOrderIApiResult {
  readonly content?: B2BBrokerOrder | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerOrderListRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /**
   * The cursor to retrieve the next page of transactions.
   * Providing it will cause the response to only return changes after this update.
   * If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
   */
  cursor?: string | null
  /**
   * Number of records to include in the response. <br />
   * Default: `100` <br />
   * Maximum: `250`
   * @format int32
   */
  count?: number
  /** Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned. */
  statuses?: BrokerOrderStatus[] | null
  /**
   * Return orders created after this timestamp.
   * If this field is not provided, orders with any creation timestamp will be returned.
   * @format int64
   */
  from?: number | null
}

export interface B2BBrokerOrderListResponse {
  /** List of obtained transactions. */
  transactions?: B2BBrokerOrder[] | null
  /** The cursor to retrieve the next page of transactions. */
  cursor?: string | null
  /**
   * Total amount of records.
   * @format int64
   */
  total?: number
  /**
   * Earliest transaction timestamp.
   * @format int64
   */
  earliestTimestamp?: number
}

export interface B2BBrokerOrderListResponseIApiResult {
  readonly content?: B2BBrokerOrderListResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export type B2BBrokerOrderPaymentSymbolType = 'fiat' | 'cryptocurrency'

export interface B2BBrokerOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** @minLength 1 */
  id: string
  /** Should be provided for Coinbase. */
  side?: BrokerOrderType | null
  /** Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought. */
  isCryptocurrency: boolean
  /** Symbol pair of the order (requested by some brokers). */
  symbolPair?: string | null
  /** MFA Code to cancel an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
}

export interface B2BBrokerOrderSymbolInfo {
  /** Specifies if the fractional trading is allowed for the provided symbol */
  fractionalTradingAllowance?:
    | 'fractionalTradingAllowed'
    | 'fractionalTradingNotAllowed'
    | 'tradingNotAllowed'
    | 'fractionalTradingPossiblyAllowed'
  /**
   * Minimum allowed order value
   * @format double
   */
  minimumOrderValue?: number
  /**
   * Maximum number of decimal digits accepted by the symbol
   * @format int32
   */
  precisionScale?: number | null
}

export interface B2BBrokerOrderSymbolInfoIApiResult {
  readonly content?: B2BBrokerOrderSymbolInfo | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerOrderTrade {
  tradeId?: string | null
  /** @format double */
  amount?: number | null
  /** @format double */
  value?: number | null
  /** @format double */
  price?: number | null
  /** @format double */
  fee?: number | null
  orderCategory?: 'order' | 'trade' | 'ledger' | 'historyAction'
}

export interface B2BBrokerPortfolioModel {
  /** Status of the request to the institution's API */
  status?: 'succeeded' | 'failed' | 'notAuthorized'
  /** Error message specifying the problem */
  errorMessage?: string | null
  /** User-friendly error message, optimized to be shown to the end user */
  displayMessage?: string | null
  /** Equity holdings, such as stocks and ETFs */
  equityPositions?: B2BPosition[] | null
  /** The equity positions Front could not recognize */
  notSupportedEquityPositions?: B2BPosition[] | null
  /** The cryptocurrency positions Front could not recognize */
  notSupportedCryptocurrencyPositions?: B2BPosition[] | null
  /** Cryptocurrency holdings on the account */
  cryptocurrencyPositions?: B2BPosition[] | null
  /** NFT holdings on the account */
  nftPositions?: B2BNftPosition[] | null
  /** Option holdings on the account */
  optionPositions?: B2BOptionPosition[] | null
  /** Type of the institution */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** External institution's account id (returned by the institution) */
  accountId?: string | null
  /** Friendly name of the connected institution */
  institutionName?: string | null
  /** Name of the account as returned from the institution */
  accountName?: string | null
}

export interface B2BBrokerPortfolioModelIApiResult {
  readonly content?: B2BBrokerPortfolioModel | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerPreviewOrderResult {
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** @format double */
  fee?: number | null
  feeText?: string | null
  /** @format double */
  amount?: number
  side?: 'unknown' | 'buy' | 'sell'
  status?: 'success' | 'failed'
  errorMessage?: string | null
  paymentSymbol?: string | null
  paymentIsCryptocurrency?: boolean
  /** @format double */
  estimatedUnitPrice?: number | null
}

export interface B2BBrokerPreviewOrderResultIApiResult {
  readonly content?: B2BBrokerPreviewOrderResult | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerRefreshTokenResponse {
  status?: 'failed' | 'succeeded' | 'mfaRequired'
  errorMessage?: string | null
  displayMessage?: string | null
  accessToken?: string | null
  refreshToken?: string | null
  /** @format int32 */
  expiresInSeconds?: number | null
  /** @format int32 */
  refreshTokenExpiresInSeconds?: number | null
  brokerAccountTokens?: BrokerAccountTokens[] | null
}

export interface B2BBrokerRefreshTokenResponseIApiResult {
  readonly content?: B2BBrokerRefreshTokenResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerSymbolInfoForOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /**
   * Symbol to trade. For example, `AAPL` or `ETH`
   * @minLength 1
   */
  symbol: string
  /**
   * Symbol to use for payment, defaults to `USD`.
   * @minLength 1
   */
  paymentSymbol: string
  /**
   * Amount of purchase.
   * @format double
   */
  amount: number
  /**
   * Price of the unit, used for `Limit` and `StopLoss` orders.
   * @format double
   */
  price?: number
  /** Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly. */
  isCryptocurrency: boolean
  /** Indicates whether the `PaymentSymbol` is fiat or cryptocurrency */
  paymentIsCryptocurrency: boolean
  /** @deprecated */
  amountIsFiat?: boolean | null
  /**
   * @deprecated
   * @format double
   */
  amountInFiat?: number | null
  /**
   * This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
   * performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
   * `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
   * value is passed.
   */
  amountIsInPaymentSymbol: boolean
  /**
   * Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
   * and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
   * @format double
   */
  amountInPaymentSymbol?: number | null
  /** Specifies if the extended trading hours should be used. */
  extendedHours?: boolean
  orderType:
    | 'unknown'
    | 'market'
    | 'limit'
    | 'stopLoss'
    | 'stopLimit'
    | 'takeProfit'
    | 'netDebit'
    | 'netCredit'
    | 'exercise'
  timeInForce: 'goodTillCanceled' | 'immediateOrCancel' | 'fillOrKill' | 'goodForDay' | 'postOnly' | 'unknown'
  /** MFA Code to create an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
  side?: BrokerOrderType | null
}

export interface B2BBrokerTradingFeature {
  supported?: boolean
  supportsFiatCurrencyPayment?: boolean
  supportsCryptocurrencyPayment?: boolean
  supportsMarginOrders?: boolean
  supportedCryptocurrencySymbols?: string[] | null
  supportedCryptocurrencySymbolsForPayment?: string[] | null
  supportedFiatCurrencies?: string[] | null
  marketType?: B2BBrokerTradingFeatureOrderType | null
  limitType?: B2BBrokerTradingFeatureOrderType | null
  stopLossType?: B2BBrokerTradingFeatureOrderType | null
}

export interface B2BBrokerTradingFeatureInfo {
  /** Type of the integration. */
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** Account Id of the integration. */
  accountId?: string | null
  /** Model, describing the ability to place cryptocurrency orders. */
  cryptocurrencyOrders?: B2BBrokerTradingFeature | null
  /** Model, describing the ability to place equity orders. */
  stockOrders?: B2BBrokerTradingFeature | null
  /** Status of the request. */
  status?: 'succeeded' | 'failed' | 'notAuthorized'
  /**
   * Indicates if the preview of orders (`preview order execution` endpoint) is provided by the institution.
   * This allows to validate the order using the API of the institution. If the order preview is not supported,
   * Front API validates the order without calling the institution's API.
   */
  supportsOrderPreview?: boolean
  /** Supports getting price information directly from the institution. */
  supportsPriceQuotes?: boolean
  /** Indicates if it is possible to cancel the placed order, while it's in the `InProgress` status. */
  supportsOrderCancellation?: boolean
  /** Indicates if the integration is available. */
  isIntegrationUp?: boolean
  /** Indicates if trading is generally supported at this time. */
  isTradingSupported?: boolean
  /** List of fiat balances of the account. */
  fiatBalances?: B2BBrokerAccountBalance[] | null
  /**
   * Limit for history records
   * @format int32
   */
  historyRecordLimit?: number | null
}

export interface B2BBrokerTradingFeatureInfoIApiResult {
  readonly content?: B2BBrokerTradingFeatureInfo | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokerTradingFeatureOrderType {
  /** Specifies if this order type is supported for this integration. */
  supported?: boolean
  /** Specifies if this order type supports buying or selling in fractional amounts. If this value is `false`, then only whole shares can be traded. */
  supportsFractionalShares?: boolean
  /** Indicates if pre-market trading or after-hours trading is supported. */
  supportsExtendedMarketHours?: boolean
  /** @deprecated */
  readonly supportsPlacingBuyOrdersInFiatAmount?: boolean
  /** @deprecated */
  readonly supportsPlacingSellOrdersInFiatAmount?: boolean
  /** The list of supported Time-in-force instructions for this order type. */
  supportedTimeInForceList?: BrokerOrderTimeInForceType[] | null
  /**
   * Specifies if this order type supports placing buy orders in payment/quote symbol amounts. For example,
   * if payment/quote symbol is USD, and this capability is supported, then the API can be instructed to buy asset for $10 or other dollar amount.
   */
  supportsPlacingBuyOrdersInPaymentSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing sell orders in payment/quote symbol amounts. For example,
   * if payment/quote symbol is USD, and this capability is supported, then the API can be instructed to sell asset for $10 or other dollar amount.
   */
  supportsPlacingSellOrdersInPaymentSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing buy orders in base symbol amounts. For example,
   * if payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to buy 1 or other amount of AAPL.
   */
  supportsPlacingBuyOrdersInBaseSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing sell orders in base symbol amounts. For example,
   * if payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to sell 1 or other amount of AAPL.
   */
  supportsPlacingSellOrdersInBaseSymbolAmount?: boolean
}

export interface B2BBrokerTransactionsListModel {
  /** List of obtained transfers. */
  transfers?: B2BBrokerCryptocurrencyTransaction[] | null
  /**
   * Total amount of records.
   * @format int64
   */
  total?: number
  /** The cursor to retrieve the next page of transfers. */
  cursor?: string | null
  /**
   * Earliest transfer timestamp.
   * @format int64
   */
  earliestTimestamp?: number
}

export interface B2BBrokerTransactionsListModelIApiResult {
  readonly content?: B2BBrokerTransactionsListModel | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BBrokersHealthStatus {
  /** Type of the integration */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** Is the communication with the integration up */
  isUp?: boolean
  /** Description of the outage */
  description?: string | null
  /**
   * Unix timestamp in seconds indicating when the outage occurred
   * @format int64
   */
  downTimeStart?: number | null
  /**
   * Unix timestamp in seconds indicating expected end of the outage
   * @format int64
   */
  downTimeEnd?: number | null
  /** Get products supported by the financial institution */
  supportedProducts?: BrokerFeature[] | null
}

export interface B2BBrokersHealthStatusListIApiResult {
  readonly content?: B2BBrokersHealthStatus[] | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BFiatPortfolioModel {
  /** List of aggregated fiat balances */
  fiatBalances?: PortfolioFiatBalance[] | null
}

export interface B2BFiatPortfolioModelIApiResult {
  readonly content?: B2BFiatPortfolioModel | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BNftPosition {
  /** @format double */
  amount?: number
  /** @format double */
  costBasis?: number | null
  contractAddress?: string | null
  name?: string | null
  description?: string | null
  /** @format int64 */
  marketplaceId?: number
  tokenId?: string | null
  marketplacePermalink?: string | null
  addressType?:
    | 'ethAddress'
    | 'btcAddress'
    | 'ltcAddress'
    | 'solAddress'
    | 'algoAddress'
    | 'celoAddress'
    | 'cardanoAddress'
    | 'polygonAddress'
    | 'bnbAddress'
    | 'elrondAddress'
    | 'neoAddress'
    | 'xrpAddress'
    | 'flowAddress'
    | 'harmonyOneAddress'
    | 'tronAddress'
    | 'dogeAddress'
}

export interface B2BOptimizedPortfolio {
  /** @format double */
  annualizedStandardDeviation?: number
  /** @format double */
  performance?: number
  assetWeights?: AssetWeight[] | null
  /** @format double */
  value?: number
  chartItems?: ChartItem[] | null
}

export interface B2BOptionPosition {
  /** Symbol of the underlying stock */
  symbol?: string | null
  /**
   * Amount of options
   * @format double
   */
  amount?: number
  /**
   * Total average paid price
   * @format double
   */
  averageOpenPrice?: number
  /** Side of the option, buy or sell */
  direction?: 'unknown' | 'buyToOpen' | 'buyToClose' | 'sellToOpen' | 'sellToClose' | 'buyToCover' | 'sellShort'
  /** @format int64 */
  createdTimestamp?: number
  /** @format int64 */
  updatedTimestamp?: number
  /**
   * Number of shares of the underlying stock
   * @format double
   */
  numberOfSharesInContract?: number
  /** Type of the option, put or call */
  optionType?: 'unknown' | 'call' | 'put'
  /**
   * The last day that the option contract is valid
   * @format int64
   */
  expirationTimestamp?: number
  /**
   * The price at which a put or call option can be exercised
   * @format double
   */
  strikePrice?: number
}

export interface B2BOriginalPortfolio {
  /** @format double */
  annualizedStandardDeviation?: number
  /** @format double */
  performance?: number
  assetWeights?: AssetWeight[] | null
  /** @format double */
  value?: number
  chartItems?: ChartItem[] | null
  /** @format double */
  startingValue?: number
}

export interface B2BPortfolioModel {
  /**
   * Amount of money spent to buy all positions of the portfolio.
   * @format double
   */
  portfolioCostBasis?: number | null
  /**
   * Actual performance based on the cost basis.
   * @format double
   */
  actualPortfolioPerformance?: number | null
  /**
   * Total USD portfolio value of all equities (sum(equity price * equity amount)). Does not include cash balance.
   * @format double
   */
  equitiesValue?: number
  /**
   * Total USD value of all cryptocurrencies in the portfolio.
   * @format double
   */
  cryptocurrenciesValue?: number
  /**
   * Total USD value of all NFTs in the portfolio.
   * @format double
   */
  nftsValue?: number
  /** List of equity positions */
  equityPositions?: B2BPositionWithMarketValues[] | null
  /** List of cryptocurrency positions */
  cryptocurrencyPositions?: B2BPositionWithMarketValues[] | null
  /** List of NFT positions */
  nftPositions?: NftPositionWithMarketValues[] | null
}

export interface B2BPortfolioModelIApiResult {
  readonly content?: B2BPortfolioModel | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BPortfolioOptimizationModel {
  originalPortfolio?: B2BOriginalPortfolio | null
  optimizedPortfolios?: B2BOptimizedPortfolio[] | null
}

export interface B2BPortfolioOptimizationModelIApiResult {
  readonly content?: B2BPortfolioOptimizationModel | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BPosition {
  /** Symbol of the asset */
  symbol?: string | null
  /**
   * Amount of the asset
   * @format double
   */
  amount?: number
  /**
   * The total original value (or purchase price) of the asset
   * @format double
   */
  costBasis?: number | null
}

export interface B2BPositionWithMarketValues {
  /** Symbol of the asset */
  symbol?: string | null
  /**
   * Amount of the asset
   * @format double
   */
  amount?: number
  /**
   * The total original value (or purchase price) of the asset
   * @format double
   */
  costBasis?: number | null
  /**
   * Market value of the asset: amount of asset multiplied by last asset value.
   * @format double
   */
  marketValue?: number | null
  /**
   * What percentage of total portfolio value is taken by this asset.
   * @format double
   */
  portfolioPercentage?: number | null
  /**
   * Total return of investment of this asset. Can be negative or null. Based on the cost basis of the asset, cost basis
   * is not available by some of integrations.
   * @format double
   */
  totalReturn?: number | null
  /**
   * Percent of return of investment for this asset. Can be negative or null.
   * @format double
   */
  returnPercentage?: number | null
  /**
   * Current last price of the asset.
   * @format double
   */
  lastPrice?: number | null
  /** Company name of the relative asset/ */
  companyName?: string | null
  /**
   * Total daily return of investment for this asset. Can be negative.
   * @format double
   */
  totalDailyReturn?: number | null
  /**
   * Daily percent of return of investment for this asset. Can be negative.
   * @format double
   */
  dailyReturnPercentage?: number | null
}

export interface B2BPriceInfo {
  /** @format double */
  price?: number
  /** @format int64 */
  timestamp?: number
}

export interface B2BPriceInfoIApiResult {
  readonly content?: B2BPriceInfo | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface B2BSymbolNewsData {
  /**
   * The identifier of the news item.
   * @format uuid
   */
  id?: string
  /** The title of the news. */
  title?: string | null
  /** The news content. */
  content?: string | null
  /** The url of the image related to th news. */
  imageUrl?: string | null
  /** The name of the news source. */
  source?: string | null
  /** The url of the news source. */
  sourceUrl?: string | null
  /**
   * The time of the creation of the news.
   * @format int64
   */
  createdTimestamp?: number
  /** The url where the news is available. */
  url?: string | null
  /**
   * Integer value which describes the relevance of the news in the Front system.
   * @format int32
   */
  rank?: number
  /** List of stock symbols mentioned in the news. */
  symbols?: string[] | null
  /** List of cryptocurrencies mentioned in the news. */
  cryptocurrencySymbols?: string[] | null
}

export type B2BSymbolNewsOrder = 'rank' | 'timestamp'

export interface B2BSymbolNewsResponse {
  /** The collection of news. */
  news?: B2BSymbolNewsData[] | null
  /**
   * The total count of news related to the symbol
   * @format int32
   */
  count?: number
}

export interface B2BSymbolNewsResponseIApiResult {
  readonly content?: B2BSymbolNewsResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export type B2BSymbolNewsSortingDirection = 'ascending' | 'descending'

export type B2BTransactionType =
  | 'order'
  | 'conversionTo'
  | 'conversionFrom'
  | 'ownAccountDeposit'
  | 'ownAccountWithdraw'
  | 'stake'
  | 'dividendReinvestment'
  | 'interest'
  | 'reward'
  | 'unknown'
  | 'conversionToFiat'
  | 'conversionFromFiat'

export interface BrokerAccount {
  accountId?: string | null
  accountName?: string | null
  /**
   * Buying power of the account. Typically consists of cash plus available margin.
   * For non-margin accounts fund contains cash only
   * @format double
   */
  fund?: number | null
  /**
   * Cash balance in USD
   * @format double
   */
  cash?: number | null
  /**
   * Indicates if this account was already connected by the current user and device.
   * Can be null.
   */
  isReconnected?: boolean | null
  /** The list of all asset balances of account */
  balances?: BrokerFiatBalance[] | null
}

export interface BrokerAccountTokens {
  account?: BrokerAccount | null
  accessToken?: string | null
  refreshToken?: string | null
}

export type BrokerAuthPromptStatus = 'failed' | 'redirect' | 'openInBrokerModule'

export type BrokerAuthStatus =
  | 'failed'
  | 'challengeFailed'
  | 'succeeded'
  | 'challengeIssued'
  | 'mfaRequired'
  | 'openInBrokerModule'
  | 'delayed'
  | 'deviceConfirmationRequired'
  | 'emailVerification'
  | 'emailReceived'
  | 'captchaChallenge'

export interface BrokerAuthenticationScheme {
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** Type of authentication for the integration. */
  authenticationSchemeType?: 'usernamePassword' | 'oAuth' | 'apiKey' | 'blockchainAddress'
  /** Set of fields that should be provided in the initial POST `authenticate` request. */
  initialAuthenticationModel?: AuthenticationModel | null
  /** Set of fields that should be provided depending on the status of the response of the first POST `authenticate` request. */
  authenticationSteps?: AuthenticationModel[] | null
  /** Supported MFA schemes, can be none or multiple. */
  mfaSchemes?: MfaScheme[] | null
  /** Optional URL with the instructions explaining how to create a set of API key/secret for the integration, can be shown to the end user. */
  instructionsUrl?: string | null
}

export interface BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult {
  readonly content?: BrokerAuthenticationScheme[] | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface BrokerBaseRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
}

export interface BrokerBrandInfo {
  brokerLogo?: string | null
  brokerPrimaryColor?: string | null
}

export interface BrokerCreateCryptocurrencyTransactionRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** Additional data to send on-chain (optional, depends on an integration) */
  data?: string | null
  /**
   * Target address to transfer the asset to
   * @minLength 1
   */
  targetAddress: string
  /**
   * Amount to transfer
   * @format double
   */
  amount?: number
  /**
   * On-chain fee (optional, depends on an integration)
   * @format double
   */
  fee?: number
  /**
   * Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.
   * Can be used instead of `Symbol` and `Chain` fields.
   * To transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.
   */
  addressType?: CryptocurrencyAddressType | null
  /** 2 Factor auth code (optional, depends on an integration) */
  mfaCode?: string | null
  /** Password or pass-phrase, required to send transfers (optional, depends on an integration) */
  password?: string | null
  /**
   * Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.
   * Can be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).
   * Please use `symbol/details` endpoint to get the list of all possible chains.
   */
  chain?: string | null
  /** Memo (also called "Tag") - address remark. */
  memo?: string | null
  /** Symbol to be transferred. Can be provided instead of the `AddressType` field. */
  symbol?: string | null
  challengeId?: string | null
}

export interface BrokerCryptocurrencyChain {
  /** Name of the chain, should be provided when initiating a transfer */
  chain?: string | null
  feeDescription?: string | null
  /** Notes or tips provided by the integration */
  notes?: string | null
  /** @format double */
  fee?: number | null
  /** @format uuid */
  networkId?: string | null
}

export interface BrokerCryptocurrencyDepositAddressRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /**
   * Symbol of the required cryptocurrency, e.g. ETH or BTC.
   * Can be used instead of the `AddressType` field.
   */
  symbol?: string | null
  /**
   * Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.
   * Can be used instead of `Symbol` field.
   */
  addressType?: CryptocurrencyAddressType | null
  /** Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni */
  chain?: string | null
  /** Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect */
  mfaCode?: string | null
}

export type BrokerCryptocurrencyTransactionBlockchainMethod =
  | 'transfer'
  | 'swap'
  | 'mint'
  | 'withdraw'
  | 'claimRewards'
  | 'deposit'
  | 'approve'
  | 'forgeToken'
  | 'multicall'
  | 'migrateToken'
  | 'claim'
  | 'openSeaTransfer'
  | 'cancel'
  | 'commit'
  | 'run'
  | 'repay'
  | 'execute'
  | 'stake'
  | 'merge'

export interface BrokerCryptocurrencyTransactionDetailsRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** Type of the address of the transferred asset. Can be used instead of the `Symbol` field. */
  addressType?: CryptocurrencyAddressType | null
  /** Transaction Id by the financial institution */
  transactionId?: string | null
  /** Hash of the transaction on the blockchain */
  transactionHash?: string | null
  /** Symbol of the transferred asset. Can be provided instead of the `AddressType` field. */
  symbol?: string | null
}

export interface BrokerCryptocurrencyTransactionNetworkFee {
  /** @format double */
  gasPrice?: number | null
  /** @format double */
  gasUsed?: number | null
  /** @format double */
  amount?: number | null
  symbol?: string | null
}

export type BrokerCryptocurrencyTransactionStatus =
  | 'unknown'
  | 'failed'
  | 'frozen'
  | 'succeeded'
  | 'mfaRequired'
  | 'pending'
  | 'expired'
  | 'canceled'
  | 'waitingForSignature'
  | 'waitingForClearing'
  | 'awaitingApproval'
  | 'awaitingConfirmation'
  | 'awaitingVerification'
  | 'rejected'
  | 'pendingCancel'
  | 'emailVerification'
  | 'deviceConfirmationRequired'
  | 'mfaFailed'

export type BrokerCryptocurrencyTransactionType = 'unknown' | 'deposit' | 'withdrawal'

export interface BrokerCryptocurrencyWalletListResponse {
  supportedCryptocurrencyWallets?: CryptocurrencyWalletDescription[] | null
  supportedCryptocurrencyAddresses?: CryptocurrencyWalletDescription[] | null
}

export interface BrokerCryptocurrencyWalletListResponseIApiResult {
  readonly content?: BrokerCryptocurrencyWalletListResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export type BrokerFeature =
  | 'holdings'
  | 'balance'
  | 'orders'
  | 'transfers'
  | 'identity'
  | 'cryptocurrencyDepositAddresses'
  | 'accountNumber'

export interface BrokerFiatBalance {
  /** Account balance currency */
  symbol?: string | null
  /**
   * BuyingPower indicates total amount of money the user can spend for buying stock. Always includes cash and
   * can also include margin
   * @format double
   */
  buyingPower?: number | null
  /**
   * BuyingPower indicates total amount of money the user can spend for buying crypto.
   * @format double
   */
  cryptoBuyingPower?: number | null
  /**
   * Account cash indicates total amount of money
   * @format double
   */
  cash?: number | null
}

export type BrokerOptionDirection =
  | 'unknown'
  | 'buyToOpen'
  | 'buyToClose'
  | 'sellToOpen'
  | 'sellToClose'
  | 'buyToCover'
  | 'sellShort'

export type BrokerOptionType = 'unknown' | 'call' | 'put'

export type BrokerOrderCategory = 'order' | 'trade' | 'ledger' | 'historyAction'

export type BrokerOrderPlaceType =
  | 'unknown'
  | 'market'
  | 'limit'
  | 'stopLoss'
  | 'stopLimit'
  | 'takeProfit'
  | 'netDebit'
  | 'netCredit'
  | 'exercise'

export type BrokerOrderStatus =
  | 'unknown'
  | 'inProgress'
  | 'cancelled'
  | 'rejected'
  | 'failed'
  | 'success'
  | 'partiallyFilled'
  | 'expired'

export type BrokerOrderTimeInForceType =
  | 'goodTillCanceled'
  | 'immediateOrCancel'
  | 'fillOrKill'
  | 'goodForDay'
  | 'postOnly'
  | 'unknown'

export type BrokerOrderType = 'unknown' | 'buy' | 'sell'

export type BrokerOrderValidationStatus = 'success' | 'failed'

export interface BrokerRefreshTokenRequest {
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** @minLength 1 */
  refreshToken: string
  /**
   * Optional, used when we the refresh token should be refreshed.
   * Currently this flow is supported by TD Ameritrade
   */
  createNewRefreshToken?: boolean | null
  /**
   * Some institutions may require accessToken to be provided as well.
   * It's currently required by WeBull and Vanguard
   */
  accessToken?: string | null
  /** Currently used to update WeBull trade token. */
  tradeToken?: string | null
  /** Optional, currently used by Vanguard if account has enforced MFA enabled. */
  mfaCode?: string | null
  /** Additional metadata */
  metadata?: Record<string, string | null>
}

export type BrokerRequestStatus = 'succeeded' | 'failed' | 'notAuthorized'

export type BrokerResponseStatus = 'unknown' | 'mfaRequired' | 'kycRequired'

export interface BrokerTransactionsListRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /**
   * Number of records to include in the response. <br />
   * Default: `100` <br />
   * Maximum: `250`
   * @format int32
   */
  count?: number
  /**
   * The cursor to retrieve the next page of transactions.
   * Providing it will cause the response to only return changes after this update.
   * If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
   */
  cursor?: string | null
  /** If this value is provided, result set is filtered to only include transaction with the provided statuses. */
  statuses?: BrokerCryptocurrencyTransactionStatus[] | null
  /** For cryptocurrency address the type of address is required. */
  cryptocurrencyAddressType?: CryptocurrencyAddressType | null
  /**
   * If this value is provided, result set is filtered to only include transactions created after this timestamp
   * @format int64
   */
  from?: number | null
}

export type BrokerType =
  | 'robinhood'
  | 'eTrade'
  | 'alpaca'
  | 'tdAmeritrade'
  | 'weBull'
  | 'stash'
  | 'interactiveBrokers'
  | 'public'
  | 'coinbase'
  | 'kraken'
  | 'coinbasePro'
  | 'cryptoCom'
  | 'openSea'
  | 'binanceUs'
  | 'gemini'
  | 'cryptocurrencyAddress'
  | 'cryptocurrencyWallet'
  | 'okCoin'
  | 'bittrex'
  | 'kuCoin'
  | 'etoro'
  | 'cexIo'
  | 'binanceInternational'
  | 'bitstamp'
  | 'gateIo'
  | 'celsius'
  | 'acorns'
  | 'okx'
  | 'bitFlyer'
  | 'coinlist'
  | 'huobi'
  | 'bitfinex'
  | 'deFiWallet'
  | 'krakenDirect'
  | 'vanguard'
  | 'binanceInternationalDirect'
  | 'bitfinexDirect'

export interface CatalogLink {
  /**
   * Url to open Front catalog that should be presented to the end user.
   * @format uri
   */
  url?: string | null
  /**
   * Url to open Front catalog in iFrame that should be presented to the end user.
   * @format uri
   */
  iFrameUrl?: string | null
}

export interface CatalogLinkIApiResult {
  readonly content?: CatalogLink | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface ChartItem {
  /** @format double */
  value?: number
  date?: string | null
}

export interface ConfigureTransferRequest {
  /**
   * The authentication token to send assets from.
   * @minLength 1
   */
  fromAuthToken: string
  /** The type of the integration to send assets from. */
  fromType:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /**
   * The authentication token of the target integration. Can be used alternatively to the list of requested address (`toAddresses`).
   * If used, `toType` should also be provided.
   */
  toAuthToken?: string | null
  /** The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `toAddresses`. */
  toType?: BrokerType | null
  /**
   * A list of available addresses provided by the API client. The list can contain all supported addresses by the client.
   * Front API validates the addresses and returns the list of supported tokens and networks as the result of the operation.
   */
  toAddresses?: TransferToAddress[] | null
  /** If provided, Front API returns only networks that support transferring of this symbol. */
  symbol?: string | null
  /**
   * If provided, Front API configures the response to only return holdings with enough amount of this crypto for the transfer
   * @format double
   */
  amount?: number | null
  /**
   * If provided, Front API configures the response to only contain holdings with enough value (converted to fiat) for the transfer.
   * @format double
   */
  amountInFiat?: number | null
  /** Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`. */
  fiatCurrency?: string | null
  /**
   * If provided, from API configures the response to include the requested network only.
   * @format uuid
   */
  networkId?: string | null
}

export interface ConfigureTransferResponse {
  /** Status of the operation. */
  status?:
    | 'succeeded'
    | 'failed'
    | 'validationFailed'
    | 'notAuthorizedTo'
    | 'notAuthorizedFrom'
    | 'kycRequired'
    | 'fromIntegrationNotSupported'
    | 'toIntegrationNotSupported'
  /** Error message, if the operation did not complete successfully. */
  errorMessage?: string | null
  /** List of holdings on the source account. */
  holdings?: ConfigureTransferResultHolding[] | null
}

export interface ConfigureTransferResponseIApiResult {
  readonly content?: ConfigureTransferResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface ConfigureTransferResultHolding {
  /** The symbol of the digital asset on the source account. */
  symbol?: string | null
  /**
   * The available balance of the digital asset.
   * @format double
   */
  availableBalance?: number
  /**
   * The available balance of the digital asset, converted to fiat currency.
   * @format double
   */
  availableBalanceInFiat?: number
  /** Specifies if the asset is eligible for a transfer. */
  eligibleForTransfer?: boolean
  /** Supported networks. */
  networks?: ConfigureTransferResultNetwork[] | null
  /** The reason indicating why the transfer of the current asset cannot be performed. */
  ineligibilityReason?: HoldingTransferIneligibilityReason | null
}

export interface ConfigureTransferResultNetwork {
  /** The name of the network. */
  name?: string | null
  /**
   * The Id of the network in Front system.
   * @format uuid
   */
  id?: string
  /**
   * Then minimum amount that can be withdrawn using this network.
   * @format double
   */
  minimumAmount?: number | null
  /**
   * The maximum amount that can be withdrawn using this network.
   * @format double
   */
  maximumAmount?: number | null
  /**
   * Total estimated transfer fee converted to fiat. Can consist of the fee taken by the financial institution and the
   * gas fee.
   * @format double
   */
  totalEstimatedTransferFeeInFiat?: number | null
  /**
   * The minimum amount that can be withdrawn using this network, converted to fiat currency.
   * @format double
   */
  minimumAmountInFiat?: number | null
  /**
   * The maximum amount that can be withdrawn using this network, converted to fiat currency.
   * @format double
   */
  maximumAmountInFiat?: number | null
  /**
   * The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be
   * covered by the `InstitutionTransferFee`.
   */
  estimatedNetworkGasFee?: TransferFee | null
  /**
   * The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not
   * take the transfer fee and only network fee is used for the transfer.
   */
  institutionTransferFee?: TransferFee | null
  /** Specifies if the asset is eligible for a transfer over the current network. */
  eligibleForTransfer?: boolean
  /** The reason indicating why the transfer cannot be performed over this network. */
  ineligibilityReason?: NetworkTransferIneligibilityReason | null
  /** The designated destination for sending the asset. */
  toAddress?: string | null
}

export type ConfigureTransferStatus =
  | 'succeeded'
  | 'failed'
  | 'validationFailed'
  | 'notAuthorizedTo'
  | 'notAuthorizedFrom'
  | 'kycRequired'
  | 'fromIntegrationNotSupported'
  | 'toIntegrationNotSupported'

export type CryptocurrencyAddressType =
  | 'ethAddress'
  | 'btcAddress'
  | 'ltcAddress'
  | 'solAddress'
  | 'algoAddress'
  | 'celoAddress'
  | 'cardanoAddress'
  | 'polygonAddress'
  | 'bnbAddress'
  | 'elrondAddress'
  | 'neoAddress'
  | 'xrpAddress'
  | 'flowAddress'
  | 'harmonyOneAddress'
  | 'tronAddress'
  | 'dogeAddress'

export interface CryptocurrencyCoinDescription {
  symbol?: string | null
  name?: string | null
}

export interface CryptocurrencyWalletDescription {
  cryptocurrencyWalletType?: CryptocurrencyWalletType | null
  cryptocurrencyAddressType?: CryptocurrencyAddressType | null
  supportedCryptocurrencies?: CryptocurrencyCoinDescription[] | null
}

export type CryptocurrencyWalletType =
  | 'coinbaseWallet'
  | 'metamask'
  | 'trustWallet'
  | 'myEtherWallet'
  | 'alphaWallet'
  | 'atomicWallet'

export interface ExecuteTransferRequest {
  /**
   * The authentication token to send the asset from.
   * @minLength 1
   */
  fromAuthToken: string
  /** The type of the integration to send the asset from. */
  fromType:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /**
   * Id of the Preview of the transfer.
   * @format uuid
   */
  previewId: string
  /** Multi-factor auth code that should be provided if the status of the transfer was `MfaRequired`. */
  mfaCode?: string | null
}

export interface ExecuteTransferResponse {
  /** The status of the transfer. */
  status?:
    | 'succeeded'
    | 'failed'
    | 'mfaRequired'
    | 'emailConfirmationRequired'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
  /** Error message, if the operation did not complete successfully. */
  errorMessage?: string | null
  /** Result of the transfer initiation. */
  executeTransferResult?: ExecuteTransferResultResponse | null
}

export interface ExecuteTransferResponseIApiResult {
  readonly content?: ExecuteTransferResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface ExecuteTransferResultResponse {
  /** The Id of the transfer by the integration. */
  transferId?: string | null
  /** The current status of the transfer. */
  status?:
    | 'unknown'
    | 'failed'
    | 'frozen'
    | 'succeeded'
    | 'mfaRequired'
    | 'pending'
    | 'expired'
    | 'canceled'
    | 'waitingForSignature'
    | 'waitingForClearing'
    | 'awaitingApproval'
    | 'awaitingConfirmation'
    | 'awaitingVerification'
    | 'rejected'
    | 'pendingCancel'
    | 'emailVerification'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
  /** Details of the current status of the transfer, as provided by the integration. */
  statusDetails?: string | null
  /** The address of the source account or wallet. */
  fromAddress?: string | null
  /** The address of the target account or wallet. */
  toAddress?: string | null
  /** Transferred symbol. */
  symbol?: string | null
  /** The name of the used network. */
  networkName?: string | null
  /**
   * The Id of the used network in Front system.
   * @format uuid
   */
  networkId?: string
  /** The hash of the blockchain transaction. */
  hash?: string | null
  /**
   * The transferred amount, in the symbol of the transfer.
   * @format double
   */
  amount?: number
  /**
   * The transferred amount, converted to the fiat currency.
   * @format double
   */
  amountInFiat?: number
  /**
   * Total amount of the transfer including all fees, converted to fiat.
   * @format double
   */
  totalAmountInFiat?: number
  /**
   * Current number of network confirmations.
   * @format int64
   */
  completedConfirmations?: number | null
  /** The fee that was taken by the institution. */
  institutionTransferFee?: TransferFee | null
  /**
   * The gas fee that was taken by the network. Depending on the integration, the network gas fee might be
   * covered by the `InstitutionTransferFee`.
   */
  networkGasFee?: TransferFee | null
}

export type ExecuteTransferStatus =
  | 'succeeded'
  | 'failed'
  | 'mfaRequired'
  | 'emailConfirmationRequired'
  | 'deviceConfirmationRequired'
  | 'mfaFailed'

export type HoldingTransferIneligibilityReason =
  | 'noEligibleNetworks'
  | 'symbolDoesNotMatch'
  | 'notSupportedForTransferByTarget'
  | 'notSupportedForTransferBySource'

export interface IApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface InitializeTransfersForLinkRequest {
  /**
   * The list of destination addresses with corresponding networks are asset symbols that
   * can be used to initiate incoming transfers.
   */
  toAddresses?: TransferToAddress[] | null
}

export interface IntegrationNetworkResponse {
  integrations?: IntegrationNetworksModelResponse[] | null
}

export interface IntegrationNetworkResponseIApiResult {
  readonly content?: IntegrationNetworkResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface IntegrationNetworksModelResponse {
  /** Type of the integration. */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /** The list of supported networks and corresponding tokens for the integration. */
  networks?: NetworkResponse[] | null
  /** Specifies if the integration supports outgoing transfers. */
  supportsOutgoingTransfers?: boolean
  /** Specifies if the integration supports incoming transfers. */
  supportsIncomingTransfers?: boolean
}

export type MfaScheme = 'mfaCode' | 'challenge' | 'deviceConfirmation' | 'securityQuestion'

export type MfaType = 'phone' | 'email' | 'totp' | 'phoneAndEmail' | 'requireNextSecurityQuestion' | 'readEmail'

export interface NetworkModelResponse {
  networks?: NetworkResponseWithIntegrations[] | null
}

export interface NetworkModelResponseIApiResult {
  readonly content?: NetworkModelResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface NetworkResponse {
  /**
   * The Id of the network in Front system. Should be used to initiate transfers.
   * @format uuid
   */
  id?: string
  /** The name if the network. */
  name?: string | null
  /** The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137. */
  chainId?: string | null
  /** The list of tokens that are currently supported to be transferred using the network. */
  supportedTokens?: string[] | null
}

export interface NetworkResponseWithIntegrations {
  /**
   * The Id of the network in Front system. Should be used to initiate transfers.
   * @format uuid
   */
  id?: string
  /** The name if the network. */
  name?: string | null
  /** The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137. */
  chainId?: string | null
  /** The list of tokens that are currently supported to be transferred using the network. */
  supportedTokens?: string[] | null
  /** The list of types of integrations that are currently supported to perform transfers over the network. */
  supportedBrokerTypes?: BrokerType[] | null
}

export type NetworkTransferIneligibilityReason =
  | 'amountNotSufficient'
  | 'gasFeeAssetBalanceNotEnough'
  | 'noTargetNetworkFound'
  | 'refusedByInstitution'

export type NftBlockchain = 'ethereum' | 'polygon' | 'klaytn'

export interface NftOrder {
  orderSide?: 'buy' | 'sell'
  symbol?: string | null
  /** @format double */
  price?: number
  /** @format double */
  priceUsd?: number | null
  /** @format double */
  amount?: number
  /** @format int64 */
  createdTimestamp?: number | null
  /** @format int64 */
  updatedTimestamp?: number | null
  symbolLogo?: string | null
}

export type NftOrderSide = 'buy' | 'sell'

export interface NftPositionWithMarketValues {
  /** @format double */
  amount?: number
  /** @format double */
  costBasis?: number | null
  contractAddress?: string | null
  paymentTokenSymbol?: string | null
  name?: string | null
  description?: string | null
  imageUrl?: string | null
  imageOriginalUrl?: string | null
  animationUrl?: string | null
  backgroundColor?: string | null
  /** @format int64 */
  marketplaceId?: number
  tokenId?: string | null
  /** @format int64 */
  numberOfSales?: number | null
  contractType?: string | null
  contractName?: string | null
  contractSchemaName?: string | null
  contractSymbol?: string | null
  contractDescription?: string | null
  marketplacePermalink?: string | null
  contractExternalLink?: string | null
  creatorAddress?: string | null
  currentOffer?: NftOrder | null
  lastSale?: NftOrder | null
  blockchain?: 'ethereum' | 'polygon' | 'klaytn'
  addressExplorerLink?: string | null
  twitterUsername?: string | null
  /**
   * Amount of NFTs multiplied by NFT value
   * @format double
   */
  marketValue?: number | null
  /**
   * What percentage of total portfolio value is taken by this NFT
   * @format double
   */
  portfolioPercentage?: number | null
}

export interface PortfolioFiatBalance {
  /** Balance currency */
  symbol?: string | null
  /**
   * Amount of money in a specific currency from all brokers
   * @format double
   */
  cash?: number | null
  /**
   * BuyingPower from all brokers, it indicates total amount of money the user can spend on buying stock.
   * Always includes cash and can also include margin
   * @format double
   */
  buyingPower?: number | null
}

export interface PreviewTransferRequest {
  /**
   * The authentication token to send the asset from.
   * @minLength 1
   */
  fromAuthToken: string
  /** The type of the integration to send the asset from. */
  fromType:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'celsius'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
  /**
   * The authentication token of the target integration. Can be used alternatively to the address in the `ToAddress` field.
   * If used, `toType` should also be provided.
   */
  toAuthToken?: string | null
  /** The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `ToAddress`. */
  toType?: BrokerType | null
  /**
   * The network to send the asset over.
   * @format uuid
   */
  networkId?: string
  /** The symbol of the digital asset to send. */
  symbol?: string | null
  /** The target address to send the asset to. */
  toAddress?: string | null
  /**
   * The amount to send, in crypto.
   * @format double
   */
  amount?: number | null
  /**
   * The amount to send, in fiat currency. Can be used alternatively to `Amount`.
   * @format double
   */
  amountInFiat?: number | null
  /** Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`. */
  fiatCurrency?: string | null
}

export interface PreviewTransferResponse {
  /** The status of the operation. */
  status?: 'succeeded' | 'failed'
  /** Error message, if the operation did not complete successfully. */
  errorMessage?: string | null
  /** Result of the preview. */
  previewResult?: PreviewTransferResult | null
}

export interface PreviewTransferResponseIApiResult {
  readonly content?: PreviewTransferResponse | null
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
  readonly message?: string | null
  readonly displayMessage?: string | null
}

export interface PreviewTransferResult {
  /**
   * The Id of the preview of the transfer. Should be used to commit the transfer using `Execute` endpoint.
   * @format uuid
   */
  previewId?: string
  /**
   * The period of time in seconds during which the transfer can be committed.
   * @format int32
   */
  previewExpiresIn?: number
  /** Obtained address that will be used to send the transfer. Not guaranteed to be returned by some of integrations. */
  fromAddress?: string | null
  /** The target address to send the asset to. */
  toAddress?: string | null
  /** Symbol of the asset to be sent. */
  symbol?: string | null
  /**
   * Amount in symbol. If the transfer was requested using `AmounInFiat` field, this field represents the exact amount
   * of the asset that will be transferred.
   * @format double
   */
  amount?: number
  /**
   * Transfer amount in fiat. If the transfer was requested in crypto amount using the `Amount` field,
   * this field contains the corresponding converted to fiat value.
   * @format double
   */
  amountInFiat?: number
  /**
   * Total estimated amount of the transfer including all fees, converted to fiat.
   * @format double
   */
  totalEstimatedAmountInFiat?: number
  /**
   * Id of the network in Front system.
   * @format uuid
   */
  networkId?: string
  /** Name of the network in Front system. */
  networkName?: string | null
  /** Blockchain address of the transferred token's contract */
  contractAddress?: string | null
  /**
   * The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not
   * take the transfer fee and only network fee is used for the transfer.
   */
  institutionTransferFee?: TransferFee | null
  /**
   * The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be
   * covered by the `InstitutionTransferFee`.
   */
  estimatedNetworkGasFee?: TransferFee | null
  /**
   * Number of decimal places used to represent the token's smallest unit
   * @format int32
   */
  decimalPlaces?: number | null
}

export type PreviewTransferStatus = 'succeeded' | 'failed'

export interface ProblemDetails {
  type?: string | null
  title?: string | null
  /** @format int32 */
  status?: number | null
  detail?: string | null
  instance?: string | null
  [key: string]: any
}

export type SymbolTradingAllowance =
  | 'fractionalTradingAllowed'
  | 'fractionalTradingNotAllowed'
  | 'tradingNotAllowed'
  | 'fractionalTradingPossiblyAllowed'

export interface TransferFee {
  /**
   * The amount of the fee.
   * @format double
   */
  fee?: number
  /** The currency of the fee. Does not match the currency of the transfer in some cases. */
  feeCurrency?: string | null
  /**
   * The value of the fee converted to the fiat currency.
   * @format double
   */
  feeInFiat?: number
}

export interface TransferToAddress {
  /**
   * The Id of the network in Front system. The list of all available networks can be obtained by using `GET /transfers/managed/networks` endpoint.
   * @format uuid
   */
  networkId?: string
  /** The symbol of the digital asset. */
  symbol?: string | null
  /** The address to send the asset to. */
  address?: string | null
}

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, HeadersDefaults, ResponseType } from 'axios'

export type QueryParamsType = Record<string | number, any>

export interface FullRequestParams extends Omit<AxiosRequestConfig, 'data' | 'params' | 'url' | 'responseType'> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean
  /** request path */
  path: string
  /** content type of request body */
  type?: ContentType
  /** query params */
  query?: QueryParamsType
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseType
  /** request body */
  body?: unknown
}

export type RequestParams = Omit<FullRequestParams, 'body' | 'method' | 'query' | 'path'>

export interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, 'data' | 'cancelToken'> {
  securityWorker?: (
    securityData: SecurityDataType | null
  ) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void
  secure?: boolean
  format?: ResponseType
}

export enum ContentType {
  Json = 'application/json',
  FormData = 'multipart/form-data',
  UrlEncoded = 'application/x-www-form-urlencoded',
  Text = 'text/plain'
}

export class HttpClient<SecurityDataType = unknown> {
  public instance: AxiosInstance
  private securityData: SecurityDataType | null = null
  private securityWorker?: ApiConfig<SecurityDataType>['securityWorker']
  private secure?: boolean
  private format?: ResponseType

  constructor({ securityWorker, secure, format, ...axiosConfig }: ApiConfig<SecurityDataType> = {}) {
    this.instance = axios.create({
      ...axiosConfig,
      baseURL: axiosConfig.baseURL || 'https://integration-api.getfront.com'
    })
    this.secure = secure
    this.format = format
    this.securityWorker = securityWorker
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data
  }

  protected mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig {
    const method = params1.method || (params2 && params2.method)

    return {
      ...this.instance.defaults,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...((method && this.instance.defaults.headers[method.toLowerCase() as keyof HeadersDefaults]) || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {})
      }
    }
  }

  protected stringifyFormItem(formItem: unknown) {
    if (typeof formItem === 'object' && formItem !== null) {
      return JSON.stringify(formItem)
    } else {
      return `${formItem}`
    }
  }

  protected createFormData(input: Record<string, unknown>): FormData {
    return Object.keys(input || {}).reduce((formData, key) => {
      const property = input[key]
      const propertyContent: any[] = property instanceof Array ? property : [property]

      for (const formItem of propertyContent) {
        const isFileType = formItem instanceof Blob || formItem instanceof File
        formData.append(key, isFileType ? formItem : this.stringifyFormItem(formItem))
      }

      return formData
    }, new FormData())
  }

  public request = async <T = any, _E = any>({
    secure,
    path,
    type,
    query,
    format,
    body,
    ...params
  }: FullRequestParams): Promise<AxiosResponse<T>> => {
    const secureParams =
      ((typeof secure === 'boolean' ? secure : this.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {}
    const requestParams = this.mergeRequestParams(params, secureParams)
    const responseFormat = format || this.format || undefined

    if (type === ContentType.FormData && body && body !== null && typeof body === 'object') {
      body = this.createFormData(body as Record<string, unknown>)
    }

    if (type === ContentType.Text && body && body !== null && typeof body !== 'string') {
      body = JSON.stringify(body)
    }

    return this.instance.request({
      ...requestParams,
      headers: {
        ...(requestParams.headers || {}),
        ...(type && type !== ContentType.FormData ? { 'Content-Type': type } : {})
      },
      params: query,
      responseType: responseFormat,
      data: body,
      url: path
    })
  }
}

/**
 * @title Front Financial Integration Catalog API
 * @version 1.0
 * @baseUrl https://integration-api.getfront.com
 *
 * Front Integration Catalog allows users of client applications to connect accounts of financial institutions. Front Integration Catalog handles credential validation, multi-factor authentication, and error handling for each institution. After the account is connected, Front Integration Catalog allows client applications to get account information, such as holdings, transactions, balances.
 */
export class FrontApi<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
  assets = {
    /**
     * No description
     *
     * @tags Assets
     * @name V1AssetsDetail
     * @summary Get available assets
     * @request GET:/api/v1/assets/{assetType}
     * @secure
     * @response `200` `AssetPaginationResponseIApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1AssetsDetail: (
      assetType: 'equity' | 'cryptocurrency',
      query?: {
        Search?: string
        /** @format int32 */
        Count?: number
        /** @format int32 */
        Offset?: number
      },
      params: RequestParams = {}
    ) =>
      this.request<AssetPaginationResponseIApiResult, ApiResult>({
        path: `/api/v1/assets/${assetType}`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * No description
     *
     * @tags Assets
     * @name V1AssetsEquityPriceDetail
     * @summary Get symbol price
     * @request GET:/api/v1/assets/equity/{symbol}/price
     * @secure
     * @response `200` `B2BPriceInfoIApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1AssetsEquityPriceDetail: (symbol: string, params: RequestParams = {}) =>
      this.request<B2BPriceInfoIApiResult, ApiResult>({
        path: `/api/v1/assets/equity/${symbol}/price`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      })
  }
  balance = {
    /**
     * @description Get real-time account fiat balances.
     *
     * @tags Balance
     * @name V1BalanceGetCreate
     * @summary Get account balance
     * @request POST:/api/v1/balance/get
     * @secure
     * @response `200` `B2BBrokerAccountBalanceModelIApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1BalanceGetCreate: (data: BrokerBaseRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerAccountBalanceModelIApiResult, ApiResult>({
        path: `/api/v1/balance/get`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get cached aggregated fiat balances from all connected integrations.
     *
     * @tags Balance
     * @name V1BalancePortfolioList
     * @summary Get aggregated portfolio fiat balances
     * @request GET:/api/v1/balance/portfolio
     * @secure
     * @response `200` `B2BFiatPortfolioModelIApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1BalancePortfolioList: (
      query?: {
        /** End user ID to get the aggregated portfolio for. */
        UserId?: string
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BFiatPortfolioModelIApiResult, ApiResult>({
        path: `/api/v1/balance/portfolio`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      })
  }
  managedAccountAuthentication = {
    /**
     * @description Get personalized catalog link for client
     *
     * @tags Managed Account Authentication
     * @name V1CataloglinkList
     * @summary Get catalog link
     * @request GET:/api/v1/cataloglink
     * @secure
     * @response `200` `CatalogLinkIApiResult` Catalog link created.
     * @response `400` `ApiResult` BadRequest can happen in following cases: <list type="number"><item><description>userId parameter not specified</description></item><item><description>Callback url parameter is invalid</description></item><item><description>Client does not have callback url specified</description></item></list>
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` API Client not found.
     */
    v1CataloglinkList: (
      query?: {
        /**
         * A unique Id representing the end user. Typically this will be a user Id from the
         *             client application. Personally identifiable information, such as an email address or phone number,
         *             should not be used.
         */
        userId?: string
        /** Type of broker to redirect to. Will redirect to catalog if not provided. */
        brokerType?: BrokerType
        /**
         * Callback link - url to redirect user after authentication in brokerage account.
         * If not provided default client's url will be used.
         */
        callbackUrl?: string
      },
      params: RequestParams = {}
    ) =>
      this.request<CatalogLinkIApiResult, ApiResult>({
        path: `/api/v1/cataloglink`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Get personalized catalog link for client supplying parameters for Link actions, such as transfers
     *
     * @tags Managed Account Authentication
     * @name V1CataloglinkCreate
     * @summary Get catalog link with parameters
     * @request POST:/api/v1/cataloglink
     * @secure
     * @response `200` `CatalogLinkIApiResult` Catalog link created.
     * @response `400` `ApiResult` BadRequest can happen in following cases: <list type="number"><item><description>userId parameter not specified</description></item><item><description>Callback url parameter is invalid</description></item><item><description>Client does not have callback url specified</description></item></list>
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` API Client not found.
     */
    v1CataloglinkCreate: (
      query: {
        /**
         * A unique Id representing the end user. Typically this will be a user Id from the
         *             client application. Personally identifiable information, such as an email address or phone number,
         *             should not be used.
         */
        userId: string
        /** Type of broker to redirect to. Will redirect to catalog if not provided. */
        brokerType?: BrokerType
        /**
         * Callback link - url to redirect user after authentication in brokerage account.
         * If not provided default client's url will be used.
         */
        callbackUrl?: string
        /**
         * Specifies if created Catalog Link session should allow transfers to be executed using the Link UI
         * @default false
         */
        enableTransfers?: boolean
      },
      data: InitializeTransfersForLinkRequest,
      params: RequestParams = {}
    ) =>
      this.request<CatalogLinkIApiResult, ApiResult>({
        path: `/api/v1/cataloglink`,
        method: 'POST',
        query: query,
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Refresh auth token of the connected institution. Some institutions do not require tokens to be refreshed. The following institutions require custom flows: WeBull: AuthToken should be provided along with the RefreshToken TdAmeritrade: refresh token should also be refreshed. CreateNewRefreshToken parameter should be set to true in order to refresh the refresh token for TdAmeritrade. Vanguard: security settings may activate MFA, requiring user action. If MFA is triggered, a second refresh request should be sent. Second request should contain MFA code and access token obtained from initial response. Bitfinex Direct: Expired Access Token is used as Refresh token. Use this endpoint to trade it for a new one
     *
     * @tags Managed Account Authentication
     * @name V1TokenRefreshCreate
     * @summary Refresh auth token
     * @request POST:/api/v1/token/refresh
     * @secure
     * @response `200` `B2BBrokerRefreshTokenResponseIApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1TokenRefreshCreate: (data: BrokerRefreshTokenRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerRefreshTokenResponseIApiResult, ApiResult>({
        path: `/api/v1/token/refresh`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Remove connection to the financial institution and erase all related data completely.
     *
     * @tags Managed Account Authentication
     * @name V1AccountDelete
     * @summary Remove connection
     * @request DELETE:/api/v1/account
     * @secure
     * @response `200` `IApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1AccountDelete: (data: BrokerBaseRequest, params: RequestParams = {}) =>
      this.request<IApiResult, ApiResult>({
        path: `/api/v1/account`,
        method: 'DELETE',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get the list of supported institutions and their health statuses.
     *
     * @tags Managed Account Authentication
     * @name V1StatusList
     * @summary Get health status
     * @request GET:/api/v1/status
     * @secure
     * @response `200` `B2BBrokersHealthStatusListIApiResult` Success
     * @response `401` `any` Unauthorized
     */
    v1StatusList: (params: RequestParams = {}) =>
      this.request<B2BBrokersHealthStatusListIApiResult, any>({
        path: `/api/v1/status`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      })
  }
  selfManagedAccountAuthentication = {
    /**
     * @description Get authentication schemes of available integrations to perform authentication programmatically (not using the Web Catalog UI).
     *
     * @tags Self Managed Account Authentication
     * @name V1AuthenticationSchemesList
     * @summary Get authentication schemes
     * @request GET:/api/v1/authenticationSchemes
     * @secure
     * @response `200` `BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult` Success
     * @response `401` `any` Unauthorized
     */
    v1AuthenticationSchemesList: (params: RequestParams = {}) =>
      this.request<BrokerAuthenticationSchemeIReadOnlyCollectionIApiResult, any>({
        path: `/api/v1/authenticationSchemes`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Get supported cryptocurrency wallets and cryptocurrency addresses to perform authentication programmatically (not using the Web Catalog UI).
     *
     * @tags Self Managed Account Authentication
     * @name V1CryptocurrencyWalletsList
     * @summary Get supported wallets
     * @request GET:/api/v1/cryptocurrencyWallets
     * @secure
     * @response `200` `BrokerCryptocurrencyWalletListResponseIApiResult` Success
     * @response `401` `any` Unauthorized
     */
    v1CryptocurrencyWalletsList: (params: RequestParams = {}) =>
      this.request<BrokerCryptocurrencyWalletListResponseIApiResult, any>({
        path: `/api/v1/cryptocurrencyWallets`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Authenticate user's brokerage/exchange account programmatically (not using the Web Catalog UI)
     *
     * @tags Self Managed Account Authentication
     * @name V1AuthenticateCreate
     * @summary Authenticate user's account
     * @request POST:/api/v1/authenticate
     * @secure
     * @response `200` `B2BBrokerAuthResponseIApiResult` Success
     * @response `400` `ProblemDetails` Bad Request
     * @response `500` `void` Server Error
     * @response `503` `void` Server Error
     */
    v1AuthenticateCreate: (
      query: {
        /** Id of the end-user */
        userId: string
      },
      data: B2BBrokerAuthRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerAuthResponseIApiResult, ProblemDetails | void>({
        path: `/api/v1/authenticate`,
        method: 'POST',
        query: query,
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType
     *
     * @tags Self Managed Account Authentication
     * @name V1AuthenticateDetail
     * @summary Get OAuth authentication link
     * @request GET:/api/v1/authenticate/{brokerType}
     * @secure
     * @response `200` `B2BBrokerAuthPromptResponseIApiResult` Success
     * @response `400` `ProblemDetails` Bad Request
     */
    v1AuthenticateDetail: (
      brokerType:
        | 'robinhood'
        | 'eTrade'
        | 'alpaca'
        | 'tdAmeritrade'
        | 'weBull'
        | 'stash'
        | 'interactiveBrokers'
        | 'public'
        | 'coinbase'
        | 'kraken'
        | 'coinbasePro'
        | 'cryptoCom'
        | 'openSea'
        | 'binanceUs'
        | 'gemini'
        | 'cryptocurrencyAddress'
        | 'cryptocurrencyWallet'
        | 'okCoin'
        | 'bittrex'
        | 'kuCoin'
        | 'etoro'
        | 'cexIo'
        | 'binanceInternational'
        | 'bitstamp'
        | 'gateIo'
        | 'celsius'
        | 'acorns'
        | 'okx'
        | 'bitFlyer'
        | 'coinlist'
        | 'huobi'
        | 'bitfinex'
        | 'deFiWallet'
        | 'krakenDirect'
        | 'vanguard'
        | 'binanceInternationalDirect'
        | 'bitfinexDirect',
      query: {
        /** Id of the end-user */
        userId: string
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerAuthPromptResponseIApiResult, ProblemDetails>({
        path: `/api/v1/authenticate/${brokerType}`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      })
  }
  managedTransfers = {
    /**
     * @description **Get the list of all networks supported by the Front API to perform transfers.** <br /> --- Returns the list of all networks supported by the Front API and corresponding supported tokens. The IDs of networks should be used to configure and initiate transfers.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedNetworksList
     * @summary Get networks
     * @request GET:/api/v1/transfers/managed/networks
     * @secure
     * @response `200` `NetworkModelResponseIApiResult` Success
     * @response `401` `any` Unauthorized
     */
    v1TransfersManagedNetworksList: (params: RequestParams = {}) =>
      this.request<NetworkModelResponseIApiResult, any>({
        path: `/api/v1/transfers/managed/networks`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description **Get the list of all integrations supported by the Front API to perform managed transfers.** <br /> --- Returns the list of all integrations currently supported by the Front API and corresponding supported tokens and networks. The IDs of networks should be used to configure and initiate transfers.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedIntegrationsList
     * @summary Get integrations
     * @request GET:/api/v1/transfers/managed/integrations
     * @secure
     * @response `200` `IntegrationNetworkResponseIApiResult` Success
     * @response `401` `any` Unauthorized
     */
    v1TransfersManagedIntegrationsList: (params: RequestParams = {}) =>
      this.request<IntegrationNetworkResponseIApiResult, any>({
        path: `/api/v1/transfers/managed/integrations`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description **Get the list of networks and tokens eligible for a transfer, based on the provided request data.** <br /> --- Transfers can be configured either from one connected account to another connected account, or from a connected account to any arbitrary address or addresses. <br /> * **From one connected account to another connected account:** <br /> The API client provides `FromAuthToken` that is representing the source account and `ToAuthToken` that is representing the target account. Front API maps networks and tokens supported by both accounts and returns all tokens and networks eligible for a transfer as the result. <br /> * **From a connected account to any arbitrary address:** <br /> The API client provides `FromAuthToken` that is representing the source account and the list of target addresses using the `ToAddresses` field. Front API verifies the addresses and returns the list of tokens, eligible to be transferred as the result of the operation. <br /><br /> Returns the list of holdings on the account that can be used to perform the transfer. Each holdings item contains the list of supported networks that can be used to transfer the corresponding asset. Each network contains details such as gas fees and the amount eligible to be transferred.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedConfigureCreate
     * @summary Configure transfer
     * @request POST:/api/v1/transfers/managed/configure
     * @secure
     * @response `200` `ConfigureTransferResponseIApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1TransfersManagedConfigureCreate: (data: ConfigureTransferRequest, params: RequestParams = {}) =>
      this.request<ConfigureTransferResponseIApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/configure`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description **Validate and preview the transfer.** <br /> --- Validates the transfer, calculates the relevant amount in crypto if requested amount was in fiat and updates the current network fee values. <br /> This endpoint uses the `NetworkId` field to specify which network will be used to perform the transfer. The target `NetworkId` should be selected after configuring the transfer using `/configure` endpoint. <br /><br /> Returns the `PreviewId` value that can be used to commit the transfer.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedPreviewCreate
     * @summary Preview transfer
     * @request POST:/api/v1/transfers/managed/preview
     * @secure
     * @response `200` `PreviewTransferResponseIApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1TransfersManagedPreviewCreate: (data: PreviewTransferRequest, params: RequestParams = {}) =>
      this.request<PreviewTransferResponseIApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/preview`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description **Commit the previously previewed transfer.** <br /> --- Previews the transfer, using the `PreviewId` value. <br /> Handles multi-factor authentication codes if the account is configured to use them for additional security. <br /><br /> Returns the status of the transfer and the details of the transfer if it was initiated successfully.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedExecuteCreate
     * @summary Execute transfer
     * @request POST:/api/v1/transfers/managed/execute
     * @secure
     * @response `200` `ExecuteTransferResponseIApiResult` Success
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1TransfersManagedExecuteCreate: (data: ExecuteTransferRequest, params: RequestParams = {}) =>
      this.request<ExecuteTransferResponseIApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/execute`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      })
  }
  news = {
    /**
     * @description Retrieve news related to the symbol in the request.
     *
     * @tags News
     * @name V1NewsStockList
     * @summary Retrieve news related to the symbol in the request
     * @request GET:/api/v1/news/stock
     * @secure
     * @response `200` `B2BSymbolNewsResponseIApiResult` The list of news related to the symbol.
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1NewsStockList: (
      query?: {
        /**
         * Lower timestamp limit of the news. If not speciefied news will be returned from the last 7 days.
         * @format int64
         */
        From?: number
        /**
         * Upper timestamp limit of the news. If not speciefied news will be returned up to the current time.
         * @format int64
         */
        To?: number
        /** Specifies which symbol's news should be returned. */
        Symbol?: string
        /**
         * The number of news to return. If not specified the maximum 25 value will be used.
         * @format int32
         */
        Count?: number
        /**
         * The offset which is used for paginatin the result set.
         * @format int32
         */
        Offset?: number
        /** Specifies the sorting criteria of the news. By default the most relevant news will be returned first. */
        Order?: 'rank' | 'timestamp'
        /** Specifies the soring direction of the result set. */
        SortDirection?: 'ascending' | 'descending'
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BSymbolNewsResponseIApiResult, ApiResult>({
        path: `/api/v1/news/stock`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Retrieve news related to the symbol in the request.
     *
     * @tags News
     * @name V1NewsCryptocurrencyList
     * @summary Retrieve news related to the cryptocurrency symbol in the request
     * @request GET:/api/v1/news/cryptocurrency
     * @secure
     * @response `200` `B2BSymbolNewsResponseIApiResult` The list of news related to the symbol.
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1NewsCryptocurrencyList: (
      query?: {
        /**
         * Lower timestamp limit of the news. If not speciefied news will be returned from the last 7 days.
         * @format int64
         */
        From?: number
        /**
         * Upper timestamp limit of the news. If not speciefied news will be returned up to the current time.
         * @format int64
         */
        To?: number
        /** Specifies which symbol's news should be returned. */
        Symbol?: string
        /**
         * The number of news to return. If not specified the maximum 25 value will be used.
         * @format int32
         */
        Count?: number
        /**
         * The offset which is used for paginatin the result set.
         * @format int32
         */
        Offset?: number
        /** Specifies the sorting criteria of the news. By default the most relevant news will be returned first. */
        Order?: 'rank' | 'timestamp'
        /** Specifies the soring direction of the result set. */
        SortDirection?: 'ascending' | 'descending'
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BSymbolNewsResponseIApiResult, ApiResult>({
        path: `/api/v1/news/cryptocurrency`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      })
  }
  portfolio = {
    /**
     * @description Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.
     *
     * @tags Portfolio
     * @name V1HoldingsGetCreate
     * @summary Get holdings
     * @request POST:/api/v1/holdings/get
     * @secure
     * @response `200` `B2BBrokerPortfolioModelIApiResult` Holdings obtained
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1HoldingsGetCreate: (data: BrokerBaseRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerPortfolioModelIApiResult, ApiResult>({
        path: `/api/v1/holdings/get`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get suggested portfolio optimizations based on different annualized standard deviations and performance.
     *
     * @tags Portfolio
     * @name V1HoldingsOptimizeList
     * @summary Get optimized portfolio
     * @request GET:/api/v1/holdings/optimize
     * @secure
     * @response `200` `B2BPortfolioOptimizationModelIApiResult` Portfolio optimized
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1HoldingsOptimizeList: (
      query?: {
        /** Id of the end user to get the optimization of the aggregated portfolio for. */
        UserId?: string
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BPortfolioOptimizationModelIApiResult, ApiResult>({
        path: `/api/v1/holdings/optimize`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Get the aggregated portfolio of the user containing market values.
     *
     * @tags Portfolio
     * @name V1HoldingsPortfolioList
     * @summary Get aggregated portfolio
     * @request GET:/api/v1/holdings/portfolio
     * @secure
     * @response `200` `B2BPortfolioModelIApiResult` Portfolio obtained
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1HoldingsPortfolioList: (
      query?: {
        /** End user ID to get the aggregated portfolio for. */
        UserId?: string
        /**
         * Offset in second, used to calculate daily return for cryptocurrencies.
         * @format int64
         */
        TimezoneOffset?: number
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BPortfolioModelIApiResult, ApiResult>({
        path: `/api/v1/holdings/portfolio`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      })
  }
  transactions = {
    /**
     * @description Get transactions on the account - the paginated history of the executed orders along with the pending orders.
     *
     * @tags Transactions
     * @name V1TransactionsListCreate
     * @summary Get transactions
     * @request POST:/api/v1/transactions/list
     * @secure
     * @response `200` `B2BBrokerOrderListResponseIApiResult` Transactions obtained.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     */
    v1TransactionsListCreate: (data: B2BBrokerOrderListRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerOrderListResponseIApiResult, any>({
        path: `/api/v1/transactions/list`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get details of an executed order. Typically used to poll the status of the previously executed order.
     *
     * @tags Transactions
     * @name V1TransactionsDetailsCreate
     * @summary Get transaction details
     * @request POST:/api/v1/transactions/details
     * @secure
     * @response `200` `B2BBrokerOrderIApiResult` Transactions obtained.
     * @response `400` `ProblemDetails` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     * @response `404` `ProblemDetails` Transaction is not found.
     */
    v1TransactionsDetailsCreate: (data: B2BBrokerOrderRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerOrderIApiResult, ProblemDetails>({
        path: `/api/v1/transactions/details`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get supported features for trading for a particular financial institution. Different institutions support different features (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to describe such features for provided financial institution.
     *
     * @tags Transactions
     * @name V1TransactionsFeatureListCreate
     * @summary Get supported order features for institution
     * @request POST:/api/v1/transactions/featureList
     * @secure
     * @response `200` `B2BBrokerTradingFeatureInfoIApiResult` Feature list obtained.
     * @response `400` `ProblemDetails` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     */
    v1TransactionsFeatureListCreate: (data: BrokerBaseRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerTradingFeatureInfoIApiResult, ProblemDetails>({
        path: `/api/v1/transactions/featureList`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Validates the order information (such as necessary balance availability), and returns additional information, such as expected order fee. Does not execute the order.
     *
     * @tags Transactions
     * @name V1TransactionsPreviewCreate
     * @summary Preview order execution
     * @request POST:/api/v1/transactions/preview/{side}
     * @secure
     * @response `200` `B2BBrokerPreviewOrderResultIApiResult` Order preview obtained.
     * @response `400` `ProblemDetails` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     */
    v1TransactionsPreviewCreate: (
      side: 'unknown' | 'buy' | 'sell',
      data: B2BBrokerCreateOrderRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerPreviewOrderResultIApiResult, ProblemDetails>({
        path: `/api/v1/transactions/preview/${side}`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Validates the order information and then calls institution's API to execute an order. It's recommended to call this endpoint after calling the `preview` endpoint to make sure that the order execution request is correct.
     *
     * @tags Transactions
     * @name V1TransactionsCreate
     * @summary Execute order
     * @request POST:/api/v1/transactions/{side}
     * @secure
     * @response `200` `B2BBrokerCreateOrderResultIApiResult` Order executed.
     * @response `400` `ProblemDetails` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     */
    v1TransactionsCreate: (
      side: 'unknown' | 'buy' | 'sell',
      data: B2BBrokerCreateOrderRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerCreateOrderResultIApiResult, ProblemDetails>({
        path: `/api/v1/transactions/${side}`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Cancels a pending order (an order with `InProgress` status). `SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions. This value
     *
     * @tags Transactions
     * @name V1TransactionsCancelCreate
     * @summary Cancel order execution
     * @request POST:/api/v1/transactions/cancel
     * @secure
     * @response `200` `IApiResult` Order canceled.
     * @response `400` `ProblemDetails` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     * @response `404` `ProblemDetails` Not Found
     */
    v1TransactionsCancelCreate: (data: B2BBrokerOrderRequest, params: RequestParams = {}) =>
      this.request<IApiResult, ProblemDetails>({
        path: `/api/v1/transactions/cancel`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Returns information on trading allowance for a provided symbol. For example - some institutions allow fractional trading for some symbols, but do not allow it for others. So before placing an order the API client can check if the required symbol can be traded fractionally with the provided institution.
     *
     * @tags Transactions
     * @name V1TransactionsSymbolinfoCreate
     * @summary Get symbol information
     * @request POST:/api/v1/transactions/symbolinfo
     * @secure
     * @response `200` `B2BBrokerOrderSymbolInfoIApiResult` Information for symbol obtained.
     * @response `400` `ProblemDetails` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct.
     */
    v1TransactionsSymbolinfoCreate: (data: B2BBrokerSymbolInfoForOrderRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerOrderSymbolInfoIApiResult, ProblemDetails>({
        path: `/api/v1/transactions/symbolinfo`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      })
  }
  transfers = {
    /**
     * @description Get cryptocurrency transfers, such as transfers on a cryptocurrency wallet, or deposit/withdrawal transfers on an cryptocurrency exchange account.
     *
     * @tags Transfers
     * @name V1TransfersListCreate
     * @summary List transfers
     * @request POST:/api/v1/transfers/list
     * @secure
     * @response `200` `B2BBrokerTransactionsListModelIApiResult` Transfers obtained.
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1TransfersListCreate: (data: BrokerTransactionsListRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerTransactionsListModelIApiResult, ApiResult>({
        path: `/api/v1/transfers/list`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get details of a cryptocurrency transfer.
     *
     * @tags Transfers
     * @name V1TransfersDetailsCreate
     * @summary Get transfer
     * @request POST:/api/v1/transfers/details
     * @secure
     * @response `200` `B2BBrokerCryptocurrencyTransactionIApiResult` Transfer details obtained.
     * @response `400` `ApiResult` Transfer details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` Transfer with provided id was not found.
     */
    v1TransfersDetailsCreate: (data: BrokerCryptocurrencyTransactionDetailsRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerCryptocurrencyTransactionIApiResult, ApiResult>({
        path: `/api/v1/transfers/details`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange.
     *
     * @tags Transfers
     * @name V1TransfersCreate
     * @summary Initiate a transfer
     * @request POST:/api/v1/transfers
     * @secure
     * @response `200` `B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult` Transfer successfully initiated.
     * @response `400` `ApiResult` Transfer details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1TransfersCreate: (data: BrokerCreateCryptocurrencyTransactionRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerCreateCryptocurrencyTransactionResponseIApiResult, ApiResult>({
        path: `/api/v1/transfers`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
     *
     * @tags Transfers
     * @name V1TransfersAddressGetCreate
     * @summary Get deposit address
     * @request POST:/api/v1/transfers/address/get
     * @secure
     * @response `200` `B2BBrokerCryptocurrencyDepositAddressResponseIApiResult` Address successfully obtained or generation initiated.
     * @response `400` `ApiResult` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` Address for the required symbol is not found.
     */
    v1TransfersAddressGetCreate: (data: BrokerCryptocurrencyDepositAddressRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerCryptocurrencyDepositAddressResponseIApiResult, ApiResult>({
        path: `/api/v1/transfers/address/get`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple blockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.
     *
     * @tags Transfers
     * @name V1TransfersSymbolDetailsCreate
     * @summary Get details of asset
     * @request POST:/api/v1/transfers/symbol/details
     * @secure
     * @response `200` `B2BBrokerCryptocurrencySymbolDetailsResponseIApiResult` Address successfully obtained or generation initiated.
     * @response `400` `ApiResult` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` Asset details for provided symbol are not found.
     */
    v1TransfersSymbolDetailsCreate: (data: BrokerCryptocurrencyDepositAddressRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerCryptocurrencySymbolDetailsResponseIApiResult, ApiResult>({
        path: `/api/v1/transfers/symbol/details`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      })
  }
}
